<html>
<head>
<title>mdx9_fase11-3</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}


.sc1 {
	color: darkgreen;
	font-weight: bold;
}

.sntx {
	color: darkgreen;
	}


.sc2 {
	color: #008000;
}
.sc4 {
	color: #ff8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #FF0000;
}
.sc9 {
	color: #804000;
	font-weight: bold;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #400080;
}

.prg {
	color: #0000FF;
}

.prg-saida {

	margin-left:0px;
	width:500pt;
	background-color:lightblue;	
}

.prg-code {
	margin-left:0px;
	width:515pt;
	background-color:lightyellow;
	padding:10px;
	font-weight:bold;
}


.niceview {
	margin-left:0px;
	width:500pt;
	background-color:white;
	border-color:lightgray;
	border-width:1px;
	border-style:solid;
	padding:10px;
}

td
{
padding:3px;
}

table.dados
{
margin-left:0px;
width:53.5em;
border-collapse:collapse;
border:1px solid red;
text-align:center;
}

th
{
background-color:darkgreen;
color:yellow;
font-weight:bold;
text-transform:uppercase;
}

.pagebody
{
padding:10px;
margin-left:50px;
border-width:1px;
border-style:solid;
border-color:white;
background-color:white;
width:90%;
}
.mybody
{
margin-top:20pt;
margin-bottom:20pt;
margin-left:20pt;
margin-right:20pt;
border-color:lightgray;
background-image:url('background.png');
}
</style>
</head>
<body class=mybody><font color='black'>
<div class=pagebody>
<hr>
<center><b style='font-size:1.5em;' >Curso completo de DirectX Gerenciado</b><br>
Gameprog - Escola de programação de jogos digitais<br>
Contato: gameprog.br@gmail.com<br>
<b>Fase 11-3</b></center>
<hr>
<table align='left' border='0' cellspacing='0' cellpadding='0' width='20%'>
<tr><td><a href='mdx9.html#start' style='color:blue'> index </a></td>
<td><a href='track11-2.html' style='color:blue'>&lt;&lt;</a></td>
<td><a href='track11-4.html' style='color:blue'>&gt;&gt;</a></td></tr></table><br><pre>
<hr><a name='topo'></a>
<h3 style='background-color:#80ff80'>11.3 Simplicação com Mesh.Simplify()</h3><pre>
<b><u>1.1 Visão geral</b></u>
<div class=prg-code><img src=images\prj_Simplificar.png></div>
O método <b class=prg>Mesh.Simplify()</b> produz uma cópia simplificada  do  modelo 3d
apresentado.   A  finalidade  da  simplificação é reduzir o número de
vértices  do  objeto  mas isto ocorre ao custo da consequente redução
da beleza visual do modelo 3d.  O uso de modelos simplificados é util
para  reduzir  a carga de processamento da aplicação 3d. Geralmente o
uso de versões simplificadas  dos  modelos detalhados  ocorre  quando
estes objetos estão longe numa cena.

<b><u>1.2 Estrutura principal da aplicação</b></u>
<div class=prg-code>
<img src=images\esquema_prj_Simplificar.png></div>
Esta aplicação mostra um modelo 3d e uma versão simplificada do mesmo.
Pressione <b>W</b> para ligar ou desligar o modo de  renderização  wireframe.
Para salvar o modelo simplificado no disco pressione <b>S</b>;   isso é útil
porque o processo de simplificação é lento  sendo  mais  interessante
fazê-lo   em   um   programa  utilitário separado e depois carregar o 
modelo simplificado normalmente na aplicação principal.

A base inicial dessa aplicação é o <b>prj_Modelo3d</b> do tópico 4.4 que foi
adaptado para este tópico.A função <b>CarregarModelo()</b> sofreu alterações
leves  com  a variável <b>xMtl</b> saindo do escopo local indo para o escopo
global da classe para ser utilizada também na função <b>salvarModelo()</b>.

Antes da aplicação do processo de simplificação ocorre um processo de
limpeza  do  mesh  no  qual  o  motor  do DirectX expande os vértices
compartilhados  em  primitivas  com  a  formação de <b>TriangleFan</b> vista
no tópico 4.1. Antes do processo de limpeza, o método que  carrega  o
modelo <b class=prg>Mesh.FromFile()</b> retorna a informação de adjacências que indica
'quem é vizinho de quem' do ponto de vista das faces  do  mesh;  esta
informação  de  adjacências  é  colocada  na  variável  <b>adj</b>  do  tipo
<b class=prg>GraphicsStream</b> e é utilizada na função <b>gerarModeloSimplificado()</b>.

<b><u>2.1 Variáveis da classe</u></b>
<div class=niceview><span class=prg>public </span><span class=prg>partial </span><span class=prg>class </span>Tela : <span class=sc5>Form</span>
<span class=sc16>{</span>
 <span class=sc2>// Para criação do dispositivo gráfico</span>
 <span class=prg>private </span><span class=sc5>Device </span>device = <span class=prg>null;</span>

 <span class=sc2>// Essa variável atualizada a cada ciclo ocasionará</span>
 <span class=sc2>// a animação do objeto</span>
 <span class=prg>private </span><span class=prg>float </span>angulo = <span class=sc4>0.0f;</span>

 <span class=sc2>// Variável para guardar as malhas 3d</span>
 <span class=prg>private </span><span class=sc5>Mesh </span>objeto3D = <span class=prg>null;</span>
 <span class=prg>private </span><span class=sc5>Mesh </span>mesh_limpo = <span class=prg>null;</span>
 <span class=prg>private </span><span class=sc5>Mesh </span>mesh_simplificado = <span class=prg>null;</span>

 <span class=sc2>// Variável para gravar informação de adjacências. Essa</span>
 <span class=sc2>// informação vai ser usada na função gerarModeloSimplificado()</span>
 <span class=sc5>GraphicsStream </span>adj; 

 <span class=sc2>// Controla modo wireframe ligado ou não</span>
 <span class=prg>bool </span>bWireframe = <span class=prg>false;</span>

 <span class=sc2>// Pacote de materiais e texturas do modelo 3d que</span>
 <span class=sc2>// precisa ser global na classe para ser utilizada também</span>
 <span class=sc2>// no método salvarModelo()</span>
 <span class=sc5>ExtendedMaterial</span>[] xMtl; 

 <span class=sc2>// Recipiente de materiais do mesh</span>
 <span class=prg>private </span><span class=sc5>Material</span>[] g_meshMtl = <span class=prg>null;</span>

 <span class=sc2>// Recipiente de texturas do mesh</span>
 <span class=prg>private </span><span class=sc5>Texture</span>[] g_meshTex = <span class=prg>null;</span>

 <span class=sc2>// Pasta de localização do arquivo mesh e sua textura</span>
 <span class=prg>private </span><span class=prg>string </span>diretorioBase = <span class=prg>null;</span>

 <span class=sc2>// Vetores para a posição e rotação do objeto 3d</span>
 <span class=sc5>Vector3 </span>posicao, rotacao; 

 <span class=sc2>// Variável global para propriedade dos objetos</span>
 Propriedades3D g_props; 

 <span class=sc2>// Objeto Font do DirectX para mostrar texto</span>
 <span class=prg>private </span><span class=prg>Direct3D.Font </span>dxfMensagem = <span class=prg>null;</span>

 <span class=sc2>// Objeto Font tradicional do namespace System.Drawing</span>
 <span class=prg>private </span><span class=prg>System.Drawing.Font </span>g_font = <span class=prg>null;</span>
</div><b>
<span class=prg>private </span><span class=sc5>Mesh </span>objeto3D = <span class=prg>null;</span>
<span class=prg>private </span><span class=sc5>Mesh </span>mesh_limpo = <span class=prg>null;</span>
<span class=prg>private </span><span class=sc5>Mesh </span>mesh_simplificado = <span class=prg>null;</span></b>
Destacamos aqui as variáveis globais para guardar o objeto 3d em seus
estágios original, limpo e simplificado.

<b><span class=sc5>GraphicsStream </span>adj; </b>
A informação de adjacência é preenchida  na função <b>CarregarModelo()</b> e 
utilizada na função <b>gerarModeloSimplificado()</b>.  Ela  também  é  usada
para salvar o modelo em disco mas na função de <b>salvarModelo()</b> geramos
esta informação dinamicamente para mostrar como se faz isso.

<b><span class=prg>bool </span>bWireframe = <span class=prg>false;</span></b>
Essa variável é usada para ligar ou desligar a visualização em wireframe.

<b><span class=sc5>ExtendedMaterial</span>[] xMtl; </b>
Esta variável recebe o pacote de materiais e texturas do objeto 3d na
função <b>CarregarModelo()</b>. Ela está no escopo  global  da  classe  pois
será necessária na função <b>salvarModelo()</b>.

<b><u>2.2 Inicializando a aplicação</u></b>
<div class=niceview><span class=prg>public </span><span class=prg>void </span>initGfx() 
<span class=sc16>{</span>
 <span class=sc2>// Configuração dos parâmetros de apresentação</span>
 <span class=sc5>PresentParameters </span>pps = <span class=prg>new </span><span class=sc5>PresentParameters</span>();  
 <span class=prg>pps.Windowed </span>= <span class=prg>true;</span>
 <span class=prg>pps.SwapEffect </span>= <span class=prg>SwapEffect.Discard;</span>

 <span class=sc2>// Ativando o buffer de profundidade</span>
 <span class=prg>pps.EnableAutoDepthStencil </span>= <span class=prg>true;</span>
 <span class=prg>pps.AutoDepthStencilFormat </span>= <span class=prg>DepthFormat.D16;</span>

 <span class=sc2>// Adaptador default, processamento no hardware, processamento de vértice</span>
 <span class=sc2>// no software, janela (this), parâmetros de apresentação (pps)</span>
 <span class=prg>int </span>adaptador = 0; 
 device = <span class=prg>new </span><span class=sc5>Device</span>(adaptador, <span class=prg>DeviceType.Hardware</span>, <span class=prg>this</span>, 
 <span class=prg>CreateFlags.SoftwareVertexProcessing</span>, pps);  

 <span class=sc2>// Configuração das fontes para mostrar mensagens</span>
 g_font = <span class=prg>new </span><span class=prg>System.Drawing.Font</span>(<span class=sc6>"Arial"</span>, <span class=sc4>12.0f</span>, <span class=prg>FontStyle.Bold</span>);  
 dxfMensagem = <span class=prg>new </span><span class=prg>Direct3D.Font</span>(device, g_font);  

 diretorioBase = <span class=sc6>@"c:\Gameprog\Gdkmedia\Modelos\Tiny\";</span>
 CarregarModelo(diretorioBase, <span class=sc6>"tiny.x"</span>);  
 gerarModeloSimplificado();
<span class=sc16>} <span class=sc2>// initGfx().fim</span></span>
</div><b>
diretorioBase = <span class=sc6>@"c:\Gameprog\Gdkmedia\Modelos\Tiny\";</span>
CarregarModelo(diretorioBase, <span class=sc6>"tiny.x"</span>);  </b>
Esta função que carrega o modelo foi levemente modificada para extrair
dela a informação de adjacência utilizada  para  limpar  ou  salvar  o
modelo.

<b>gerarModeloSimplificado();  </b>
Chamamos aqui a função que gera o modelo simplificado.

<b><u>2.3 Carregando o modelo 3d</u></b>
<div class=niceview><span class=prg>private </span><span class=prg>void </span>CarregarModelo(<span class=prg>string </span>diretorioBase, <span class=prg>string </span>arquivo) 
<span class=sc16>{</span>
 <span class=sc2>// Composição do nome final do arquivo</span>
 <span class=prg>string </span>caminhoFinal = diretorioBase + arquivo; 

 <span class=sc2>// Recebe nome do arquivo de textura sendo carregado</span>
 <span class=prg>string </span>arquivo_textura = <span class=prg>null;</span>

 <span class=sc2>// Quantidade de materiais\texturas encontrados no modelo3d</span>
 <span class=prg>int </span>nTam = 0; 

 <span class=sc2>// Carrega modelo 3d com suas texturas e materiais e</span>
 <span class=sc2>// informação de adjacências</span>
 objeto3D = <span class=prg>Mesh.FromFile</span>(caminhoFinal, <span class=prg>MeshFlags.Managed</span>, 
 device, <span class=prg>out </span>adj, <span class=prg>out </span>xMtl);  

 <span class=sc2>// Verifica quantidade de texturas\materiais do modelo</span>
 nTam = <span class=prg>xMtl.Length;</span>

 <span class=sc2>// Carrega as texturas caso nTam &gt; 0</span>
 <span class=sc9>if </span>((xMtl != <span class=prg>null</span>)  && (nTam &gt; <span class=sc4>0</span>) ) 
 <span class=sc16>{</span>
 <span class=sc2>// Inicializa as variáveis arrays de materiais e texturas</span>
 g_meshMtl = <span class=prg>new </span><span class=sc5>Material</span>[nTam];  
 g_meshTex = <span class=prg>new </span><span class=sc5>Texture</span>[nTam];  

 <span class=prg>for </span>(<span class=prg>int </span>ncx = 0; ncx &lt; nTam; ncx++) 
 <span class=sc16>{</span>
   <span class=sc2>// Carrega materiais</span>
   g_meshMtl[ncx] = xMtl[ncx]<span class=prg>.Material3D;</span>

   <span class=sc2>// Carrega texturas</span>
   arquivo_textura = xMtl[ncx]<span class=prg>.TextureFilename;</span>
   <span class=sc9>if </span>((arquivo_textura != <span class=prg>null</span>)  && arquivo_textura != <span class=prg>String.Empty</span>)  
   <span class=sc16>{</span>
	 g_meshTex[ncx] = <span class=prg>TextureLoader.FromFile</span>(device, 
	   diretorioBase + arquivo_textura);  
   <span class=sc16>} <span class=sc2>// endif (texturas)</span></span>
  <span class=sc16>} <span class=sc2>// endfor (materiais\texturas)</span></span>
 <span class=sc16>} <span class=sc2>// endif (verificação de texturas\materiais presentes)</span></span>
<span class=sc16>} <span class=sc2>// CarregarModelo().fim</span></span>
</div><b>
<span class=sc2>// Carrega modelo 3d com suas texturas e materiais e</span>
<span class=sc2>// informação de adjacências</span>
objeto3D = <span class=prg>Mesh.FromFile</span>(caminhoFinal, <span class=prg>MeshFlags.Managed</span>, 
 device, <span class=prg>out </span>adj, <span class=prg>out </span>xMtl);  </b>
O grande destaque aqui é que  a  função  <span class=prg>Mesh.FromFile()</span>  preenche  a 
variável <b>adj</b> com informação de adjacências necessária para o processo
de limpeza e/ou salvamento do modelo em disco.

<b><u>2.4 Gerando o modelo simplificado</u></b>
<div class=niceview><span class=prg>private </span><span class=prg>void </span>gerarModeloSimplificado() 
<span class=sc16>{</span>
 <span class=sc2>// Limpeza do objeto 3d</span>
 mesh_limpo = <span class=prg>Mesh.Clean</span>(objeto3D, adj, adj);  

 <span class=sc2>// Geração do objeto simplificado</span>
 <span class=prg>int </span>nVerts_alvo = 1000; 
 mesh_simplificado = <span class=prg>Mesh.Simplify</span>(mesh_limpo, adj, <span class=prg>null</span>, nVerts_alvo, 
 <span class=prg>MeshFlags.SimplifyVertex</span>);  

<span class=sc16>} <span class=sc2>// gerarModeloSimplificado()</span></span>
</div><b>
mesh_limpo = <span class=prg>Mesh.Clean</span>(objeto3D, adj, adj);  </b>
Esta função retorna um mesh  limpo; em  seus  argumentos  de  entrada
inicialmente vem o mesh (<b>objeto3D</b>) e a variável de entrada e saida da
informação de adjacências no qual utilizamos a mesma variável (<b>adj</b>).

<b><span class=prg>int </span>nVerts_alvo = 1000; </b>
Esta variável representa o valor alvo desejado  de  simplificação  do
mesh configurado para ser reduzido a 1000 vértices.    A  função  não 
garante que o Mesh vai ser simplificado até alcançar esse patamar mas
tenta simplificar ao máximo.   Você pode configurar esse valor como 1
para garantir o máximo de simplificação que a função  <span class=prg>Mesh.Simplify()</span>
consegue  realizar  ainda  que  não  chegue  a  este  valor extremo!

<b>mesh_simplificado = <span class=prg>Mesh.Simplify</span>(mesh_limpo, adj, <span class=prg>null</span>, nVerts_alvo, 
<span class=prg>MeshFlags.SimplifyVertex</span>);  </b>
Com esta linha de código é obtido uma versão simplificada de um modelo
3d mais detalhado.

<b><u>2.5 Salvando o modelo simplificado em disco</u></b>
<div class=niceview><span class=prg>private </span><span class=prg>void </span>salvarModelo() 
<span class=sc16>{</span>
 <span class=sc2>// Define uma variável array para informação de adjacência</span>
 <span class=prg>int</span>[] modelo_adj = <span class=prg>new </span><span class=prg>int</span>[<span class=prg>mesh_simplificado.NumberFaces </span>* <span class=sc4>3 </span>];  

 <span class=sc2>// Gera informação de adjacência</span>
 <span class=prg>mesh_simplificado.GenerateAdjacency</span>(<span class=sc4>0.0f</span>, modelo_adj);  

 <span class=sc2>// Limpa o modelo</span>
 <span class=sc5>Mesh </span>meshLimpo = <span class=prg>Mesh.Clean</span>(mesh_simplificado, modelo_adj, 
 <span class=prg>out </span>modelo_adj);  

 <span class=sc2>// Salva o modelo simplificado em arquivo x modo texto</span>
 <span class=prg>meshLimpo.Save</span>(diretorioBase + <span class=sc6>"tinySimplificado.x"</span>, modelo_adj, 
 xMtl, <span class=prg>XFileFormat.Text</span>);  

 <span class=prg>meshLimpo.Dispose</span>();  

<span class=sc16>} <span class=sc2>// salvarModelo().fim</span></span>
</div><b>
<span class=sc2>// Define uma variável array para informação de adjacência</span>
<span class=prg>int</span>[] modelo_adj = <span class=prg>new </span><span class=prg>int</span>[<span class=prg>mesh_simplificado.NumberFaces </span>* <span class=sc4>3 </span>];  </b>
Esta linha cria o espaço necessário  para  guardar  a  informação  de
adjacências  na  variável  array  <b>modelo_adj</b>.   Visto  que  cada face 
triangular  tem  3  vértices  ligando-se  assim a 3 faces vizinhas, o
espaço necessário então é o triplo do número de faces  do  objeto  3d.

<b><span class=sc2>// Gera informação de adjacência</span>
<span class=prg>mesh_simplificado.GenerateAdjacency</span>(<span class=sc4>0.0f</span>, modelo_adj);  </b>
Nesta linha é gerado a informação de adjacências.


<b><span class=sc2>// Limpa o modelo</span>
<span class=sc5>Mesh </span>meshLimpo = <span class=prg>Mesh.Clean</span>(mesh_simplificado, modelo_adj, 
<span class=prg>out </span>modelo_adj);  </b>
Produzimos um modelo limpo.

<b><span class=sc2>// Salva o modelo simplificado em arquivo x modo texto</span>
<span class=prg>meshLimpo.Save</span>(diretorioBase + <span class=sc6>"tinySimplificado.x"</span>, modelo_adj, 
xMtl, <span class=prg>XFileFormat.Text</span>);  </b>
Enfim o modelo é salvo em um arquivo x formatado como texto.

<b><u>2.6 Renderizando a cena</u></b>
<div class=niceview><span class=prg>public </span><span class=prg>void </span>Renderizar() 
<span class=sc16>{</span>

 <span class=sc2>// Limpa os dispositivos e os buffers de apoio</span>
 <span class=prg>device.Clear</span>(<span class=prg>ClearFlags.Target </span>| <span class=prg>ClearFlags.ZBuffer</span>, 
 <span class=prg>Color.White.ToArgb</span>(), <span class=sc4>1.0f</span>, <span class=sc4>0</span>);  

 <span class=prg>device.BeginScene</span>();  
 <span class=sc2>// (...) Todo o código de desenhar vai aqui</span>

 <span class=sc2>// Atualiza a câmera</span>
 AtualizarCamera();  
 <span class=sc2>// Configuração de luz </span>
 <span class=prg>device.RenderState.Lighting </span>= <span class=prg>false;</span>

 <span class=sc2>// Posicionamento do primeiro modelo</span>
 posicao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>100.0f</span>, <span class=sc4>0.2f</span>, <span class=sc4>-100.0f</span>);  
 rotacao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>0</span>, <span class=sc4>0</span>, <span class=sc4>0</span>);  
 g_props = <span class=prg>new </span>Propriedades3D(posicao, rotacao);  
 desenharObjeto(objeto3D, g_props);  

 <span class=sc2>// Posicionamento do modelo simplificado</span>
 <span class=prg>g_props.position </span> = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>-100.0f</span>, <span class=sc4>0.2f</span>, <span class=sc4>-200.0f</span>);  
 desenharObjeto(mesh_simplificado, g_props);  

 <span class=sc2>// Mostra o número de vértices de cada modelo</span>
 <span class=prg>string </span>info; 
 info = <span class=prg>String.Format</span>(<span class=sc6>"Modelo limpo: {0}"</span>, 
 <span class=prg>mesh_limpo.NumberVertices</span>);  
 MostrarMensagem(20, 20, info);  

 info = <span class=prg>String.Format</span>(<span class=sc6>"simplificado: {0}"</span>, 
 <span class=prg>mesh_simplificado.NumberVertices</span>);  
 MostrarMensagem(220, 20, info);  

 info = <span class=prg>String.Format</span>(<span class=sc6>"original: {0}"</span>, 
 <span class=prg>objeto3D.NumberVertices</span>);  
 MostrarMensagem(420, 20, info);  

 <span class=prg>device.EndScene</span>();  

 <span class=sc2>// Apresenta a cena renderizada na tela</span>
 <span class=prg>device.Present</span>();  

 <span class=sc2>// Libera a janela para processar outros eventos</span>
 <span class=prg>Application.DoEvents</span>();  
<span class=sc16>} <span class=sc2>// Renderizar().fim</span></span>
</div><b>
<span class=sc2>// Posicionamento do primeiro modelo</span>
posicao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>100.0f</span>, <span class=sc4>0.2f</span>, <span class=sc4>-100.0f</span>);  
rotacao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>0</span>, <span class=sc4>0</span>, <span class=sc4>0</span>);  
g_props = <span class=prg>new </span>Propriedades3D(posicao, rotacao);  
desenharObjeto(objeto3D, g_props);  </b>
Esse código renderiza o objeto original.

<b><span class=sc2>// Posicionamento do modelo simplificado</span>
<span class=prg>g_props.position </span> = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>-100.0f</span>, <span class=sc4>0.2f</span>, <span class=sc4>-200.0f</span>);  
desenharObjeto(mesh_simplificado, g_props);  </b>
Esse código renderiza o objeto 3d simplificado.

<b><span class=sc2>// Mostra o número de vértices de cada modelo</span>
<span class=prg>string </span>info; 
info = <span class=prg>String.Format</span>(<span class=sc6>"Modelo limpo: {0}"</span>, 
<span class=prg>mesh_limpo.NumberVertices</span>);  
MostrarMensagem(20, 20, info);  </b>
Esse bloco de código mostra a quantidade de vértices do mesh limpo que
vai apresentar  um  número  maior  de vértices em virtude desta função
produzir um vértice para descompartilhar vértices em comum em formação
de triangleFan.   O  bloco  de  código abaixo mostra as informações de
quantidade de vértice do modelo simplificado e de sua versão original.
<b>
info = <span class=prg>String.Format</span>(<span class=sc6>"simplificado: {0}"</span>, 
<span class=prg>mesh_simplificado.NumberVertices</span>);  
MostrarMensagem(220, 20, info);  

info = <span class=prg>String.Format</span>(<span class=sc6>"original: {0}"</span>, 
<span class=prg>objeto3D.NumberVertices</span>);  
MostrarMensagem(420, 20, info);  </b>

<b><u>2.7 Tratando o teclado</u></b>
<div class=niceview><span class=prg>private </span><span class=prg>void </span>Tela_KeyDown(<span class=sc5>object </span>sender, <span class=sc5>KeyEventArgs </span>e) 
<span class=sc16>{</span>
 <span class=sc2>// A tecla W liga\desliga o modo wireframe</span>
 <span class=sc9>if </span>(<span class=prg>e.KeyCode </span>== <span class=prg>Keys.W</span>)  bWireframe = !bWireframe; 
 <span class=sc9>if </span>(bWireframe) <span class=prg>device.RenderState.FillMode </span>= <span class=prg>FillMode.WireFrame;</span>
 <span class=sc9>else </span><span class=prg>device.RenderState.FillMode </span>= <span class=prg>FillMode.Solid;</span>

 <span class=sc2>// A tecla S salva o modelo</span>
 <span class=sc9>if </span>(<span class=prg>e.KeyCode </span>== <span class=prg>Keys.S</span>)  salvarModelo();  

<span class=sc16>} <span class=sc2>// Tela_KeyDown().fim</span></span>
</div><b>
<span class=sc2>// A tecla W liga\desliga o modo wireframe</span>
<span class=sc9>if </span>(<span class=prg>e.KeyCode </span>== <span class=prg>Keys.W</span>)  bWireframe = !bWireframe; 
<span class=sc9>if </span>(bWireframe) <span class=prg>device.RenderState.FillMode </span>= <span class=prg>FillMode.WireFrame;</span>
<span class=sc9>else </span><span class=prg>device.RenderState.FillMode </span>= <span class=prg>FillMode.Solid;</span></b>
Esse bloco de código liga ou desliga a visualização em modo wireframe
do  modelo  3d  permutando entre o modo de preenchimento do modelo em
wireframe ou sólido.

<b><span class=sc2>// A tecla S salva o modelo</span>
<span class=sc9>if </span>(<span class=prg>e.KeyCode </span>== <span class=prg>Keys.S</span>)  salvarModelo();  </b>
A tecla S chama a função que salva o modelo em disco.

<b><u>3. Código fonte do projeto de exemplo:prj_Simplificar</u></b>
<div class=prg-code>
<img src=images\prj_Simplificar.png>

<span class=sc2>// prj_Simplificar - Arquivo: Tela.cs</span>
<span class=sc2>// Esse projeto mostra como simplificar um modelo 3D</span>
<span class=sc2>// utilizando o método Mesh.Simplify()</span>
<span class=sc2>// Produzido por www.gameprog.com.br</span>
<span class=sc16>using </span><span class=sc16>System;</span>
<span class=sc16>using </span><span class=prg>System.Drawing;</span>
<span class=sc16>using </span><span class=prg>System.ComponentModel;</span>
<span class=sc16>using </span><span class=prg>System.Windows.Forms;</span>
<span class=sc16>using </span><span class=prg>Microsoft.DirectX;</span>
<span class=sc16>using </span><span class=prg>Microsoft.DirectX.Direct3D;</span>
<span class=sc16>using </span>Direct3D = <span class=prg>Microsoft.DirectX.Direct3D;</span>

<span class=sc16>namespace </span>prj_Simplificar 
<span class=sc16>{</span>

  <span class=sc2>// Estrutura para propriedades 3d do objeto</span>
  <span class=sc2>// posição, rotação e cor</span>
  <span class=prg>struct </span>Propriedades3D 
  <span class=sc16>{</span>
    <span class=prg>public </span><span class=sc5>Vector3 </span>position; 
    <span class=prg>public </span><span class=sc5>Vector3 </span>rotation; 
 

    <span class=prg>public </span>Propriedades3D(<span class=sc5>Vector3 </span>pos, <span class=sc5>Vector3 </span>rot) 
    <span class=sc16>{</span>
      position = pos; 
      rotation = rot; 

    <span class=sc16>}</span>
  <span class=sc16>};</span>


  <span class=prg>public </span><span class=prg>partial </span><span class=prg>class </span>Tela : <span class=sc5>Form</span>
  <span class=sc16>{</span>
    <span class=sc2>// Para criação do dispositivo gráfico</span>
    <span class=prg>private </span><span class=sc5>Device </span>device = <span class=prg>null;</span>

    <span class=sc2>// Essa variável atualizada a cada ciclo ocasionará</span>
    <span class=sc2>// a animação do objeto</span>
    <span class=prg>private </span><span class=prg>float </span>angulo = <span class=sc4>0.0f;</span>

    <span class=sc2>// Variável para guardar as malhas 3d</span>
    <span class=prg>private </span><span class=sc5>Mesh </span>objeto3D = <span class=prg>null;</span>
    <span class=prg>private </span><span class=sc5>Mesh </span>mesh_limpo = <span class=prg>null;</span>
    <span class=prg>private </span><span class=sc5>Mesh </span>mesh_simplificado = <span class=prg>null;</span>

    <span class=sc2>// Variável para gravar informação de adjacências. Essa</span>
    <span class=sc2>// informação vai ser usada na função gerarModeloSimplificado()</span>
    <span class=sc5>GraphicsStream </span>adj; 

    <span class=sc2>// Controla modo wireframe ligado ou não</span>
    <span class=prg>bool </span>bWireframe = <span class=prg>false;</span>

    <span class=sc2>// Pacote de materiais e texturas do modelo 3d que</span>
    <span class=sc2>// precisa ser global na classe para ser utilizada também</span>
    <span class=sc2>// no método salvarModelo()</span>
    <span class=sc5>ExtendedMaterial</span>[] xMtl; 

    <span class=sc2>// Recipiente de materiais do mesh</span>
    <span class=prg>private </span><span class=sc5>Material</span>[] g_meshMtl = <span class=prg>null;</span>

    <span class=sc2>// Recipiente de texturas do mesh</span>
    <span class=prg>private </span><span class=sc5>Texture</span>[] g_meshTex = <span class=prg>null;</span>

    <span class=sc2>// Pasta de localização do arquivo mesh e sua textura</span>
    <span class=prg>private </span><span class=prg>string </span>diretorioBase = <span class=prg>null;</span>

    <span class=sc2>// Vetores para a posição e rotação do objeto 3d</span>
    <span class=sc5>Vector3 </span>posicao, rotacao; 

    <span class=sc2>// Variável global para propriedade dos objetos</span>
    Propriedades3D g_props; 

    <span class=sc2>// Objeto Font do DirectX para mostrar texto</span>
    <span class=prg>private </span><span class=prg>Direct3D.Font </span>dxfMensagem = <span class=prg>null;</span>

    <span class=sc2>// Objeto Font tradicional do namespace System.Drawing</span>
    <span class=prg>private </span><span class=prg>System.Drawing.Font </span>g_font = <span class=prg>null;</span>

    <span class=prg>public </span>Tela() 
    <span class=sc16>{</span>

      <span class=sc2>// Inicialização dos componentes.</span>
      InitializeComponent();  

      <span class=sc2>// Toda renderização deverá ocorrer dentro do evento onPaint()</span>
      <span class=sc2>// Isso evita interferência estrangeira de processamento default</span>
      <span class=sc2>// do sistema Windows</span>
      <span class=prg>this.SetStyle</span>(<span class=prg>ControlStyles.AllPaintingInWmPaint </span>| <span class=prg>ControlStyles.Opaque</span>, <span class=prg>true</span>);  

    <span class=sc16>} <span class=sc2>// construtor</span></span>

    <span class=prg>public </span><span class=prg>void </span>initGfx() 
    <span class=sc16>{</span>

      <span class=sc2>// Configuração dos parâmetros de apresentação</span>
      <span class=sc5>PresentParameters </span>pps = <span class=prg>new </span><span class=sc5>PresentParameters</span>();  
      <span class=prg>pps.Windowed </span>= <span class=prg>true;</span>
      <span class=prg>pps.SwapEffect </span>= <span class=prg>SwapEffect.Discard;</span>

      <span class=sc2>// Ativando o buffer de profundidade</span>
      <span class=prg>pps.EnableAutoDepthStencil </span>= <span class=prg>true;</span>
      <span class=prg>pps.AutoDepthStencilFormat </span>= <span class=prg>DepthFormat.D16;</span>

      <span class=sc2>// Adaptador default, processamento no hardware, processamento de vértice</span>
      <span class=sc2>// no software, janela (this), parâmetros de apresentação (pps)</span>
      <span class=prg>int </span>adaptador = 0; 
      device = <span class=prg>new </span><span class=sc5>Device</span>(adaptador, <span class=prg>DeviceType.Hardware</span>, <span class=prg>this</span>, 
        <span class=prg>CreateFlags.SoftwareVertexProcessing</span>, pps);  

      <span class=sc2>// Configuração das fontes para mostrar mensagens</span>
      g_font = <span class=prg>new </span><span class=prg>System.Drawing.Font</span>(<span class=sc6>"Arial"</span>, <span class=sc4>12.0f</span>, <span class=prg>FontStyle.Bold</span>);  
      dxfMensagem = <span class=prg>new </span><span class=prg>Direct3D.Font</span>(device, g_font);  

      diretorioBase = <span class=sc6>@"c:\Gameprog\Gdkmedia\Modelos\Tiny\";</span>
      CarregarModelo(diretorioBase, <span class=sc6>"tiny.x"</span>);  
      gerarModeloSimplificado();  

    <span class=sc16>} <span class=sc2>// initGfx().fim</span></span>



    <span class=prg>private </span><span class=prg>void </span>CarregarModelo(<span class=prg>string </span>diretorioBase, <span class=prg>string </span>arquivo) 
    <span class=sc16>{</span>
      <span class=sc2>// Composição do nome final do arquivo</span>
      <span class=prg>string </span>caminhoFinal = diretorioBase + arquivo; 

      <span class=sc2>// Recebe nome do arquivo de textura sendo carregado</span>
      <span class=prg>string </span>arquivo_textura = <span class=prg>null;</span>

      <span class=sc2>// Quantidade de materiais\texturas encontrados no modelo3d</span>
      <span class=prg>int </span>nTam = 0; 

      <span class=sc2>// Carrega modelo 3d com suas texturas e materiais e</span>
      <span class=sc2>// informação de adjacências</span>
      objeto3D = <span class=prg>Mesh.FromFile</span>(caminhoFinal, <span class=prg>MeshFlags.Managed</span>, 
        device, <span class=prg>out </span>adj, <span class=prg>out </span>xMtl);  

      <span class=sc2>// Verifica quantidade de texturas\materiais do modelo</span>
      nTam = <span class=prg>xMtl.Length;</span>

      <span class=sc2>// Carrega as texturas caso nTam &gt; 0</span>
      <span class=sc9>if </span>((xMtl != <span class=prg>null</span>)  && (nTam &gt; <span class=sc4>0</span>) ) 
      <span class=sc16>{</span>
        <span class=sc2>// Inicializa as variáveis arrays de materiais e texturas</span>
        g_meshMtl = <span class=prg>new </span><span class=sc5>Material</span>[nTam];  
        g_meshTex = <span class=prg>new </span><span class=sc5>Texture</span>[nTam];  

        <span class=prg>for </span>(<span class=prg>int </span>ncx = 0; ncx &lt; nTam; ncx++) 
        <span class=sc16>{</span>
          <span class=sc2>// Carrega materiais</span>
          g_meshMtl[ncx] = xMtl[ncx]<span class=prg>.Material3D;</span>

          <span class=sc2>// Carrega texturas</span>
          arquivo_textura = xMtl[ncx]<span class=prg>.TextureFilename;</span>
          <span class=sc9>if </span>((arquivo_textura != <span class=prg>null</span>)  && arquivo_textura != <span class=prg>String.Empty</span>)  
          <span class=sc16>{</span>
            g_meshTex[ncx] = <span class=prg>TextureLoader.FromFile</span>(device, 
              diretorioBase + arquivo_textura);  
          <span class=sc16>} <span class=sc2>// endif (texturas)</span></span>
        <span class=sc16>} <span class=sc2>// endfor (materiais\texturas)</span></span>
      <span class=sc16>} <span class=sc2>// endif (verificação de texturas\materiais presentes)</span></span>
    <span class=sc16>} <span class=sc2>// CarregarModelo().fim</span></span>



    <span class=prg>private </span><span class=prg>void </span>gerarModeloSimplificado() 
    <span class=sc16>{</span>
      <span class=sc2>// Limpeza do objeto 3d</span>
      mesh_limpo = <span class=prg>Mesh.Clean</span>(objeto3D, adj, adj);  

      <span class=sc2>// Geração do objeto simplificado</span>
      <span class=prg>int </span>nVerts_alvo = 1000; 
      mesh_simplificado = <span class=prg>Mesh.Simplify</span>(mesh_limpo, adj, <span class=prg>null</span>, nVerts_alvo, 
        <span class=prg>MeshFlags.SimplifyVertex</span>);  

    <span class=sc16>} <span class=sc2>// gerarModeloSimplificado()</span></span>



    <span class=prg>private </span><span class=prg>void </span>salvarModelo() 
    <span class=sc16>{</span>
      <span class=sc2>// Define uma variável array para informação de adjacência</span>
      <span class=prg>int</span>[] modelo_adj = <span class=prg>new </span><span class=prg>int</span>[<span class=prg>mesh_simplificado.NumberFaces </span>* <span class=sc4>3 </span>];  

      <span class=sc2>// Gera informação de adjacência</span>
      <span class=prg>mesh_simplificado.GenerateAdjacency</span>(<span class=sc4>0.0f</span>, modelo_adj);  

      <span class=sc2>// Limpa o modelo</span>
      <span class=sc5>Mesh </span>meshLimpo = <span class=prg>Mesh.Clean</span>(mesh_simplificado, modelo_adj, 
        <span class=prg>out </span>modelo_adj);  

      <span class=sc2>// Salva o modelo simplificado em arquivo x modo texto</span>
      <span class=prg>meshLimpo.Save</span>(diretorioBase + <span class=sc6>"tinySimplificado.x"</span>, modelo_adj, 
        xMtl, <span class=prg>XFileFormat.Text</span>);  

      <span class=prg>meshLimpo.Dispose</span>();  

    <span class=sc16>} <span class=sc2>// salvarModelo().fim</span></span>


    <span class=prg>private </span><span class=prg>void </span>AtualizarCamera() 
    <span class=sc16>{</span>
      <span class=sc2>// Dados para a configuração da matriz de projeção</span>
      <span class=prg>int largura = this.Width; <span class=sc2>// largura da janela</span></span>
      <span class=prg>int altura = this.Height;  <span class=sc2>// altura da janela</span></span>
      <span class=prg>float aspecto = largura / altura; <span class=sc2>// aspecto dos gráficos</span></span>
      <span class=prg>float campo_visao = (float)Math.PI / 4; <span class=sc2>// Campo de visão</span></span>
      <span class=prg>float </span>corte_perto = <span class=sc4>1.0f;</span>

      <span class=sc2>// Essa variável foi modificar para acomodar o tamanho</span>
      <span class=sc2>// do modelo</span>
      <span class=prg>float </span>corte_longe = <span class=sc4>5000.0f;</span>

      <span class=sc2>// Atualiza angulo para dar movimento ao objeto 3d</span>
      angulo += <span class=sc4>0.02f;</span>

      <span class=sc2>// Mostra a parte interna do polígono</span>
      <span class=prg>device.RenderState.CullMode </span>= <span class=prg>Cull.None;</span>

      <span class=sc2>// Configura a matriz de projeção</span>
      <span class=prg>device.Transform.Projection </span>= <span class=prg>Matrix.PerspectiveFovLH</span>(campo_visao, 
          aspecto, corte_perto, corte_longe);  

      <span class=sc2>// Dados para a configuração da matriz de visualização</span>
      <span class=sc2>// O eixo z foi modificado para comportar o tamanho do modelo</span>
      <span class=sc5>Vector3 </span>cam_pos = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>0</span>, <span class=sc4>0</span>, <span class=sc4>600.0f</span>);  
      <span class=sc5>Vector3 </span>cam_alvo = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>0.0f</span>, <span class=sc4>0.0f</span>, <span class=sc4>0.0f</span>);  
      <span class=sc5>Vector3 </span>cam_orientacao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>0</span>, <span class=sc4>1.0f</span>, <span class=sc4>0</span>);  

      <span class=sc2>// Configura a matriz de visualização</span>
      <span class=prg>device.Transform.View </span>= <span class=prg>Matrix.LookAtLH</span>(cam_pos, cam_alvo, cam_orientacao);  
    <span class=sc16>}  <span class=sc2>// AtualizarCamera()</span></span>


    <span class=prg>public </span><span class=prg>void </span>Renderizar() 
    <span class=sc16>{</span>

      <span class=sc2>// Limpa os dispositivos e os buffers de apoio</span>
      <span class=prg>device.Clear</span>(<span class=prg>ClearFlags.Target </span>| <span class=prg>ClearFlags.ZBuffer</span>, 
        <span class=prg>Color.White.ToArgb</span>(), <span class=sc4>1.0f</span>, <span class=sc4>0</span>);  

      <span class=prg>device.BeginScene</span>();  
      <span class=sc2>// (...) Todo o código de desenhar vai aqui</span>

      <span class=sc2>// Atualiza a câmera</span>
      AtualizarCamera();  
     
      <span class=sc2>// Configuração de luz </span>
      <span class=prg>device.RenderState.Lighting </span>= <span class=prg>false;</span>

      <span class=sc2>// Posicionamento do primeiro modelo</span>
      posicao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>100.0f</span>, <span class=sc4>0.2f</span>, <span class=sc4>-100.0f</span>);  
      rotacao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>0</span>, <span class=sc4>0</span>, <span class=sc4>0</span>);  
      g_props = <span class=prg>new </span>Propriedades3D(posicao, rotacao);  
      desenharObjeto(objeto3D, g_props);  

      <span class=sc2>// Posicionamento do modelo simplificado</span>
      <span class=prg>g_props.position </span> = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>-100.0f</span>, <span class=sc4>0.2f</span>, <span class=sc4>-200.0f</span>);  
      desenharObjeto(mesh_simplificado, g_props);  

      <span class=sc2>// Mostra o número de vértices de cada modelo</span>
      <span class=prg>string </span>info; 
      info = <span class=prg>String.Format</span>(<span class=sc6>"Modelo limpo: {0}"</span>, 
        <span class=prg>mesh_limpo.NumberVertices</span>);  
      MostrarMensagem(20, 20, info);  

      info = <span class=prg>String.Format</span>(<span class=sc6>"simplificado: {0}"</span>, 
        <span class=prg>mesh_simplificado.NumberVertices</span>);  
      MostrarMensagem(220, 20, info);  

      info = <span class=prg>String.Format</span>(<span class=sc6>"original: {0}"</span>, 
        <span class=prg>objeto3D.NumberVertices</span>);  
      MostrarMensagem(420, 20, info);  

      <span class=prg>device.EndScene</span>();  

      <span class=sc2>// Apresenta a cena renderizada na tela</span>
      <span class=prg>device.Present</span>();  

      <span class=sc2>// Libera a janela para processar outros eventos</span>
      <span class=prg>Application.DoEvents</span>();  
    <span class=sc16>} <span class=sc2>// Renderizar().fim</span></span>


    <span class=prg>private </span><span class=prg>void </span>desenharObjeto(<span class=sc5>Mesh </span>obj, Propriedades3D props) 
    <span class=sc16>{</span>

      <span class=sc2>// Ajusta rotação do objeto 3d</span>
      <span class=sc5>Matrix </span>obj_rot = <span class=prg>Matrix.RotationX</span>(<span class=prg>props.rotation.X </span>+ angulo) * 
        <span class=prg>Matrix.RotationY</span>(<span class=prg>props.rotation.Y</span>)  * 
        <span class=prg>Matrix.RotationZ</span>(<span class=prg>props.rotation.Z</span>);  

      <span class=sc2>// Ajusta posição do objeto 3d</span>
      <span class=sc5>Matrix </span>obj_pos = <span class=prg>Matrix.Translation</span>(<span class=prg>props.position</span>);  

      <span class=sc2>// Tranfere posição e rotação para o mundo</span>
      <span class=prg>device.Transform.World </span>= obj_rot * obj_pos; 

      <span class=sc2>// Prepara e aplica material\textura no objeto</span>
      <span class=prg>for </span>(<span class=prg>int </span>ncx = 0; ncx &lt; <span class=prg>g_meshMtl.Length; </span>ncx++) 
      <span class=sc16>{</span>
        <span class=sc2>// Informa ao dispositivo o material a ser utilizado</span>
        <span class=sc2>// na renderização</span>
        <span class=prg>device.Material </span>= g_meshMtl[ncx];  
        <span class=prg>device.SetTexture</span>(<span class=sc4>0</span>, g_meshTex[ncx]);  

        <span class=sc2>// Renderiza o mesh</span>
        <span class=prg>obj.DrawSubset</span>(ncx);  
      <span class=sc16>} <span class=sc2>// endfor</span></span>

    <span class=sc16>} <span class=sc2>// desenharObjeto()</span></span>

    
    <span class=prg>protected </span><span class=prg>override </span><span class=prg>void </span>OnPaint(<span class=sc5>PaintEventArgs </span>e) 
    <span class=sc16>{</span>
      <span class=sc2>// Trate outros processos padrões</span>
      <span class=prg>base.OnPaint</span>(e);  

      <span class=sc2>// Renderize a cena</span>
      <span class=prg>this.Renderizar</span>();  

      <span class=sc2>// Invalide para chamar novamente onPaint()</span>
      <span class=prg>this.Invalidate</span>();  
    <span class=sc16>} <span class=sc2>// onPaint().fim</span></span>


    <span class=prg>private </span><span class=prg>void </span>Tela_KeyDown(<span class=sc5>object </span>sender, <span class=sc5>KeyEventArgs </span>e) 
    <span class=sc16>{</span>
      <span class=sc2>// A tecla W liga\desliga o modo wireframe</span>
      <span class=sc9>if </span>(<span class=prg>e.KeyCode </span>== <span class=prg>Keys.W</span>)  bWireframe = !bWireframe; 
      <span class=sc9>if </span>(bWireframe) <span class=prg>device.RenderState.FillMode </span>= <span class=prg>FillMode.WireFrame;</span>
      <span class=sc9>else </span><span class=prg>device.RenderState.FillMode </span>= <span class=prg>FillMode.Solid;</span>

      <span class=sc2>// A tecla S salva o modelo</span>
      <span class=sc9>if </span>(<span class=prg>e.KeyCode </span>== <span class=prg>Keys.S</span>)  salvarModelo();  

    <span class=sc16>} <span class=sc2>// Tela_KeyDown().fim</span></span>


    <span class=sc2>// Mostra texto na posição (x,y) da tela</span>
    <span class=prg>private </span><span class=prg>void </span>MostrarMensagem(<span class=prg>int </span>xpos, <span class=prg>int </span>ylin, <span class=prg>string </span>txt) 
    <span class=sc16>{</span>
      <span class=sc2>// Configura posição do texto</span>
      <span class=sc5>Rectangle </span>position = <span class=prg>new </span><span class=sc5>Rectangle</span>(xpos, ylin, <span class=sc4>0</span>, <span class=sc4>0</span>);  

      <span class=sc2>// Mostra texto</span>
      <span class=prg>dxfMensagem.DrawText</span>(<span class=prg>null</span>, txt, position, <span class=prg>DrawTextFormat.NoClip</span>, 
        <span class=prg>Color.Blue</span>);  
    <span class=sc16>} <span class=sc2>// MostrarMensagem().fim</span></span>
  <span class=sc16>} <span class=sc2>// fim da classe</span></span>
<span class=sc16>} <span class=sc2>// fim do namespace</span></span>
</div>
<hr>
<table align='bottom' border='0' cellspacing='0' cellpadding='0' width='20%'>
<tr><td><a href='mdx9.html#start' style='color:blue'> index </a></td>
<td><a href='track11-2.html' style='color:blue'>&lt;&lt;</a></td>
<td><a href='track11-4.html' style='color:blue'>&gt;&gt;</a></td></tr></table><pre>
<hr><div style='background-color:lightyellow;color:blue'>
<center>Produzido por Gameprog: Jair Pereira - Março/2014 ©
gameprog.br@gmail.com
<a href='http://www.gameprog.com.br'>http://www.gameprog.com.br</center><hr></div></div></body></html>