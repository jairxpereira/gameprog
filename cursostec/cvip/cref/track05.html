<html><head>
<title>cbiblioteca_track05_dos</title>
<style type="text/css">

span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc2 {
	color: #008000;
}
.sc4 {
	color: #ff8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #FF0000;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #400080;
}

.prg {
	color: #0000FF;
}
</style></head>
<body><font color="black"><pre>
<hr>
<center><b>GAMEPROG - Escola de programação de jogos digitais</b><br><b>Contato: Jair Pereira - gameprog.br@gmail.com</b><br><b>Guia completo de referência da biblioteca padrão da Linguagem C [Borland Turbo C/++ ver 3.1]</b><br><b>track05.html</b><br></center><table align=bottom border=0 cellspacing=0 cellpadding=0 width=20%><tr><td><a href=cbiblioteca.html style='color:blue'> index </a></td><td><a href='track04.html'style='color:blue'>&lt;&lt;</a></td><td><a href='track06.html'style='color:blue'>&gt;&gt;</a></td></tr></table>
<hr>
<A NAME="5.00"></A>
<center><h2>5.00 dos.h</h2></center>
<A HREF="#5.01">5.01</a> absread...........Lê setores absolutos do disco
<A HREF="#5.02">5.02</a> abswrite..........Escreve em setores absolutos no disco
<A HREF="#5.03">5.03</a> allocmem..........Faz alocação de memória com tamanho dado em parágrafos.
<A HREF="#5.04">5.04</a> bdos..............Executa um serviço da interrupção 0x21 do MsDos
<A HREF="#5.05">5.05</a> bdosptr...........Executa um serviço da interrupção 0x21 do MsDos com um argumento
<A HREF="#5.06">5.06</a> country...........Retorna informação que é dependente de país
<A HREF="#5.07">5.07</a> ctrlbrk...........Registra uma função que manipula o pressionamento control break
<A HREF="#5.08">5.08</a> delay.............Suspende a execução do programa por um intervalo de tempo
<A HREF="#5.09">5.09</a> disable...........Desabilita interrupção de hardware
<A HREF="#5.10">5.10</a> dosexterr.........Obtém informações de erro extendido MsDos
<A HREF="#5.11">5.11</a> dostounix.........Converte data e horas para o formato UNIX

<A HREF="#5.12">5.12</a> __emit__..........Insere código de máquina no programa
<A HREF="#5.13">5.13</a> enable............Habilita interrupção de software
<A HREF="#5.14">5.14</a> FP_OFF............Obtém o offset de um ponteiro far
<A HREF="#5.15">5.15</a> FP_SEG............Obtém o segmento de um ponteiro far
<A HREF="#5.16">5.16</a> freemem...........Libera um bloco de memória alocado com allocmem().
<A HREF="#5.17">5.17</a> geninterrupt......Gera uma interrupção de software
<A HREF="#5.18">5.18</a> getcbrk...........Obtém a configuração de control break
<A HREF="#5.19">5.19</a> getcwd............Obtém o nome do diretório corrente
<A HREF="#5.20">5.20</a> getdate...........Obtém a data do sistema
<A HREF="#5.21">5.21</a> getdfree..........Obtém o espaço livre do drive selecionado
<A HREF="#5.22">5.22</a> getdta............Obtém o endereço do buffer de diskete
<A HREF="#5.23">5.23</a> getfat............Obtém informação da FAT do driver selecionado.

<A HREF="#5.24">5.24</a> getfatd...........Obtém informação da FAT do hd master
<A HREF="#5.25">5.25</a> getftime..........Obtém hora e data do arquivo
<A HREF="#5.26">5.26</a> getpsp............Obtém o psp do pograma executável
<A HREF="#5.27">5.27</a> gettime...........Obtém a hora do sistema
<A HREF="#5.28">5.28</a> getvect...........Obtém o vetor (endereço) da interrupção fornecida
<A HREF="#5.29">5.29</a> getverify.........Obtém o estado do flag de verificação de gravação
<A HREF="#5.30">5.30</a> harderr...........Registra a função que manipula falha de hardware (INT 0x24)
<A HREF="#5.31">5.31</a> hardresume........Retorna um valor para um processo MsDos que emitiu falha de hardware
<A HREF="#5.32">5.32</a> hardretn..........Retorna um valor para o programa que sofreu falha de hardware
<A HREF="#5.33">5.33</a> inp...............Lê um byte de uma porta
<A HREF="#5.34">5.34</a> inport............Lê uma palavra de uma porta
<A HREF="#5.35">5.35</a> inportb...........Lê um byte de uma porta

<A HREF="#5.36">5.36</a> int86.............Configura os registradores e chama uma interrupção padrão 8086
<A HREF="#5.37">5.37</a> int86x............Gera uma interrupção geral de software e hardware padrão 8086
<A HREF="#5.38">5.38</a> intdos............Gera uma interrupção 0x21 do MsDos
<A HREF="#5.39">5.39</a> intdosx...........Gera qualquer serviço da interrupção 0x21 do MsDos
<A HREF="#5.40">5.40</a> intr..............Gera qualquer interrupção padrão 8086
<A HREF="#5.41">5.41</a> keep..............Finaliza o programa e o deixa residente na memória como um TSR
<A HREF="#5.42">5.42</a> MK_FP.............Monta um ponteiro far completo a partir do segmento e deslocamento
<A HREF="#5.43">5.43</a> nosound...........Desliga o altofalante
<A HREF="#5.44">5.44</a> outp..............Coloca um byte numa porta
<A HREF="#5.45">5.45</a> outport...........Coloca uma palavra numa porta
<A HREF="#5.46">5.46</a> outportb..........Coloca um byte numa porta
<A HREF="#5.47">5.47</a> parsfnm...........Separa nome de arquivo usando FCB

<A HREF="#5.48">5.48</a> peek..............Retorna o valor que está na posição de memória fornecida
<A HREF="#5.49">5.49</a> peekb.............Retorna o byte que está na posição de memória fornecida
<A HREF="#5.50">5.50</a> poke..............Coloca um valor de 16 bits numa localização de memória
<A HREF="#5.51">5.51</a> pokeb.............Coloca um byte numa localização de memória
<A HREF="#5.52">5.52</a> randbrd...........Lê registros do arquivo em disco usando o FCB
<A HREF="#5.53">5.53</a> randbwr...........Escreve registros em arquivo no disco usando o FCB
<A HREF="#5.54">5.54</a> segread...........Obtém os valores dos registradores de segmento
<A HREF="#5.55">5.55</a> setblock..........Redefine o tamanho de um bloco de memória alocado com allocmem()
<A HREF="#5.56">5.56</a> setcbrk...........Ativa ou desativa verificação de control break
<A HREF="#5.57">5.57</a> setdate...........Configura uma nova data para o sistema

<A HREF="#5.58">5.58</a> setdta............Define um novo endereço para a DTA
<A HREF="#5.59">5.59</a> settime...........Configura uma nova hora para o sistema
<A HREF="#5.60">5.60</a> setvect...........Determina um novo vetor para uma interrupção
<A HREF="#5.61">5.61</a> setverify.........Configura o flag de confirmação de gravação em disco
<A HREF="#5.62">5.62</a> sleep.............Suspende a execução do programa por um intervalo de tempo
<A HREF="#5.63">5.63</a> sound.............Aciona o alto falante numa determinada frequência
<A HREF="#5.64">5.64</a> unixtodos.........Converte data e horas do UNIX para formato MsDos
<A HREF="#5.65">5.65</a> unlink............Deleta o arquivo especificado

<A NAME="5.01"><b>5.01 absread</b></A>
        Esta função grava em setores absolutos do disco.
        <b style="color:green">
        int absread(int driver,int nsects, int lsect,void *buffer);
        nSts = absread(nDisk, nSecToRead, nSetor, &sBuffer);</b>

        nSts.........A função retorna 0 para sucesso, -1 para falhas.
        nDisk........Disco a ser lido, 0=A; 1=B; 2=C e assim por diante.
        nSecToRead...Número de setores para serem lidos
        nSetor.......Número do setor lógico a ser lido
        &sBuffer.....Buffer de memória que recebe o conteúdo lido.

        Veja o programa exemplo que lê o setor 0 do diskete e pega o
        nome do volume:<font color="darkblue">

        #include "stdio.h"
        #include "conio.h"
        #include "dos.h"

        int main (int nCmd, char **sCmd) {

        int nDisk = 0;
        int nSector = 0;
        char sMemoria[512];
        int nSecToRead = 1;
        int nSts,cx;
        char sVol[12]="\0\0\0\0\0\0\0\0\0\0\0\0";

        clrscr();

        nSts = absread(nDisk, nSecToRead, nSector, &sMemoria);

        for (cx=0;cx<11;cx++) {
        sVol[cx] = sMemoria[cx+43];
        if (sVol[cx]=='\0') break; }

        printf("Nome do volume: %s",sVol);

        puts("\nEnd of Program");
        getch();
        }</font>

.......................................................................................
<A NAME="5.02"><b>5.02 abswrite</b></A>
        Esta função lê setores absolutos do disco.
        <b style="color:green">
        int abswrite(int driver,int nsects, int lsect,void *buffer);
        nSts = abswrite(nDisk, nSecToRead, nSetor, &sBuffer);</b>

        nSts.........A função retorna 0 para sucesso, -1 para falhas.
        nDisk........Disco a ser escrito, 0=A; 1=B; 2=C e assim por diante.
        nSecToRead...Número de setores para serem escritos
        nSetor.......Número do setor lógico a ser escrito
        &sBuffer.....Buffer de memória que contém o conteúdo a ser escrito

.......................................................................................
<A NAME="5.03"><b>5.03 allocmem</b></A>
        Esta função faz a alocação de memória com o tamanho dado em parágrafos.
        Vamos lembrar que um parágrafo é uma extensão de 16 bytes.
        <b style="color:green">
        int allocmem(unsigned size, unsigned *segp);
        nSts = allocmem(nSize, &pSegmento);</b>

        nSts............O valor de retorno é -1 para sucesso, caso contrário em
                        nSts é retornado o tamanho do maior bloco disponível
        &pSegmento......O segmento do bloco alocado é retornado em pSegmento

        Veja este programa exemplo:<font color="darkblue">
        #include "dos.h"
        #include "alloc.h"
        #include "conio.h"
        #include "stdio.h"

        /* int allocmem(unsigned size, unsigned *segp)
                nSts = allocmem(nSize,&pSegmento); */

        int main(void) {
        unsigned int nSize, pSegmento;
        int nSts;

        clrscr();

        nSize = 64;                    /* (64 x 16) = 1024 bytes */
        nSts = allocmem(nSize, &pSegmento);
        if (nSts == -1)
        printf("Memória alocada no segmento: %Xh\n", pSegmento);
        else
        printf("Falhou: Só há disponível %u parágrafos\n", nSts);
        getch();
        return 0;}</font>

.......................................................................................
<A NAME="5.04"><b>5.04 bdos</b></A>
        Esta função executa um serviço da interrupção 0x21 do MsDos.
        <b style="color:green">
        int bdos(int dosfunc, unsigned dosdx, unsigned dosal);
        nSts = bdos(nService, pDx, nAL);</b>

        nSts.....Recebe o valor de AX, que é definido pelo serviço executado
        pDx......Recebe o valor que é configurado no registrador DX
        nAL......Recebe o valor que é configurado no registrador AL

        No exemplo a seguir, nós usamos o serviço do MsDos de impressão de
        string 0x09. A string deve terminar com s-cifrão '$' e seu endereço
        deve ser passado para DX. Veja então o exemplo:<font color="darkblue">

        #include "dos.h"
        #include "alloc.h"
        #include "conio.h"
        #include "stdio.h"

        /* bdos(int dosfunc, unsigned dosdx, unsigned dosal); */

        int main(void) {
        char sMsg[]="O melhor ataque é a melhor defesa!$";
        int dosfunc=0x09;
        unsigned int dosdx;
        unsigned int dosal=0;

        clrscr();

        dosdx = (unsigned) sMsg;
        bdos(dosfunc,dosdx,dosal);

        puts("\nEnd of program");
        getch();
        return 0;}</font>

        Saída:
        O melhor ataque é a melhor defesa!
        End of program

.......................................................................................
<A NAME="5.05"><b>5.05 bdosptr</b></A>
        Executa um serviço da interrupção MsDos que exige um argumento.
        <b style="color:green">
        int bdosptr(int dosfunc, void *argument, unsigned dosal);
        nSts = bdosptr(nService, pData, nAL);</b>

        nSts......Retorna valor de AX, em caso de falha o retorno é -1
        nService..Número que identifica o serviço a ser executado
        pData.....O argumento que o serviço requer para ser efetuado
        nAL.......O valor que vai ser configurado em AL

        Veja o programa exemplo que executa o serviço que cria um
        subdiretório:<font color="darkblue">

        #include <dos.h>
        #include <conio.h>
        #include <stdio.h>

        /* bdosptr(int dosfunc, void *argument, unsigned dosal); */

        int main(void) {
        int nMakeDir = 0x39;
        char sDirName[]="mydir";
        clrscr();

        bdosptr(nMakeDir,sDirName,0);
        puts("\nEnd of program");
        getch();
        return 0;}</font>

        Este programa cria um diretório chamado MYDIR no diretório corrente.

.......................................................................................
<A NAME="5.06"><b>5.06 country</b></A>
        Esta função retorna as informações que são dependentes de cada
        país. Estas informações consiste de coisas como o símbolo
        monetário do país, o separador decimal etc.
        <b style="color:green">
        struct country *country(xcode, struct country *cp);
        country(nPais, &xPais);</b>

        nPais.......O código do país que se quer obter as informações. Configurado
                    em zero, retorna as informações do país corrente.
        xPais.......Estrutura criada com a struct country para receber as informações
                    do país solicitado.

        Veja os elementos da estrutura criada com struct country:

        int co_date;         /* Código de formatação de data */
        char co_curr[5];     /* Simbolo monetário */
        char co_thsep[2];    /* Separador de milhar */
        char co_desep[2];    /* Separador decimal */
        char co_dtsep[2];    /* Separador de data */
        char co_tmsep[2];    /* Separador de tempo */
        char co_currstyle;   /* Estilo monetário */
        char co_digits;      /* Digitos monetários significantes */
        char co_time;        /* Formatação do tempo */
        long co_case;        /* Função mapeadora de caracteres */
        char co_dasep[2];    /* Separador de data secundário */
        char co_fill[10];    /* Preenchimento */

        Veja o programa exemplo:<font color="darkblue">

        #include <dos.h>
        #include <conio.h>
        #include <stdio.h>

        #define Brasil 0

        /* struct country *country(int xcode,struct country *cp) */

        int main(void) {

        struct country xBrasil;

        country(Brasil,&xBrasil);
        clrscr();

        printf("Formatação de data: %d\n",xBrasil.co_date);
        printf("Símbolo monetário: %s\n",xBrasil.co_curr);
        printf("Separador de milhar: %s\n",xBrasil.co_thsep);
        printf("Separador decimal: %s\n",xBrasil.co_desep);
        printf("Separador de data: %s\n",xBrasil.co_dtsep);

        printf("Separador de tempo: %s\n",xBrasil.co_tmsep);
        printf("Estilo monetário: %d\n",xBrasil.co_currstyle);
        printf("Digitos monetários significativos: %d\n",xBrasil.co_digits);
        printf("Separador de tempo secundário: %d\n",xBrasil.co_time);
        printf("Função mapeadora de caracteres: %p\n",xBrasil.co_case);

        printf("Separador de data secundário: %s\n",xBrasil.co_dasep);
        printf("Preenchimento: %d\n",xBrasil.co_fill);

        puts("\nEnd of program");
        getch();
        return 0;}</font>

        Saída:
        Formatação de data: 1
        Símbolo monetário: Cr$
        Separador de milhar: .
        Separador decimal: ,
        Separador de data: /
        Separador de tempo: :
        Estilo monetário: 2
        Digitos monetários significativos: 2
        Separador de tempo secundário: 1
        Função mapeadora de caracteres: 0D6B
        Separador de data secundário: ;
        Preenchimento: -44
        End of program

.......................................................................................
<A NAME="5.07"><b>5.07 ctrlbrk</b></A>
        Esta função registra uma nova função que manipula o pressionamento de
        CTRL+BREAK OU CTRL+C. Esta função é chamada de handler, manipulador(a)
        em nosso idioma.
        <b style="color:green">
        void ctrlbrk(int (*handler)(void));
        ctrlbrk(NomeFunção);</b>

        Veja o programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"
        #include "dos.h"

        int abortando(void) {
        printf("\nA função que manipula control+break "
        "foi executada com sucesso\n");
        return(0);}

        int main (int nCmd, char **sCmd) {
        ctrlbrk(abortando);

        clrscr();
        for(;;){
        gotoxy(20,13);
        printf("Executando normal.");
        sleep(1);}
        puts("\nEnd of Program");
        getch();
        getch();
        }</font>

        Saída:
        Ao ser pressionado control+break ou control+c o programa exibe a mensagem
        A função que manipula control+break foi executa com sucesso.

        Detalhes: O handler deve retornar 0, caso contrário o programa principal
        continuará executando.
        Esta função modifica o vetor da interrupção 0x23 que aponta para a
        rotina que manipula control break.


.......................................................................................
<A NAME="5.08"><b>5.08 delay</b></A>
        Esta função suspende a execução do programa por um intervalo de
        tempo dado em milessegundos.
        <b style="color:green">
        void delay(unsigned milliseconds);
        delay(nMilessegundos);</b>

        Ex.:    sound(500);
                delay(10000);
                nosound();

.......................................................................................
<A NAME="5.09"><b>5.09 disable</b></A>
        Esta função desabilita todas as interrupções de hardware, exceto
        as conhecidas como NMI.
        <b style="color:green">
        void disable(void);
        disable();</b>

        Ex.:    disable();

.......................................................................................
<A NAME="5.10"><b>5.10 dosexterr</b></A>
        Esta função obtém informação extra sobre o último erro ocorrido em
        uma chamada ao sistema. Uma estrutura com as informações extras do
        erro é preenchida.
        <b style="color:green">
        int dosexterr(struct DOSERROR *eblkp);
        nSts = dosexterr(&xErro);</b>

        nSts........A função retorna zero caso não tenha ocorrido erro na
                    última chamada ao sistema.

        Elementos da estrutura xErro criado com struct DOSERROR:
        xErro.exterror......Número do erro extendido
        xErro.class.........Classe do erro
        xErro.action........evento que causou o erro
        xErro.locus.........Locus do erro

        Veja o programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"
        #include "dos.h"

        int main(void){
        int nSts;
        FILE *hFile;
        struct DOSERROR xErro;

        clrscr();

        hFile= fopen("nofile.tst","r");
        if (!hFile) perror("Falha na abertura de arquivo");
        nSts = dosexterr(&xErro);

        printf("Informações de erro extendido MsDos:\n\n");
        printf("Erro extendido.. %d\n",xErro.exterror);
        printf("Classe.......... %x\n",xErro.class);
        printf("Ação............ %x\n",xErro.action);
        printf("Locus do erro... %x\n",xErro.locus);
        printf("nSts............ %d\n",nSts);
        getch();
        return 0;</font>

        Saída:
        Falha na abertura de arquivo: No such file or directory
        Informações de erro extendido MsDos:

        Erro extendido.. 2
        Classe.......... 8
        Ação............ 3
        Locus do erro... 4
        nSts............ 2

.......................................................................................
<A NAME="5.11"><b>5.11 dostounix</b></A>
        Esta função converte data e horas do formato MsDos para o formato
        do sistema operacional UNIX.
        <b style="color:green">
        long dostounix(struct date *d, struct time *t);
        nUnixFmt = dostounix(&xToday,&xTempo);</b>

        Veja o programa exemplo, ilustrando esta função:<font color="darkblue">
        #include "time.h"
        #include "stddef.h"
        #include "dos.h"
        #include "stdio.h"
        #include "conio.h"

        int main(void) {
        long nUnixFmt;
        struct time xTempo;
        struct date xToday;
        struct tm *xTodayTempo;
        char *sDataTempoInfo;
        getdate(&xToday);
        gettime(&xTempo);

        clrscr();

        nUnixFmt = dostounix(&xToday, &xTempo);
        xTodayTempo = localtime(&nUnixFmt);
        sDataTempoInfo = asctime(xTodayTempo);
        printf("Data e horas: %s\n",sDataTempoInfo);
        getch();
        return 0;}</font>

        Saída:
        Data e horas: Mon Dec 06 16:08:04 2004
.......................................................................................
<A NAME="5.12"><b>5.12 __emit__</b></A>
        Esta função insere código de máquina no programa.
        <b style="color:green">
        void __emit__(argument,...);
        __emit__(nCódigo, nCódigo,...);</b>

        Ex.: __emit__(0xB4,0x00,0xB0,0x13,0xCD,0x10);

        Esta única linha de código muda o modo de vídeo para o modo 13.

        Este exemplo, é equivalente a estas linhas em assembly:
        mov ah,00h
        mov al,13h
        int 10h

.......................................................................................
<A NAME="5.13"><b>5.13 enable</b></A>
        Esta função reabilita todas as interrupções de hardware que foram
        previamente desabilitadas com disable().
        <b style="color:green">
        void enable(void);
        enable();</b>

        Ex.:    enable();
.......................................................................................
<A NAME="5.14"><b>5.14 FP_OFF</b></A>
        Esta função obtém o deslocamento (offset) de um ponteiro far.
        <b style="color:green">
        unsigned FP_OFF(farpointer);
        nOffset = FP_OFF(nFarPonteiro);</b>

        Veja o programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"
        #include "dos.h"
        #include "alloc.h"

        int main (int nCmd, char **sCmd) {

        unsigned char nByte;
        char far *tabtile;
        unsigned int nSegmento;
        unsigned int nOffSet;

        clrscr();

        tabtile = (char far *) farmalloc(64000);

        if (tabtile==NULL) {
        printf("Memória não concedida!\n");
        getch();
        exit(1); }

        nSegmento = FP_SEG(tabtile);
        printf("Segmento: %p\n",nSegmento);
        nOffSet = FP_OFF(tabtile);
        printf("Deslocamento: %p\n",nOffSet);
        tabtile[1000]=14;

        nByte = peek(nSegmento,nOffSet+1000);

        printf("nByte: %d",nByte);

        puts("\nEnd of Program");

        getch();}</font>

        Saída:
        Segmento: 74E7
        Deslocamento: 0008
        nByte: 14
        End of Program

.......................................................................................
<A NAME="5.15"><b>5.15 FP_SEG</b></A>
        Esta função obtém o segmento de um ponteiro far.
        <b style="color:green">
        unsigned FP_SEG(farpointer);
        nSegmento = FP_SEG(nFarPonteiro);</b>

        Veja o programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"
        #include "dos.h"
        #include "alloc.h"

        int main (int nCmd, char **sCmd) {

        unsigned char nByte;
        char far *tabtile;
        unsigned int nSegmento;
        unsigned int nOffSet;

        clrscr();

        tabtile = (char far *) farmalloc(64000);

        if (tabtile==NULL) {
        printf("Memória não concedida!\n");
        getch();
        exit(1); }

        nSegmento = FP_SEG(tabtile);
        printf("Segmento: %p\n",nSegmento);
        nOffSet = FP_OFF(tabtile);
        printf("Deslocamento: %p\n",nOffSet);
        tabtile[1000]=14;

        nByte = peek(nSegmento,nOffSet+1000);

        printf("nByte: %d",nByte);

        puts("\nEnd of Program");

        getch();}</font>

        Saída:
        Segmento: 74E7
        Deslocamento: 0008
        nByte: 14
        End of Program

.......................................................................................
<A NAME="5.16"><b>5.16 freemem</b></A>
        Esta função libera um bloco de memória alocado previamente com
        allocmem().
        <b style="color:green">
        int freemem(unsigned segx);
        nSts = freemem(pSegmento);</b>

        nSts.......A função retorna 0 para sucesso, -1 para falhas.
        pSegmento..O ponteiro que foi retornado por allocmem()

        Ex.:    nSts = freemem(pSegmento);

.......................................................................................
<A NAME="5.17"><b>5.17 geninterrupt</b></A>
        Esta função gera uma interrupção de software.
        <b style="color:green">
        void geninterrupt(int intr_num);
        geninterrupt(nInterruption);</b>

        Ex.:    geninterrupt(0x23);

        Este exemplo chama a rotina que manipula control+break como se este
        pressionamento tivesse ocorrido.

.......................................................................................
<A NAME="5.18"><b>5.18 getcbrk</b></A>
        Esta função obtém a configuração de control break.
        <b style="color:green">
        int getcbrk(void);
        nConfig = getcbrk();</b>

        nConfig.....Retorna 1 caso verificação de control break esteja ligada,
                    Retorna 0 caso esteja desligada.

        Para outros detalhes veja a função irmã setcbrk().

.......................................................................................
<A NAME="5.19"><b>5.19 getcwd</b></A>
        Esta função obtém o nome do diretório atual de trabalho.
        <b style="color:green">
        char getcwd(char *buf, int buflen);
        sName = getcwd(sDirName, nTam);</b>

        sDirName.......Buffer que receberá o nome do diretório corrente
        nTam...........Deve ser passado o tamanho desse buffer.
        sName..........A função retorna um ponteiro para sDirName

        Ex.:    char sDirName[64];
                getcwd(sDirName,64);
                printf("Estou aqui: %s \n",sDirName);
                /* Resulta em Estou aqui: C:\TC */
.......................................................................................
<A NAME="5.20"><b>5.20 getdate</b></A>
        Esta função obtém a data do sistema em mês, dia e ano.
        <b style="color:green">
        void getdate(struct date *datep);
        getdate(&xToday);</b>

        Elementos de xToday:
        xToday.da_day......Dia tipo: unsigned char
        xToday.da_mon......Mês tipo: unsigned char
        xToday.da_year.....Ano tipo: int

        Ex.:    struct date xToday;
                getdate(&xToday);
                printf("Dia: %d\n",xToday.da_day);
                printf("Mês: %d\n",xToday.da_mon);
                printf("Ano: %d\n",xToday.da_year);

        /* Resulta em
                        Dia: 22
                        Mês: 11
                        Ano: 2004       */


.......................................................................................
<A NAME="5.21"><b>5.21 getdfree</b></A>
        Esta função obtém o espaço disponível do driver selecionado.
        <b style="color:green">
        void getdfree(unsigned char drive, struct dfree *dtable);
        getdfree(nDrive, &xSpace);</b>

        Elementos de xSpace:
        xSpace_df.avail.........Número de clusters disponíveis
        xSpace_df.total.........Total de clusters na unidade
        xSpace_df.bsec..........Número de Bytes por setor
        xSpace_df.sclus.........Número de Setores por cluster

        Veja o programa exemplo que obtém espaço livre do diskete a::<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"
        #include "dos.h"

        /* void getdfree(unsigned char drive, struct dfree *dtable); */

        struct dfree xSpace;
        unsigned char nDrive = 1;
        long nBytesFree;

        int main (int nCmd, char **sCmd) {

        clrscr();
        getdfree(nDrive, &xSpace);
        nBytesFree = (long) xSpace.df_avail * xSpace.df_bsec;

        printf("Clusters disponíveis: %u\n",xSpace.df_avail);
        printf("Total de clusters: %u\n",xSpace.df_total);
        printf("Bytes por setor: %d\n",xSpace.df_bsec);
        printf("Setores por cluster: %u\n",xSpace.df_sclus);
        printf("Total de bytes livres: %li\n",nBytesFree);

        puts("\nEnd of Program");
        getch();}</font>

        Saída:
        Clusters disponíveis: 1160
        Total de clusters: 2847
        Bytes por setor: 512
        Setores por cluster: 1
        Total de bytes livres: 593920
        End of Program

.......................................................................................
<A NAME="5.22"><b>5.22 getdta</b></A>
        Esta função obtém o endereço da dta, data transfer address, que
        é a área de buffer de disco.
        <b style="color:green">
        char far *getdta(void);
        pDiscBuffer = getdta();</b>

        Ex.:    char far *pDiscBuffer;
                pDiscBuffer = getdta();
                printf("Endereço do Buffer do diskete: %Fp",pDiscBuffer);
                /* Resulta em Endereço do Buffer do diskete: 62FD:0080 */

.......................................................................................
<A NAME="5.23"><b>5.23 getfat</b></A>
        Esta função obtém informações da FAT do driver selecionado. Vamos
        lembrar que FAT,File Allocation Table, é a tabela de alocação de
        arquivos no disco. É esta tabela que informa aonde cada arquivo
        está localizado no disco.
        <b style="color:green">
        void getfat(unsigned char drive, struct fatinfo *dtable);
        getfat(nDiscDrive,&xFat);</b>

        Elementos de xFat:
        xFat.fi_sclus.............Setores por cluster
        xFat.fi_fatid.............Byte de identificação da FAT
        xFat.fi_nclus.............Número de clusters
        xFat.fi_bysec.............Tamanho em bytes de cada setor

        Veja o programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"
        #include "dos.h"

        /* void getfat(unsigned char drive, struct fatinfo *dtable); */

        int main (int nCmd, char **sCmd) {

        struct fatinfo xFat;
        unsigned char nDiscDrive = 1;
        clrscr();

        getfat(nDiscDrive,&xFat);

        printf("Setores por cluster: %d\n",xFat.fi_sclus);
        printf("Fat ID byte: %d\n",xFat.fi_fatid);
        printf("Número de clusters: %u\n",xFat.fi_nclus);
        printf("Tamanho do setor: %d\n",xFat.fi_bysec);
        puts("\nEnd of Program");
        getch();}</font>

        Saída:
        Setores por cluster: 1
        Fat ID byte: -16
        Número de clusters: 2847
        Tamanho do setor: 512
        End of Program

.......................................................................................
<A NAME="5.24"><b>5.24 getfatd</b></A>
        Esta função obtém informações da FAT do hd master. Vamos lembrar que FAT,
        File Allocation Table, é a tabela de alocação de arquivos no disco.
        É esta tabela que informa aonde cada arquivo está localizado no disco.
        <b style="color:green">
        void getfatd(struct fatinfo *dtable);
        getfatd(&xFat);</b>

        Elementos de xFat:
        xFat.fi_sclus.............Setores por cluster
        xFat.fi_fatid.............Byte de identificação da FAT
        xFat.fi_nclus.............Número de clusters
        xFat.fi_bysec.............Tamanho em bytes de cada setor

        Veja o programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"
        #include "dos.h"

        /* void getfat(unsigned char drive, struct fatinfo *dtable); */

        int main (int nCmd, char **sCmd) {

        struct fatinfo xFat;
        clrscr();

        getfatd(&xFat);

        printf("Setores por cluster: %d\n",xFat.fi_sclus);
        printf("Fat ID byte: %d\n",xFat.fi_fatid);
        printf("Número de clusters: %d\n",xFat.fi_nclus);
        printf("Tamanho do setor: %d\n",xFat.fi_bysec);
        puts("\nEnd of Program");
        getch();}</font>

        Saída:
        Setores por cluster: 1
        Fat ID byte: 65528
        Número de clusters: 64258
        Tamanho do setor: 512
        End of Program

.......................................................................................
<A NAME="5.25"><b>5.25 getftime</b></A>
        Esta função obtém a data e hora do arquivo. Esta data e hora refere-se
        a criação ou última atualização do arquivo.
        <b style="color:green">
        int getftime(int handle, struct ftime *ftimep);
        nSts = getftime(nHandle,&xFileInfo);</b>

        nHandle.....Número de handle de arquivo, que também pode ser obtido por
                fileno(hFile);

        nSts....Esta função retorna 0 quando sucesso; -1 para falha e configura
                a variável errno que pode ser pesquisada por outra função.

        Elementos da estrutura xFileInfo, definida em io.h:

        unsigned  xFileInfo.ft_tsec  : 5; ............. Segundos
        unsigned  xFileInfo.ft_min   : 6; ............. Minutos
        unsigned  xFileInfo.ft_hour  : 5; ............. Horas
        unsigned  xFileInfo.ft_day   : 5; ............. Dia
        unsigned  xFileInfo.ft_month : 4; ............. Mês
        unsigned  xFileInfo.ft_year  : 7; ............. Ano

        Veja o programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"
        #include "dos.h"
        #include "io.h"

        /* getftime() */

        int main (int nCmd, char **sCmd) {

        char sFileName[]="teste.txt";
        struct ftime xFileInfo;
        FILE *hFile;
        char sOpenMode[]="rt";
        int nHandle;

        clrscr();
        hFile = fopen(sFileName,sOpenMode);
        nHandle = fileno(hFile);
        getftime(nHandle,&xFileInfo);

        printf("Dia: %d\n",xFileInfo.ft_day);
        printf("Mês: %d\n",xFileInfo.ft_month);
        printf("Ano: %d\n\n",xFileInfo.ft_year+1980);
        printf("Hor: %d\n",xFileInfo.ft_hour);
        printf("Min: %d\n",xFileInfo.ft_min);
        printf("Seg: %d\n",xFileInfo.ft_tsec);

        puts("\nEnd of program");
        getch();
        }</font>

        Saída:
        Dia: 9
        Mês: 11
        Ano: 2004
        Hor: 21
        Min: 21
        Seg: 22
        End of program

.......................................................................................
<A NAME="5.26"><b>5.26 getpsp</b></A>
        Esta função obtém o psp do programa executável. O psp é o
        cabeçalho do programa executável que informa a linha de comando,
        o quanto que o programa usa de memória e outros dados.
        <b style="color:green">
        unsigned getpsp(void);
        getpsp();</b>

        Detalhes: Psp desdobra-se em Program Prefix Segment, prefixo do
        segmento do programa. A função retorna um ponteiro para o Psp.

.......................................................................................
<A NAME="5.27"><b>5.27 gettime</b></A>
        Esta função obtém a hora do sistema em horas, minutos, segundos e
        centésimos.
        <b style="color:green">
        void gettime(struct time *timep);
        gettime(&xTempo);</b>

        Elementos de xTempo:
        xTempo.ti_hour.......horas
        xTempo.ti_min........minutos
        xTempo.ti_sec........segundos
        xTempo.ti_hund.......centésimos
        Todos eles são unsigned char.

        Ex.:    struct time xTempo;
                gettime(&xTempo);
                printf("     Horas: %s\n",xTempo.ti_hour);
                printf("   Minutos: %s\n",xTempo.ti_min);
                printf("  Segundos: %s\n",xTempo.ti_sec);
                printf("Centésimos: %s\n",xTempo.ti_hund);

                /* Resulta em
                      Hora: 23
                   Minutos: 20
                  Segundos: 15
                Centésimos: 35  */


.......................................................................................
<A NAME="5.28"><b>5.28 getvect</b></A>
        Esta função obtém o vetor (endereço) de memória no qual está
        contido o código de execução da interrupção fornecida.
        <b style="color:green">
        void interrupt(*getvect(int intr_num))();
        nAddress = *getvect(nInterrupt);</b>

        Ex.:    int nInterrupt = 0x23   /* Rotina de control break */
                unsigned char *nAddress;
                nAddress = *getvect(nInterrupt);
                printf("%p\n",nAddress);
                /* Resulta em 016D */

.......................................................................................
<A NAME="5.29"><b>5.29 getverify</b></A>
        Esta função obtém o estado atual do flag de verificação de gravação.
        <b style="color:green">
        int getverify(void);
        nSts = getverify();</b>

        nSts.....O retorno para ligado é 1, desligado é zero.

        Detalhes:       O zero indica que a integridade da operação de gravação
                        não é confirmada com uma leitura subsequente dos
                        dados, enquanto 1 indica que isto é feito.

        Ex.:    int nSts;
                nSts = getverify();

.......................................................................................
<A NAME="5.30"><b>5.30 harderr</b></A>
        Esta função registra a função que gerenciará falhas de hardware.
        Na ocorrência de uma interrupção INT 0x24, a função registrada
        via harderr() será chamada ao trabalho.
        <b style="color:green">
        void harderr(int (*handler)());
        harderr(pFunçãoNome);</b>

        pFunçãoNome......Você deve passar o nome da função gerenciadora de erros
        como argumento de harderr(). Quando esta função é chamada (pFunçãoNome)
        lhe é passada quatro argumentos nesta ordem: int errval,int ax,int bp,int si.
        Sendo errval o valor do erro, ax o valor do registrador ax que informa
        em qual periférico ocorreu o erro; bp e si são respectivamente os valores
        dos registradores bp e si do processador.

        Veja este programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "dos.h"

        #define IGNORE  0
        #define RETRY   1
        #define ABORT   2

        int buf[500];

        static char *err_msg[] = {
         "Protegido contra gravação!",
         "unidade desconhecida!",
         "driver não está pronto!",
         "comando desconhecido!",
         "Erro nos dados (CRC)!",
         "requisição ruim!",
         "erro de busca!",
         "tipo desconhecido de m¡dia.",
         "setor não encontrado!",
         "impressora sem papel!",
         "falha na gravação!",
         "falha de leitura!",
         "falha geral!",
         "reservado!",
         "reservado!",
         "mudança inválida de disco!" };

        error_win(char *msg) {
        int retval;
        printf("Vc está dentro de error_win()\n");
        cputs(msg);

        /* Pedimos ao usuário pressionar uma tecla para
        abortar, retentar, ignorar */

        while(1) {
        retval= getch();
        if (retval == 'a' || retval == 'A') {
        retval =ABORT;
        break;  }

        if (retval == 'r' || retval == 'R') {
        retval = RETRY;
        break;  }

        if (retval == 'i' || retval == 'I')     {
        retval = IGNORE;            break;      }
        }

        return(retval); }

        int handler(int errval,int ax,int bp,int si) {
        static char msg[80];
        unsigned di;
        int drive;
        int errorno;

        di= _DI;

        /*      Se este não foi um erro de disco isto então foi um erro
        um erro em outro dispositivo */

        printf("Vc està dentro do handler()\n");
        if (ax < 0)    {
        /* Reportando o erro */
        error_win("Erro no dispositivo!");
        /* e retorna diretamente ao programa requisitando abortar */
        hardretn(ABORT);        }

        /* caso contrário foi realmente um erro de disco */
        drive = ax & 0x00FF;
        errorno = di & 0x00FF;

        /* Reportando que erro ocorreu: */
        sprintf(msg, "Erro: %s no drive %c\r\nA)bortar, R)etentar I)gnorar: ",
                err_msg[errorno], 'A' + drive);

        /* Retorne ao programa via interrupção 0x23 com abortar, retentar,
        ou ignorar como entrada definida pelo usu rio. */

        printf("*** Hardresume foi usada 01 ***\n");
        hardresume(error_win(msg));
        printf("*** Hardresume foi usada 02 ***");
        getch();

        return ABORT; }

        int main(void) {
        harderr(handler);
        clrscr();
        printf("Vc está dentro de main()\n");
        printf("Para simulação, esvazie o drive A:\n");
        printf("Pressione uma tecla para continuar...\n");
        getch();
        printf("Tentando acessar drive A:\n");
        printf("fopen retornou %p\n",fopen("A:temp.dat", "w"));
        getch();
        return 0; }</font>

.......................................................................................
<A NAME="5.31"><b>5.31 hardresume</b></A>
        Esta função retorna um valor para um processo do MsDos que emitiu
        uma falha de hardware (INT 0x24). Este valor pode ser 2 para
        abortar, 1 para retentar (retry) ou 0 para ignorar.
        <b style="color:green">
        void hardresume(int axretn);
        hardresume(nRetorno);</b>

        Ex.: hardresume(2);

        Detalhes:       Esta função deve ser usada em conjunto com harderr().
                        Harderr() registra uma função "handler" para gerenciar
                        os erros que ocorrerem, é dentro deste handler() que você
                        vai usar hardretn() para informar a rotina que emitiu a
                        interrupção 0x24 como prosseguir depois que o problema
                        ocorreu.

        Veja o programa exemplo em harderr()

.......................................................................................
<A NAME="5.32"><b>5.32 hardretn</b></A>
        Esta função retorna um valor para um programa que sofreu uma falha
        de hardware (INT 0x24). Este valor pode ser 2 para abortar, 1 para
        retentar (retry) ou 0 para ignorar.
        <b style="color:green">
        void hardretn(int retn);
        hardretn(nRetorno);</b>

        Ex.: hardretn(2);

        Detalhes:       Esta função deve ser usada em conjunto com harderr().
                        Harderr() registra uma função "handler" para gerenciar
                        os erros que ocorrerem, é dentro deste handler() que você
                        vai usar hardretn() para informar a rotina que emitiu a
                        interrupção 0x24 como prosseguir depois que o problema
                        ocorreu.

        Veja o programa exemplo em harderr()

.......................................................................................
<A NAME="5.33"><b>5.33 inp</b></A>
        Esta função lê um byte de uma porta.
        <b style="color:green">
        int inp(int portid);
        nByte = inp(nPorta);</b>

        Ex.:    nByte = inp(0);

        Veja este programa:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "dos.h"

        int main( int nCmd, char **sCmd) {
        int nSlotRgb = 0x3C9;
        int nSlotCor = 0x3C8;
        int cor = 0;
        int r,g,b;

        outp(nSlotCor,0);
        clrscr();

        for (cor=0; cor<16; cor++ ) {
        r = inp(nSlotRgb);
        g = inp(nSlotRgb);
        b = inp(nSlotRgb);
        printf("%d %d %d %d\n",cor,r,g,b);}

        puts("End of Porgram.");
        getch();
        }</font>

        Detalhes: A porta identificada como 0x3C9 é o registrador VGA de Cor.
        Na primeira leitura desta porta, o valor de retorno é a taxa de vermelho
        da cor, a segunda leitura é a taxa de verde, a terceira leitura é a
        a taxa de azul e a leitura seguinte retorna a taxa de vermelho da
        próxima cor e assim por diante.

.......................................................................................
<A NAME="5.34"><b>5.34 inport</b></A>
        Esta função lê uma palavra de uma porta, lembrando que uma palavra é
        um número de 2 bytes ou 16 bits.
        <b style="color:green">
        int inport(int portid);
        nWord = inport(nPorta);</b>

        Ex.:    int nWord, nPorta = 0x3C8;
                nWord = inport(nPorta);
                printf("%d",nWord);
.......................................................................................
<A NAME="5.35"><b>5.35 inportb</b></A>
        Esta função lê um byte de uma porta de hardware.
        <b style="color:green">
        unsigned char inportb(int nportid);
        cByte = inportb(nPorta);</b>

        Ex.:    unsigned char cByte;
                int nPorta = 03C8;
                cByte = inportb(nPorta);
                printf("%d\n",cByte);
.......................................................................................
<A NAME="5.36"><b>5.36 int86</b></A>
        Esta função configura os registradores e emite uma interrupção de software,
        a função retorna os valores que a interrupção retorna nos registradores.

        Existe uma série de funções de controle e gerenciamento de hardware e
        software que são carregados para a memória durante a inicialização do
        sistema, algumas destas funções são cópias do firmware presentes nas
        placas controladoras de vídeo, de discos, et; e o restante destas funções
        são serviços que o sistema MsDos oferece, coisas como abrir arquivo, salvar
        arquivo, etc.

        Estas funções são identificadas e chamadas por números, que são
        multiplicados por outro número para localizar o endereço da rotina
        numa tabela de endereços de funções.
        <b style="color:green">
        int int86(int intno, union REGS *inregs, union REGS *outregs);
        nSts = int86(nInterrupt, xEntrada, xSaida);</b>

        nInterrupt..Número da interrupção de software
        xEntrada....Estrutura criada com union REGS com configuração
                    inicial dos registradores
        xSaida......Estrutura criada com union REGS com os valores dos registradores
                    que a execução da interrupção retorna em sua finalização.

                        <u>Declarando e usando a estrutura xEntrada e xSaida</u>

        union REGS xEntrada;
        union REGS xSaida;

        Elementos de xEntrada:
        xEntrada.h.ah = 0;
        xEntrada.h.al = 0;
        xEntrada.x.bx = 0xB800;

        int86 (nInterrupt, &xEntrada, &xSaida);
        cMyVar = xSaida.h.ah
        cVariavel = xSaida.h.al
        nValor = xSaida.x.bx

        (...) E assim por diante.
        Os valores que entram e os valores que saem têm um byte de tamanho
        quando o elemento apresenta l ou h em seu final, ah ou al trabalham
        com valores de um byte.
        Os elementos ax,bx,cx,dx,di,si,flags,cflags, trabalham com valores
        de 16 bits.

        Elementos comuns de xEntrada e xSaida:
        xEntrada.x.ax   xEntrada.h.ah   xEntrada.h.al
        xEntrada.x.bx   xEntrada.h.bh   xEntrada.h.bl
        xEntrada.x.cx   xEntrada.h.ch   Entrada.h.cl
        xEntrada.x.dx   xEntrada.h.dh   xEntrada.h.dl

        xEntrada.x.di.....Valor de 16 bits conhecido como Indexador de destino (Destin Index)
        xEntrada.x.si.....Valor de 16 bits conhecido como Indexador de fonte (Source Index)

        xEntrada.x.clags...Flags ou indicadores de status dos processos
        xEntrada.x.flags...Flags ou indicadores de status dos processos

                <u>Parte alta e baixa dos registradores</u>

        O registrador AX é um registrador de 16 bits, os primeiros 8 bits
        da esquerda para a direita são denominados os bits de maior significância
        cuja abreviação é MSB, podem ser manipulados isoladamente através da
        referência AH, sendo este H abreviação de HIGH, que indica que AH é
        a parte alta de AX.

        Os oito bits restantes são conhecidos como os bits de menor signigicância,
        que podem ser manipulados pela referência AL, este L significando LOW,
        que indica que AL é a parte baixa de AX.

        Se por exemplo, AX contiver um valor 0x5003, quer dizer então que
        AH tem o valor 0x50 e AL tem o valor 0x03.
        Você então pode acessar assim os valores dos registradores, supondo
        que você declarou uma union REGS xRegistrador:

        nValor = xRegistrador.x.cx
        cByteAlto = xRegistrador.h.ah
        cByteBaixo = xRegistrador.h.al

        O que foi dito para AX serve igualmente para BX,CX e DX.

        Exemplo:        union REGS xEntrada;
                        union REGS xSaida;
                        int nVideo, nLargura, nPagina;
                        int nVideoServices = 0x10;
                        int nGetVideoInfo = 0x0F;

                        xEntrada.h.ah = nGetVideoInfo;

                        int86 (nVideoServices, &xEntrada, &xSaida);

                        printf("Nro de colunas: %d\n",xSaida.h.ah);
                        printf("Modo de Vídeo: %d\n",xSaida.h.al);
                        printf("Nro da página: %d\n",xSaida.h.bh);

                /* Resulta em
                                        Nro de colunas: 80
                                        Modo de Vídeo: 3
                                        Nro da página: 0        */


        Veja este programa exemplo:<font color="darkblue">
        #include "conio.h"
        #include "stdio.h"
        #include "dos.h"

        int main(int nCmd, char **sCmd) {

        int nVideo, nLargura, nPagina;
        union REGS cpu;
        int nSts;

        clrscr();

        /* Configura registradores antes da execução da interrupção: */
        cpu.h.ah = 0x0F;

        int86(0x10,&cpu, &cpu);

        /* Pegamos os valores que a interrupção retornou: "
        nVideo = cpu.h.al;
        nLargura = cpu.h.ah;
        nPagina  = cpu.h.bh;

        printf("nVídeo: %d\n",nVideo);
        printf("nLargura: %d colunas\n",nLargura);
        printf("nPágina: %d\n\n",nPagina);

        puts("\nEnd of Program.");
        getch();
        }</font>

        Saída:
        nVídeo: 3
        nLargura: 80 colunas
        nPágina: 0
        End of Program.

        Detlhes:        Existe a interrupção 16 (0x10) que oferece vários serviços de
                        vídeo. Cada serviço é indicado por um número principal que
                        é configurado em xEstrutura.h.ah. Por exemplo, 15 (0x0F) é
                        serviço que obtém informações básicas do vídeo, retornando
                        em xEstrutura.h.ah a largura da página, em xEstrtura.ah.al
                        o modo de vídeo, e em xEstrutura.h.bh o número da págfina de
                        vídeo ativa.

.......................................................................................
<A NAME="5.37"><b>5.37 int86x</b></A>
        Esta função gera qualquer interrupção de software e hardware no padrão
        8086. Para obter um maior domínio desta função consulte int86() que
        clarifica o uso de interrupções de software.
        <b style="color:green">
        int int86x(int intno,
                         union REGS *inregs, union REGS *outregs, struct SREGS *segregs);

        nSts = int86x(nInterrupt, xEntrada, xSaida, xSegmentos);</b>

        nInterrupt......Número da interrupção

        xEntrada........Estrutura declarada com union REGS que recebe os valores de
                        configuração dos registradores para a chamada da interrupção

        xSaída..........Estrutura declarada com union REGS que recebe os valores de
                        retorno de finalização da interrupção

        xSegmentos......Estrutura declarada com struct SREGS que é usada para entrada
                        e saída dos valores dos registradores de segmentos.

        Elementos da struc xSegmento:
        xSegmento.cs.........Aponta para o código executável do programa
        xSegmento.ds.........Aponta para o bloco de dados fonte do programa
        xSegmento.es.........Aponta para o bloco de dados destino do programa
        xSegmento.ss.........Aponta para a pilha do programa

        Veja este programa:<font color="darkblue">

        #include "stdio.h"
        #include "conio.h"
        #include "dos.h"

        /* int86x */

        int main (int nCmd, char **sCmd) {

        union REGS xCpu;
        union REGS xInfo;

        int nGetVideoInfo = 0x0F00;
        unsigned char cVideoServices = 0x10;
        struct SREGS xSegmento;

        clrscr();

        xCpu.x.ax = nGetVideoInfo;

        int86x(cVideoServices,&xCpu, &xInfo,&xSegmento);

        printf("nLargura nVideo: %Xh\n",xInfo.x.ax);
        printf("nLargura: %d\n",xInfo.h.ah);
        printf("nVideo: %d\n",xInfo.h.al);
        printf("nPágina: %d\n\n",xInfo.h.bh);

        printf("CS: \%Xh\n",xSegmento.cs);
        printf("DS: \%Xh\n",xSegmento.ds);
        printf("SS: \%Xh\n",xSegmento.ss);
        printf("ES: \%Xh\n",xSegmento.es);

        puts("\nEnd of Program");
        getch();
        }</font>

        Saída:
        nLargura nVideo: 5003h
        nLargura: 80
        nVideo: 3
        nPágina: 0

        CS: FFEAh
        DS: 8463h
        SS: 1134h
        ES: 720h
        End of Program

....................................................................................
<A NAME="5.38"><b>5.38 intdos</b></A>
        Esta função gera uma interrupção 0x21 do MsDos. Esta interrupção
        executa vários serviços que o MsDos oferece, tais como gerenciamento
        de arquivos e hardware. Para conhecer estes serviços é necessário
        consultar um manual de Assembly no tópico interrupções do MsDos.
        <b style="color:green">
        int intdos(union REGS *inregs, union REGS *outregs);
        nSts = intdos(xEntrada, xSaida);</b>

        xEntrada.....estrutura criada com union REGS que contém a configuração
                        dos registradores para executar a interrupçao
        xSaida.......estrutura criada com union REGS para conter o valor dos
                        registradores no final da execução da interrupção.

        Ex.:    union REGS cpu;
                int nPrintString = 0x09;
                char sMsg[]="Estudar é lucrativo!$";
                cpu.h.ah = nPrintString;
                cpu.x.dx = sMsg;
                intdos(&cpu,&cpu);

                /* Resulta em Estudar é lucrativo! */

        Para obter um maior domínio desta função veja a função int86()

.......................................................................................
<A NAME="5.39"><b>5.39 intdosx</b></A>
        Esta função executa qualquer serviço da interrupção 0x21 do MsDos.
        <b style="color:green">
        int intdosx(union REGS *inregs, union REGS *outregs, struct SREGS segregs);
        nSts = intdosx(xEntrada, xSaida, xSegmentos);</b>

        xEntrada.....estrutura criada com union REGS que contém a configuração
                        dos registradores para executar a interrupçao
        xSaida.......estrutura criada com union REGS para conter o valor dos
                        registradores no final da execução da interrupção.
        xSegmentos...estrutura criada com struct SREGS que contém os valores de
                        entrada e saída dos registradores de segmentos de memória.

        Veja o programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"
        #include "dos.h"

        int main (int nCmd, char **sCmd) {

        union REGS xCpu;
        struct SREGS xSegmento;
        char sBuffer[64];
        int nGetCurrentDir = 0x47;

        clrscr();

        xCpu.h.ah = nGetCurrentDir;
        xCpu.h.dl = 0;
        xSegmento.ds = _DS;
        xCpu.x.si = (unsigned ) sBuffer;

        intdosx(&xCpu,&xCpu,&xSegmento);

        printf("%s",sBuffer);

        puts("\nEnd of Program");
        getch();
        }</font>

        Saída:
        TC
        End of Program

        Detalhes:       O serviço 0x47 configurado em xCpu.h.ah obtém o diretório
                        corrente do driver default configurado em xCpu.h.dl = 0.
                        O nome do diretório é retornado sem a barra de caminho no
                        buffer de 64 bytes cujo endereço deve ser passado para
                        DS:SI.

        Para obter maior domínio desta função veja int86() e intdos()

.......................................................................................
<A NAME="5.40"><b>5.40 intr</b></A>
        Esta aqui é uma função alternativa para gerar interrupções padrão
        8086. Veja a função int86() e movedata() para maior domínio desta
        função.
        <b style="color:green">
        void intr(intno, struct REGPACK *preg);
        intr(nInterrupt, xCpu);</b>

        nInterrupt.......Número da interrupção
        xCpu.............Estrutura criada com struct REGPACK

        Elementos de xCpu:
        xCpu.r_ax       xCpu.r_bp       xCpu.r_es
        xCpu.r_bx       xCpu.r_si       xCpu.r_ds
        xCpu.r_cx       xCpu.r_di       xCpu.r_flags
        xCpu.r_dx

        Veja este programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "dos.h"

        int main (int nCmd, char **sCmd) {

        int nMsDos = 0x21;
        int nService = 0x0900;
        char sMsg[]="Aprenda Assembly!$";

        struct REGPACK xCpu;

        clrscr();
        xCpu.r_ax = nService;
        xCpu.r_ds = _DS;
        xCpu.r_dx = (unsigned) sMsg;
        intr(nMsDos,&xCpu);
        puts("\nEnd of Program");
        getch();
        }</font>

        Saída:
        Aprenda Assembly!
        End of Program

        Detalhes:       O uso de interrupções pode produzir grandes estragos, ainda
                        porque o compilador da Borland não analisa o que vc digitou
                        antes da execução do programa e o Windows e o MsDos não são
                        muito vigilantes quanto a segurança. Por exemplo, num erro
                        de digitação você pode acidentalmente gerar uma interrupção
                        que escreve em endereços absolutos no hd e destruir o seu
                        conteúdo ou até a trilha zero inutilizando o disco, requerendo
                        uma reinstalação do Windows.

.......................................................................................
<A NAME="5.41"><b>5.41 keep</b></A>
        Esta função finaliza o programa e o deixa residente na memória como
        um programa TSR.
        <b style="color:green">
        void keep(unsigned char status, unsigned size);
        keep(nSts, nSize);</b>

        * A Borland não proveu um exemplo satisfatoriamente elucidativo desta
        função e desencorajou o uso da mesma.

.......................................................................................
<A NAME="5.42"><b>5.42 MK_FP</b></A>
        Esta função monta um ponteiro far completo, a partir do segmento e
        deslocamento fornecidos.
        <b style="color:green">
        void far *MK_FP(seg,off);
        pFarPonteiro = MK_FP(nSegmento, nDeslocamento);</b>

        Veja programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"
        #include "dos.h"
        #include "alloc.h"

        int main (int nCmd, char **sCmd) {

        char far *pMemoria;
        char far *pFarPonteiro;

        unsigned int nOffSet;
        unsigned int nSegmento;

        clrscr();

        pMemoria = (char far *) farmalloc (64000);

        if (pMemoria==NULL) {
        printf("Memória não concedida!");
        getch();
        exit(0); }

        nSegmento = FP_SEG(pMemoria);
        nOffSet = FP_OFF(pMemoria);
        pFarPonteiro = MK_FP(nSegmento, nOffSet);

        printf("pMemoria: %Fp\n",pMemoria);
        printf("nSegmento: %p\n",nSegmento);
        printf("nOffSet: %p\n",nOffSet);
        printf("pFarponteiro: %Fp\n",pFarPonteiro);

        puts("\nEnd of Program");
        getch();}</font>

        Saída:
        pMemoria: 74EE:0008
        nSegmento: 74EE
        nOffSet: 0008
        pFarponteiro: 74EE:0008
        End of Program

.......................................................................................
<A NAME="5.43"><b>5.43 nosound</b></A>
        Esta função desliga o altofalante.
        <b style="color:green">
        void nosound(void);
        nosound();</b>

        Ex.:    sound(500);
                delay(10000);
                nosound();

.......................................................................................
<A NAME="5.44"><b>5.44 outp</b></A>
        Esta função escreve um byte numa porta.
        <b style="color:green">
        int outp(int portid, int byte_value);
        outp(nPorta, nByte);</b>

        Ex.:    outp(0x3C8,0);
                outp(0x3C9,32);
                outp(0x3C9,32);
                outp(0x3C9,32);

        Aqui neste exemplo a porta identificada por 0x3C8 é o registrador
        de cor das placas de vídeo VGA. O número que está no argumento nByte
        é a cor que vai ter seus valores rgbs lidos ou escritos.

        A porta identificada por 0x3C9 é o registrador de entrada de valores
        rgb. Na primeira escrita entra a taxa de vermelho, na segunda escrita
        entra a taxa de verde, na terceira escrita entra a taxa de azul e a
        próxima escrita pega a taxa de vermelho da próxima cor. E assim
        por diante.

        Neste pequenino exemplo, nós mudamos a taxa de rgb da cor preta cujo
        slot é zero. Nós a econfiguramos como cinza (32,32,32).

        Veja este programa que produz um efeito visual reconfigurando os
        valores rgb da cor preta (slot 0):<font color="darkblue">

        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"
        #include "dos.h"
        #include "time.h"

        int main (int nCmd, char **sCmd) {

        #define SlotCor 0x3C8
        #define SlotRgb 0x3C9
        int x;

        clrscr();
        randomize();

        for (;;) {
        outp(SlotCor,0);
        outp(SlotRgb, random(64));
        outp(SlotRgb, random(64));
        outp(SlotRgb, random(64));
        sleep(1);
        if (kbhit()) break;
        }

        outp(SlotCor,0);
        outp(SlotRgb, 0);
        outp(SlotRgb, 0);
        outp(SlotRgb, 0);

        puts("\nEnd of program");
        getch();
        getch();
        }</font>



.......................................................................................
<A NAME="5.45"><b>5.45 outport</b></A>
        Esta função envia uma palavra para uma porta. O termo 'palavra'
        é usado para descrever um conjunto de 16 bits.
        <b style="color:green">
        void outport(int portid, int value);
        outport(nPorta, nByte);</b>

        Veja o programa exemplo na função outp() acima para melhor compreensão
        desta função.


.......................................................................................
<A NAME="5.46"><b>5.46 outportb</b></A>
        Esta função coloca um byte numa porta.
        <b style="color:green">
        void outport(int portid, unsigned char value);
        outportb(nPorta,cByte);</b>

        Ex.:    outportb(0x3C8,0);
                outportb(0x3C9,32);
                outportb(0x3C9,32);
                outportb(0x3C9,32);

        Veja programa ilustrando uso de porta em outp() acima.

.......................................................................................
<A NAME="5.47"><b>5.47 parsfnm</b></A>
        Esta função separa nome de arquivo e monta um FCB atrelado
        a este nome. FCB está para File Control Block, ou seja, bloco de
        controle de arquivo. É uma estrutura que conserva dados básicos sobre
        o arquivo enquanto este está sendo manipulado pelo sistema.
        <b style="color:green">
        char *parsfnm(const char *cmdline, struct fcb *fcb, int noption);
        parsfnm(sLinha, &xFile, nAL);</b>

        sLinha......Nome do arquivo neste padrão drive:NomeDoArquivo
        &xFile......Estrutura FCB criada com a struct fcb
        nAL.........Valor que seleciona opções via registrador AL
                    Para saber estas opções é necessário consultar
                    um manual de interrupções MsDos INT 0x21 Serviço 0x29


        Elementos de xFile criada com struct fcb:

        struct fcb {
        char   fcb_drive;
        char   fcb_name[8],  fcb_ext[3];
        short  fcb_curblk,   fcb_recsize;
        long   fcb_filsize;
        short  fcb_date;
        char   fcb_resv[10], fcb_currec;
        long   fcb_random;  };

        Veja programa exemplo:<font color="darkblue">
        #include "process.h"
        #include "string.h"
        #include "stdio.h"
        #include"conio.h"
        #include "dos.h"

        int main(void) {
        char sLinha[80];
        struct fcb xFile;

        clrscr();
        printf("Entre com drive e nome de arquivo, com esta sintaxe:\n");
        printf("sem o caminho, assim a:teste.txt\n\n>");

        gets(sLinha);

        if (parsfnm(sLinha, &xFile, 1) == NULL)
        printf("Erro na chamada de parsfnm\n");
        else
        printf("Drive #%d  Nome: %11s\n", xFile.fcb_drive, xFile.fcb_name);

        puts("\nEnd of Program");
        getch();
        return 0;}</font>

        Saída:
        Entre com drive e nome de arquivo, com esta sintaxe:
        sem o caminho, assim a:teste.txt

        &gt;c:teste.txt
        Drive #3  Nome: TESTE   TXT

        End of Program

        Detalhes: Depois de separar com sucesso o nome do arquivo, esta função
        retorna um ponteiro para o próximo byte após o nome do arquivo. Caso
        ocorra erro na separação do nome do arquivo o valor de retorno é 0.

.......................................................................................
<A NAME="5.48"><b>5.48 peek</b></A>
        Esta função retorna o valor de 16 bits que está na posição de memória
        dada em termos de segmento e deslocamento.
        <b style="color:green">
        int peek(unsigned segment, unsigned offset);
        nValor = peek(nSegmento, nDeslocamento);</b>

        Ex.:    unsigned textmem = 0xB800;
                int nValor;
                poke(0xB800,0,0x1F41);
                nValor = peek(textmem,0);
                printf("nValor: \%X\n",nValor);
                /* Resulta em nValor: 1F41 */

        Veja a explanação sobre memória, segmento e deslocamento na função
        movedata de string.h.

.......................................................................................
<A NAME="5.49"><b>5.49 peekb</b></A>
        Esta função retorna o byte que está na posição de memória fornecida,
        dada em termos de segmento e deslocamento.
        <b style="color:green">
        char peek(unsigned segment, unsigned offset);
        cByte = peek(nSegmento, nDeslocamento);</b>

        Ex:     unsigned char cByte;
                unsigned textmem = 0xB800;

                poke(textmem,0,0x1F41);
                cByte = peek(textmem,0);
                printf("Caracter: %u",cByte);
                cByte = peek(textmem,1);
                printf("Atributo: %u",cByte);

                /* Resulta em   A
                                Caracter: 65
                                Atributo: 31    */

        Veja a explanação sobre memória, segmento e deslocamento na função
        movedata de string.h.

.......................................................................................
<A NAME="5.50"><b>5.50 poke</b></A>
        Esta função coloca um valor de 16 bits não-sinalizado numa posição de
        memória dada em termos de segmento e deslocamento.
        <b style="color:green">
        void poke(unsigned segment, unsigned offset, int value);
        poke(nSegmento, nDeslocamento, nValor);</b>

        Ex.:    poke(0xB800,0,0x1F41);

        /* Coloca um 'A' com fundo azul e frente branca na memória de vídeo */

        Veja a explanação sobre memória, segmento e deslocamento na função
        movedata de string.h.

.......................................................................................
<A NAME="5.51"><b>5.51 pokeb</b></A>
        Esta função coloca um valor de 8 bits não-sinalizado numa posição de
        memória dada em termos de segmento e deslocamento.
        <b style="color:green">
        void pokeb(unsigned segment, unsigned offset, char value);
        pokeb(nSegmento, nDeslocamento, cChar);</b>

        Ex.:    pokeb(0xB800,0,65);

        /* Coloca um 'A' na memória de vídeo */

        Veja a explanação sobre memória, segmento e deslocamento na função
        movedata de string.h.

.......................................................................................
<A NAME="5.52"><b>5.52 randbrd</b></A>
        Esta função lê registros do arquivo em disco usando o FCB.
        Para que esta função trabalhe adequadamente você precisa
        configurar alguns elementos da struct fcb, e prover uma dta
        para aonde irão os dados lidos.

        <b style="color:green">
        int randbrd(struct fcb, int rcnt);
        nSts = randbrd(&xFcb,nRegistro);</b>

        Detalhes: Conforme o retorno, nSts têm estes significados:
                0.....Sucesso total, todo os registro forma lidos
                1.....Fim de arquivo (EOF), a leitura do último registro foi completa
                2.....Leitura de registro foi embrulhada no mesmo segmento.
                      Isto pode ocorrer quando é alcançado o deslocamento 0xFFFF e
                      faz-se uma leitura de arquivo.
                3.....Fim de arquivo, a leitura do último registro foi incompleta.

        Veja programa exemplo:<font color="darkblue">
        #include "dos.h"
        #include "alloc.h"
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int main(void) {
        char far *save_dta;
        char sBuffer[256];
        char sLinha[]="c:teste.txt";
        struct fcb xFile;
        int cx, nSts;

        clrscr();

        /* Vamos registrar o FCB */
        if (!parsfnm(sLinha, &xFile, 1))  {
        printf("Erro na chamada de parsfnm\n");
        exit(1); }
        printf("Drive #%d  Arquivo: %s\n\n", xFile.fcb_drive, xFile.fcb_name);

        /* Vamos abrir arquivo usando o serviço do MsDos DOS FCB open file */
        bdosptr(0x0F, &xFile, 0);

        /* Vamos salvar a dta original, e estabelecer uma nova */
        save_dta = getdta();
        setdta(sBuffer);

        /* Vamos configurar o FCB para trabalhar bem com a dta */
        xFile.fcb_recsize = 128;
        xFile.fcb_random = 0L;
        nSts = randbrd(&xFile, 1);

        /* Vamos checar o status de retorno de randbrd() */
        if (!nSts)
        printf("Leitura OK\n\n");
        else {
        perror("Erro de leitura");
        exit(1); }

        /* Lendo dados a partir da nova dta: */
        printf("Os primeiros 128 bytes são:\n");
        for (cx=0; cx<128; cx++)
        putchar(sBuffer[cx]);

        /* Vamos recuperar a dta original: */
        setdta(save_dta);

        puts("\nEnd of Program.");
        getch();
        return 0; }</font>

        Saída:
        Drive #3  Arquivo: TESTE   TXT

        Leitura OK

        Os primeiros 128 bytes são:
        abcdefghijklmnopqrtuvwxyz
        abcdefghijklmnopqrtuvwxyz
        abcdefghijklmnopqrtuvwxyz
        abcdefghijklmnopqrtuvwxyz
        abcdefghijklmnopqrtu
        End of Program.

.......................................................................................
<A NAME="5.53"><b>5.53 randbwr</b></A>
        Esta função escreve informações em um arquivo em disco usando o FCB.
        Para fazer uso desta função você deve configurar adequadamente um
        FCB, e configurar também uma DTA daonde os dados serão tirados para
        gravação.
        <b style="color:green">
        int randbwr(struct fcb, int rcnt);
        nSts = randbwr(&xFcb,nRegistro);</b>

        Detalhes: Conforme o valor de retorno, nSts significa:
                        0....Todos os registros foram escritos
                        1....Espaço insuficiente para gravação
                        2....Gravação de registros foi embrulhada no mesmo segmento.
                        Isso ocorre quando a dta atingiu o limite de segmento e é
                        jogado mais informações na dta com esta condição.

        Veja o programa exemplo:<font color="darkblue">
        #include "dos.h"
        #include "alloc.h"
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int main(void){
        char far *save_dta;
        char sLinha[]="c:wteste.txt";
        char sBuffer[256] = "Testando randbwr().\n";
        struct fcb xFcb;
        int nSts;

        clrscr();

        /* Vamos preparar um FCB: */
        parsfnm(sLinha,&xFcb,1);
        printf("Drive #%d  Arquivo: %s\n", xFcb.fcb_drive, xFcb.fcb_name);

        /* Vamos usar um serviço do MsDos DOS criar arquivo */
        if (bdosptr(0x16, &xFcb, 0) == -1) {
        perror("Erro na criação de arquivo.");
        exit(1);}

        /* Vamos salvar a dta original e estabelecer uma nova */
        save_dta = getdta();
        setdta(sBuffer);

        /* Grava os novos registros: */
        xFcb.fcb_recsize = 256;
        xFcb.fcb_random = 0L;
        nSts = randbwr(&xFcb, 1);

        if (!nSts)
        printf("Gravaço OK\n");
        else {
        perror("Erro de Disco.");
        exit(1);}

        /* Vamos fechar o arquivo via DOS fechar arquivo: */
        if (bdosptr(0x10, &xFcb, 0) == -1) {
        perror("Erro em fechamento de arquivo.");
        exit(1);}

        /* Vamos recuperar a dta original*/
        setdta(save_dta);
        getch();
        puts("\nEnd of Program.");
        return 0;}      </font>


.......................................................................................
<A NAME="5.54"><b>5.54 segread</b></A>
        Esta função obtém os valores atuais dos registradores de segmentos.
        <b style="color:green">
        void segread(struct SREGS *segp);
        segread(&xSegmento);</b>

        Ex.:    struct SREGS xSegmento;
                segread(&xSegmento);
                printf("Data Segment \%X\n",xSegmento.ds);
                printf("Code Segment \%X\n",xSegmento.cs);
                printf("Extra Segment \%X\n",xSegmento.es);
                printf("Stack Segment \%X\n",xSegmento.ss);

        Detalhes:       Todos os elementos da struct xSegmento declarada com SREGS,
                        são do tipo unsigned int. Os elementos desta estrutura são
                        apenas estes quatros: .ds, .cs, .es e .ss


.......................................................................................
<A NAME="5.55"><b>5.55 setblock</b></A>
        Esta função redefine o tamanho do bloco de memória alocado previamente
        com allocmem(), permitindo obter mais memória com o mesmo ponteiro.
        <b style="color:green">
        int setblock(unsigned segx, unsigned newsize);
        nSts = setblock(pMemoria, nTam);</b>

        Veja o programa exemplo:<font color="darkblue">
        #include "dos.h"
        #include "alloc.h"
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int main(void){
        unsigned int nTam, pMemoria;
        int nSts;

        clrscr();

        nTam = 64; /* (64 x 16) = 1024 bytes */
        nSts = allocmem(nTam, &pMemoria);

        if (nSts == -1)
        printf("A memória foi alocada no segmento: %Xh\n", pMemoria);
        else {
        printf("Falhou: O tamanho máximo liberado foi %d\n",nSts);
        exit(1);}

        nSts = setblock(pMemoria, nTam * 2);

        if (nSts == -1)
        printf("Tamanho do bloco livre foi duplicado no segmento: %Xh\n", pMemoria);
        else
        printf("Falhou: O tamanho máximo liberado foi %d\n",nSts);

        freemem(pMemoria);

        puts("\nEnd of Program.");
        getch();
        return 0;}</font>

        Saída:
        A memória foi alocada no segmento: 7497h
        Tamanho do bloco livre foi duplicado no segmento: 7497h
        End of Program.

        Detalhes: Para sucesso o valor de retorno é -1. Em caso de erro é
        retornado o tamanho do maior bloco disponível. O tamanho é dado e
        obtido em parágrafos.

.......................................................................................
<A NAME="5.56"><b>5.56 setcbrk</b></A>
        Esta função ativa ou desativa verificação de control break.
        <b style="color:green">
        int setcbrk(int cbrkvalue);
        nSts = setcbrk(nConfig);</b>

        nConfig.........Se 1, então será feito a verificação de control break
                        em todas as chamadas ao sistema. Se 0 (zero) a verificação
                        é feita apenas em processos de entrada e saída de vídeo,
                        teclado, comunicações e impressora.

        nSts............A função retorna o valor passado em nConfig

        Ex.:    setcbrk(0);

        Detalhes:       Em nossos testes, com nConfig=0, não houve desativação
                        da paralisação do programa ao pressionamento de control break
                        que continuou sendo operante. Na prática não descobrimos a
                        funcionalidade e utilidade desta função.

.......................................................................................
<A NAME="5.57"><b>5.57 setdate</b></A>
        Esta função configura uma nova data para o sistema.
        <b style="color:green">
        void setdate(struct date *datep);
        setdate(&xToday);</b>

        Ex.:    struct date xToday;
                xToday.da_day = 1;
                xToday.da_mon = 3;
                xToday.da_year = 2007;
                setdate(&xToday);

.......................................................................................
<A NAME="5.58"><b>5.58 setdta</b></A>
        Esta função determina um novo endereço para a DTA, data transfer
        Address, que é o buffer para operações de I/O em disco.
        <b style="color:green">
        void setdta(char far *dta);
        setdta(sNewDta);</b>

        Ex.:    char sNewDta[1024];
                setdta(sNewDta);

.......................................................................................
<A NAME="5.59"><b>5.59 settime</b></A>
        Esta função configura uma nova hora para o sistema.
        <b style="color:green">
        void settime(struct time *timep);
        settime(&xTempo);</b>

        Ex.:    struct time xTempo;
                xTempo.ti_hour = 21;
                xTempo.ti_min = 50;
                xTempo.ti_sec = 59;
                xTempo.ti_hund = 99;
                settime(&xTempo);

.......................................................................................
<A NAME="5.60"><b>5.60 setvect</b></A>
        Esta função determina um novo vetor para uma interrupção,
        por outras palavras você pode associar uma função a uma interrupção
        que será executada sempre que ocorrer a interrupção definida,
        desta forma você redefine o handler() que gerencia a interrupção.
        <b style="color:green">
        void setvect(int interruptno, void interrupt (*isr) ( ));
        setcvect(nInterrupt, pAddress);</b>

        Veja o programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"
        #include "dos.h"

        /***NOTA:
        Esta interrupção é uma rotina de serviço.  Você NÃO pode compilar
        este programa com 'Test Stack Overflow' habilitado e conseguir
        um arquivo executável que opere corretamente. */

        int nInterrupt = 0x1C; /* Interrupção de tick do relógio */

        #define __CPPARGS

        void interrupt ( *oldhandler)(__CPPARGS);

        int count=0;

        void interrupt handler(__CPPARGS) {
        count++;

        /* Vamos chamar a antiga rotina: */
        oldhandler(); }

        int main(void){
        /* Vamos salvar o vetor original da interrupção: */
        oldhandler = getvect(nInterrupt);

        /* Vamos instalar o novo gerenciador da interrupção: */
        setvect(nInterrupt, handler);

        while (count < 20)
        printf("Contador:  %d\n",count);

        /* Vamos retornar o vetor original: */
        setvect(nInterrupt, oldhandler);

        return 0;}</font>

.......................................................................................
<A NAME="5.61"><b>5.61 setverify</b></A>
        Esta função configura o flag de confirmação de gravação em disco.
        <b style="color:green">
        void setverify(int value);
        setverify(nSts);</b>

        nSts.....Coloque 1 para ligar, zero para desligar.

        Detalhes:       O zero indica que a integridade da operação de gravação
                        não é confirmada com uma leitura subsequente dos
                        dados, enquanto 1 indica que isto deve ser feito.

        Ex.:    int nSts=1;
                setverify(nSts);

.......................................................................................
<A NAME="5.62"><b>5.62 sleep</b></A>
        Esta função suspende a execução do programa por um intervalo de tempo
        dado em segundos.
        <b style="color:green">
        void sleep(unsigned seconds);
        sleep(nSegundos);</b>

        Ex.:    sleep(2);

.......................................................................................
<A NAME="5.63"><b>5.63 sound</b></A>
        Esta função aciona o altofalante numa determinada frequência.
        A frequência é tocada até que outra função desligue o altofalante.
        <b style="color:green">
        void sound(unsigned frequency);
        sound(nFrequency);</b>

        Ex.:    sound(500);
                delay(10000);
                nosound();

.......................................................................................
<A NAME="5.64"><b>5.64 unixtodos</b></A>
        Esta função converte data e horas do formato UNIX para o formato
        normal do sistema operacional MsDos.
        <b style="color:green">
        void unixtodos(long time, struct date *d, struct time *d);
        unixtodos(nUnixFmt, &xToday, &xTempo);</b>

        Para maior domínio desta função veja a função irmã dostounix().

.......................................................................................
<A NAME="5.65"><b>5.65 unlink</b></A>
        Esta função deleta o arquivo especificado, retornando 0 para sucesso
        e -1 caso não tenha conseguido eliminar o arquivo.
        <b style="color:green">
        int unlink(const char *filename);
        nSts = unlink(sNomeArquivo);</b>

        Ex.:    char *sFileName="vitima.txt";
                int nSts;
                nSts = unlink(sFileName);


<table align=bottom border=0 cellspacing=0 cellpadding=0 width=20%><tr><td><a href=cbiblioteca.html style='color:blue'> index </a></td><td><a href='track04.html'style='color:blue'>&lt;&lt;</a></td><td><a href='track06.html'style='color:blue'>&gt;&gt;</a></td></tr></table><hr><div style='background-color:lightyellow;color:blue'>
<center>Produzido por Gameprog: Jair Pereira - Fev/2006 - Junho/2013 ©
gameprog.br@gmail.com
<a href='http://www.gameprog.com.br'>http://www.gameprog.com.br</a></center><hr></div></body></html>
