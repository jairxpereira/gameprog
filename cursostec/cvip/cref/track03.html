<html><head>
<title>cbiblioteca_track03_stdlib</title>
<style type="text/css">

span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc2 {
	color: #008000;
}
.sc4 {
	color: #ff8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #FF0000;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #400080;
}

.prg {
	color: #0000FF;
}
</style></head>
<body><font color="black"><pre>
<hr>
<center><b>GAMEPROG - Escola de programação de jogos digitais</b><br><b>Contato: Jair Pereira - gameprog.br@gmail.com</b><br><b>Guia completo de referência da biblioteca padrão da Linguagem C [Borland Turbo C/++ ver 3.1]</b><br><b>track03.html</b><br></center><table align=bottom border=0 cellspacing=0 cellpadding=0 width=20%><tr><td><a href=cbiblioteca.html style='color:blue'> index </a></td><td><a href='track02.html'style='color:blue'>&lt;&lt;</a></td><td><a href='track04.html'style='color:blue'>&gt;&gt;</a></td></tr></table>
<hr>
<A NAME="3.00"></A><center><h2>3.00 stdlib.h</h2></center>
<A HREF="#3.01">3.01</a> abort.............Aborta bruscamente a execução do programa
<A HREF="#3.02">3.02</a> abs...............Retorna o valor absoluto de um número inteiro
<A HREF="#3.03">3.03</a> atexit............Registra funções de finalização do programa
<A HREF="#3.04">3.04</a> atof..............Converte uma string para número flutuante
<A HREF="#3.05">3.05</a> atoi..............Converte uma string para um número inteiro
<A HREF="#3.06">3.06</a> atol..............Converte uma string para um número inteiro longo
<A HREF="#3.07">3.07</a> bsearch...........Executa pesquisa binária numa tabela em busca de um valor
<A HREF="#3.08">3.08</a> calloc............Aloca memória principal
<A HREF="#3.09">3.09</a> div...............Divide dois números inteiros
<A HREF="#3.10">3.10</a> ecvt..............Converte um número flutuante para uma string
<A HREF="#3.11">3.11</a> _exit.............Finaliza o programa
<A HREF="#3.12">3.12</a> exit..............Encerra normalmente a execução do programa

<A HREF="#3.13">3.13</a> fcvt..............Converte um número float para uma string
<A HREF="#3.14">3.14</a> free..............Libera bloco de memória alocada com malloc() ou calloc()
<A HREF="#3.15">3.15</a> gcvt..............Converte literalmente um número float para uma string
<A HREF="#3.16">3.16</a> getenv............Obtém o valor de uma variável de ambiente
<A HREF="#3.17">3.17</a> itoa..............Converte um número inteiro para uma string
<A HREF="#3.18">3.18</a> labs..............Retorna o valor absoluto de um número inteiro longo
<A HREF="#3.19">3.19</a> ldiv..............Divide dois números inteiros longos
<A HREF="#3.20">3.20</a> lfind.............Pesquisa linearmente um valor numa array
<A HREF="#3.21">3.21</a> _lrotl............Roda os bits de um inteiro longo para a esquerda
<A HREF="#3.22">3.22</a> _lrotr............Roda os bits de um inteiro longo para a direita
<A HREF="#3.23">3.23</a> lsearch...........Pesquisa linearmente um valor numa array
<A HREF="#3.24">3.24</a> ltoa..............Converte um número inteiro longo para uma string.

<A HREF="#3.25">3.25</a> malloc............Aloca memória principal
<A HREF="#3.26">3.26</a> max...............Retorna o maior de dois números inteiros
<A HREF="#3.27">3.27</a> min...............Retorna o menor de dois números inteiros
<A HREF="#3.28">3.28</a> putenv............Configura uma variável de ambiente
<A HREF="#3.29">3.29</a> qsort.............Organiza uma array de valores em ordem crescente
<A HREF="#3.30">3.30</a> rand..............Retorna um número aleatório entre 0 e 32767
<A HREF="#3.31">3.31</a> random............Retorna um número aleatório entre zero e o valor fornecido
<A HREF="#3.32">3.32</a> randomize.........Ativa o gerador de número aleatórios
<A HREF="#3.33">3.33</a> realloc...........Realoca memória para um bloco

<A HREF="#3.34">3.34</a> _rotl.............Roda os bits de um inteiro para a esquerda
<A HREF="#3.35">3.35</a> _rotr.............Roda os bits de um inteiro para a direita
<A HREF="#3.36">3.36</a> srand.............Inicializa o gerador de números aleatórios
<A HREF="#3.37">3.37</a> strtod............Converte uma string para um número double
<A HREF="#3.38">3.38</a> strtol............Converte uma string em qualquer base numérica para um inteiro longo
<A HREF="#3.39">3.39</a> strtoul...........Converte uma string em  qualquer base para um longo não sinalizado.
<A HREF="#3.40">3.40</a> swab..............Copia uma string para outra permutando bytes pares pelos ímpares
<A HREF="#3.41">3.41</a> system............Executa arquivo .bat, .com ou .exe do Ms_Dos
<A HREF="#3.42">3.42</a> ultoa.............Converte um longo não sinalizado para uma string

.......................................................................................
<A NAME="3.01"><b>3.01 abort</b></A>
        Esta função encerra bruscamente a execução do programa.
        <b style="color:green">
        void abort(void);
        abort();</b>

        Ex.:    if (nIdade > 120) abort();

        Detalhes: A mensagem 'Abnormal program termination' é exibida.

.......................................................................................
<A NAME="3.02"><b>3.02 abs</b></A>
        Esta função retorna o valor absoluto de um número inteiro.
        <b style="color:green">
        int abs (int x);
        nNumber = abs(nNumberx);</b>

        Ex.:    int nNumberx = -10;
                printf("nNumber: %d",abs(nNumberx));
                /* Resulta em nNumber: 10 */

.......................................................................................
<A NAME="3.03"><b>3.03 atexit</b></A>
        Esta função registra funções que serão executadas logo antes da
        finalização do programa.
        <b style="color:green">
        int atexit(atexit_t func);
        nSts = atexit(FuncName);</b>

        nSts.......Esta função retorna 0 para sucesso e nonzero para falhas.
        FuncName...Representa o nome da função que será chamada na finalização

        Ex.:    void final(void);
                atexit(final);

        Detalhes:
        Esta função, simples de ser usada, é muito útil para finalizar
        o programa com charme. Até 32 funções podem ser registradas,
        sendo a execução delas feitas na base de a última que entra
        é a primeira a ser chamada.

.......................................................................................
<A NAME="3.04"><b>3.04 atof</b></A>
        Esta função converte uma string para um número flutuante.
        <b style="color:green">
        double atof(const char *s);
        nFloat = atof(sNumber);</b>

        Ex.:    char *sPi="3.141516";
                float nFloat;
                nFloat = atof(sPi);

        Detalhes:
        Esta função não funcionou em nossos testes no Turbo C Borland,
        vindo a funcionar no compilador Turbo C++ 3.1 da Borland.

.......................................................................................
<A NAME="3.05"><b>3.05 atoi</b></A>
        Esta função converte uma string para um número inteiro.
        <b style="color:green">
        int atoi(const char *s);
        nNumber = atoi(sNumber);</b>

        Ex.:    char *sIdade="33";
                int nIdade;
                nIdade = atoi(sIdade);

        Detalhes:
        Se a string não puder ser convertida o valor de retorno é zero.

.......................................................................................
<A NAME="3.06"><b>3.06 atol</b></A>
        Esta função converte uma string para um número inteiro longo.
        <b style="color:green">
        long atol(const char *s);
        nLongNumber = atol(sLongNumber);</b>

        Ex.:    char sLongNumber[] = "66000";
                int nLongNumber;
                nLongNumber = atol(sLongNuumber);

        Detalhes:
        Se a string não puder ser convertida o valor de retorno é zero.

.......................................................................................
<A NAME="3.07"><b>3.07 bsearch</b></A>
        Esta função executa uma pesquisa binária em uma tabela em busca
        por um valor. A tabela deve estar organizada em ordem crescente
        de valores. Noutros termos, essa função procura um valor numa array,
        essa função é mais rápida que lfind() e lsearch().
        <b style="color:green">
        void *bsearch(const void *key, const void *base,
        size_t *nelem, size_t width,
        int (*fcmp)(const void*, const void*));

        nResultado = bsearch (&nProcurado, nMyArray, nArrayTam, nElementoTam,
        (int (*) (const void *, const void *)) UserDefinedFunction);</b>

        nResultado........Em caso de sucesso, o valor procurado é retornado, retornando
                          zero caso valor não foi localizado.

        &nProcurado.......O valor procurado deve ser passado por referência

        nMyArray..........A tabela onde procurar o valor

        nElementoTam......Tamanho geral do elemento da tabela obtido com sizeof()

        UserDefinedFunction....Nome da função que compara dois valores com esta sintaxe:
        (int (*) (const void *, const void *)) UserDefinedFunction)

        Detalhes:
        Para maior domínio desta função veja as funções similares que
        são lfind()e lsearch()

        Veja o programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int comparar (int *x, int *y) {
        return(*x-*y); }

        int main (int nCmd, char **sCmd) {

        int nMyArray[] = {10,20,30,40,50};
        int nProcurado = 50;
        size_t nArrayTam = 5;
        int *nResultado;

        clrscr();

        nResultado = bsearch(&nProcurado, nMyArray, nArrayTam, sizeof(int),
        (int (*)(const void *, const void *))comparar);

        if (nResultado) printf("Localizado: %d\n",*nResultado);

        else printf("%d Não encontrado!\n",*nResultado);

        puts("\End of Program");
        getch(); }</font>

.......................................................................................
<A NAME="3.08"><b>3.08 calloc</b></A>
        Esta função aloca memória principal para nElementos de nBytes cada
        um, sendo o total de bytes dado por nElementos * nBytes.
        <b style="color:green">
        void *calloc (size_t nelem, size_t elsize);
        MemPtr = (DataType *) calloc (nNumber,nBytes);</b>

        MemPtr........A função retorna um ponteiro que aponta para a área alocada
        (DataType *)..Você precisa usar um casting para garantir que o ponteiro
                      retornado seja do tipo certo.
        nNumber.....A quantidade de elementos
        nBytes......O tamanho em bytes de cada elemento

        Ex.:    char *sNomes;
                int nNome = 10;
                int nBytes = sizeof(char) * 20;
                sNome = (char *) calloc (nNome,nBytes);

        Em caso de falha ou memória insuficiente, o valor de retorno
        do ponteiro é NULL. Os bytes da área alocada são zerados.
        Para outros detalhes veja a função malloc().

        Veja mais este programinha:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"

        int main(void) {
        char *str = NULL;

        clrscr();

        str = (char *) calloc(10, sizeof(char));
        if (str==NULL) {
        printf("Memória insuficiente\n");
        abort();}

        strcpy(str, "Reservado");

        printf("%s\n", str);

        free(str);
        getch();
        return 0; }</font>

.......................................................................................
<A NAME="3.09"><b>3.09 div</b></A>
        Esta função divide dois números inteiros.
        <b style="color:green">
        div_t div(int numer, int denom);
        xDivStru = div(nNumerador,nDenominador);</b>

        Ex.:    div_t xDivStru;
                int nNumerador=100;
                int nDenominador=3;
                xDivStru = div(nNumerador,nDenominador);
                printf("Resultado: %d",xDivStru.quot);
                printf("Resto: %d",xDivStru.rem);

        Detalhes:       A estrutura div_t apresenta esses dois elementos:
                        int quot, int rem.

        Programa ilustrando div():<font color="darkblue">
        /* div() ldiv()*/
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int main (int nCmd, char **sCmd) {
        div_t mat;
        ldiv_t lmat;

        long nNumer=67003;
        long nDenom=4;

        int nNumerador=100;
        int nDenominador=3;

        mat = div(nNumerador,nDenominador);
        lmat = ldiv(nNumer,nDenom);

        clrscr();

        printf("\n\nTestando div(): \n\n");
        printf("nNumerador: %d\n",nNumerador);
        printf("nDenominador: %d\n",nDenominador);
        printf("Resultado: %d\n",mat.quot);
        printf("Resto: %d\n",mat.rem);

        printf("\n\nTestando ldiv(): \n\n");
        printf("nNumerador: %ld\n",nNumer);
        printf("nDenominador: %ld\n",nDenom);
        printf("Resultado: %ld\n",lmat.quot);
        printf("Resto: %ld\n",lmat.rem);

        puts("\End of Program");
        getch(); }</font>

        Esta é a saída deste programa:

        Testando div():

        nNumerador: 100
        nDenominador: 3
        Resultado: 33
        Resto: 1

        Testando ldiv():

        nNumerador: 67003
        nDenominador: 4
        Resultado: 16750
        Resto: 3
        End of Program

.......................................................................................
<A NAME="3.10"><b>3.10 ecvt</b></A>
        Esta função converte um número flutuante double para uma string.
        <b style="color:green">
        char *ecvt(double value, int ndig, int *dec, int *sign);
        sNumber = ecvt(nDoubleNumber, nDig, &nDec, &nSign);</b>

        sNumber.....Esta string, cujo tamanho é determinado pelo valor que você
                    coloca em nDig, recebe o número double convertido.

        nDig........Tamanho máximo da string, se nDig for maior que o número de
                    de digitos presente no número float, o restante da string sNumber
                    é completado com zeros.

        nDec........Retorna a localização do ponto decimal no número float, você
                    deve declarar nDec como int no início da sua função e passá-lo
                    por referência (&nDec) a ecvt().

        nSign.......Retorna zero para floats positivos, 1 para negativos. Tal como
                    nDec você deve declará-lo como int e passá-lo por referência a ecvt()

        Ex.:    char *sNumber;
                int nDec, nSign;
                int nDig=6;
                double nPi = -3.141516;
                sNumber = ecvt(nPi,nDig, &nDec, &nSign);

        Detalhes:
        ecvt() e fcvt() fazem a mesma coisa, a difença entre elas
        reside na maneira de cada uma fazer o arrendondamento do
        valor que será convertido.

        Na string convertida não há o ponto decimal, para isso
        você deve usar gcvt().

        Veja a seguir o programa exemplo, ilustrando ecvt():<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int main (int nCmd, char **sCmd) {

        double npi = -3.141516;
        int nDec,nSign;
        int nDig;

        char *sNumber;

        nDig=6;
        nSign=1;
        nDec=1;

        clrscr();

        sNumber = ecvt(npi,nDig,&nDec,&nSign);
        printf("nPi: %lf\t \tnDig=%d \tDec=%d \tSign=%d \n",npi,nDig,nDec,nSign);
        printf("sNumber: %s\n",sNumber);

        puts("\End of Program");
        getch(); }</font>

        Este programa apresenta a seguinte saída:

        nPi: -3.141516          nDig=6  Dec=1   Sign=1
        sNumber: 314152
        End of Program

        Repare que na string convertida não há o ponto decimal.

.......................................................................................
<A NAME="3.11"><b>3.11 _exit</b></A>
        Esta função termina o programa, retornando nStatus para o sistema operacional.
        <b style="color:green">
        void _exit(int status);
        _exit(nSts);</b>

        Ex.:    _exit(1);

        Detalhes:
        Diferente de exit(), _exit() não chama as funções de finalização
        registradas por atexit()

.......................................................................................
<A NAME="3.12"><b>3.12 exit</b></A>
        Esta função termina normalmente a execução do programa, retornando um
        valor inteiro para o sistema operacional.
        <b style="color:green">
        void exit (int status);
        exit(nSts);</b>

        Ex.:    exit(1);

        Detalhes:
        Esta função efetiva a gravação dos buffers de saída,
        encerra os arquivos e chama as funções de finalização
        registradas com a função atexit().

.......................................................................................
<A NAME="3.13"><b>3.13 fcvt</b></A>
        Esta função converte um número flutuante double para uma string.
        <b style="color:green">
        char *fcvt(double value, int ndig, int *dec, int *sign);
        sNumber = fcvt(nDoubleNumber, nDig, &nDec, &nSign);</b>

        sNumber.....Esta string, cujo tamanho é determinado pelo valor que você
                    coloca em nDig, recebe o número double convertido.

        nDig........Tamanho máximo da string, se nDig for maior que o número de
                    de digitos presente no número float, o restante da string sNumber
                    é completado com zeros.

        nDec........Retorna a localização do ponto decimal no número float, você
                    deve declarar nDec como int no início da sua função e passá-lo
                    por referência (&nDec) a ecvt().

        nSign.......Retorna zero para floats positivos, 1 para negativos. Tal como
                    nDec você deve declará-lo como int e passá-lo por referência a ecvt()

        Ex.:    char *sNumber;
                int nDec, nSign;
                int nDig=6;
                double nPi = -3.141516;
                sNumber = fcvt(nPi,nDig, &nDec, &nSign);

        Detalhes:
        ecvt() e fcvt() fazem a mesma coisa, a difença entre elas
        reside na maneira de cada uma fazer o arrendondamento do
        valor que será convertido.

        Na string convertida não há o ponto decimal, para isso
        você deve usar gcvt().

        Veja a seguir o programa exemplo, ilustrando fcvt():<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int main (int nCmd, char **sCmd) {

        double npi = -3.141516;
        int nDec,nSign;
        int nDig;

        char *sNumber;

        nDig=6;
        nSign=1;
        nDec=1;

        clrscr();

        sNumber = fcvt(npi,nDig,&nDec,&nSign);
        printf("nPi: %lf\t \tnDig=%d \tDec=%d \tSign=%d \n",npi,nDig,nDec,nSign);
        printf("sNumber: %s\n",sNumber);

        puts("\End of Program");
        getch(); }</font>

        Este programa apresenta a seguinte saída:

        nPi: -3.141516          nDig=6  Dec=1   Sign=1
        sNumber: 3141516
        End of Program

.......................................................................................
<A NAME="3.14"><b>3.14 free</b></A>
        Esta função libera para o sistema operacional o bloco de memória
        que foi alocada com malloc() ou calloc() anteriormente.
        <b style ="color:green">
        void free( void *block);
        free(BlockPtr);</b>

        Ex.:            free(IntPtr);

.......................................................................................
<A NAME="3.15"><b>3.15 gcvt</b></A>
        Esta função converte literalmente um número flutuante double para
        uma string.
        <b style="color:green">
        char *gcvt(double value, int ndig, char *buf);
        sString = gcvt(nDoubleNumber,nDig, sNumber);</b>

        sString.........A função retorna um ponteiro para sNumber
        nDoubleNumber...Número flutuante double que será convertido.
        sNumber.........String que recebe o número convertido.
        nDig............O tamanho máximo da string. Se o número de dígitos
                        em nDoubleNumber for maior que nDig, gcvt() performa
                        um arrendondamento neste número a ser convertido.

        Ex.:    char sNumber[40];
                double nDoubleNumber = 3.141516;
                int nDig=7;
                gcvt(nDoubleNumber,nDig,sNumber);
                printf("%s",sNumber);

        Veja este programa exemplo, ilustrando gcvt():<font color="darkblue">
        /* gcvt() */
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int main (int nCmd, char **sCmd) {

        double npi = -3.141516;
        int nDig;

        char sNumber[40];

        nDig=7;

        clrscr();

        gcvt(npi,nDig,sNumber);
        printf("nPi: %lf\t \tnDig=%d \n",npi,nDig);
        printf("sNumber: %s\n",sNumber);

        printf("\n");
        nDig=6;
        gcvt(npi,nDig,sNumber);
        printf("nPi: %lf\t \tnDig=%d \n",npi,nDig);
        printf("sNumber: %s\n",sNumber);

        puts("\End of Program");
        getch(); }</font>

        Veja a saída deste programa:
        nPi: -3.141516          nDig=7
        sNumber: -3.141516

        nPi: -3.141516          nDig=6
        sNumber: -3.14152
        End of Program

....................................................................................
<A NAME="3.16"><b>3.16 getenv</b></A>
        Esta função obtém o valor de uma variável de ambiente.
        <b style="color:green">
        char *getenv(const char *name);
        sValor = getenv(sSystemVar);</b>

        Ex.:    char *sTempDir;
                sTempDir = getenv("TEMP");
                printf("%s",sTempDir);
                /* Resulta em C:\WINDOWS\TEMP */

.......................................................................................
<A NAME="3.17"><b>3.17 itoa</b></A>
        Esta função converte um número inteiro para uma string, podendo
        esta conversão ser para qualquer base.
        <b style="color:green">
        char *itoa(int value, char *string, int radix);
        sString = itoa(nNumber,sNumber,nBase);</b>

        sString.....Esta função retorna um ponteiro para sNumber
        sNumber.....String que recebe o número convertido
        nNumber.....Número inteiro a ser convertido
        nBase.......Base numérica para a conversão, pode ser 2,8,10 ou 16.

        Ex.:    char *sString;
                char sNumber[40];
                int nNumber=32000;
                sString = itoa(nNumber,sNumber,16);

        Para um maior domínio desta função, veja a funcão ultoa() que
        apresenta maiores detalhes.

.......................................................................................
<A NAME="3.18"><b>3.18 labs</b></A>
        Esta função retorna o valor absoluto de um número inteiro longo.
        <b style="color:green">
        long labs(long x);
        nAbsValor = labs(nLongNumber);</b>

        Ex.:    long int nNumber = -66000;
                printf("%li",abs(nNumber);
                /* Resulta em 66000 */

.......................................................................................
<A NAME="3.19"><b>3.19 ldiv</b></A>
        Esta função divide dois números inteiros longos.
        <b style="color:green">
        ldiv_t ldiv(long numer, long denom);
        xDivStru = ldiv(nNumerador,nDenominador);</b>

        Ex.:    ldiv_t xDivStru;
                long nNumerador=66000;
                long nDenominador=3;
                xDivStru = ldiv(nNumerador,nDenominador);
                printf("Resultado: %ld\n",xDivStru.quot);
                printf("Resto: %ld\n",xDivStru.rem);

        Detalhes:       A estrutura ldiv_t apresenta esses dois elementos:
                        long quot, long rem.

        Veja programa que ilustra ldiv() em div().

.......................................................................................
<A NAME="3.20"><b>3.20 lfind</b></A>
        Esta função pesquisa linearmente um valor numa array com o auxílio
        de uma função de comparação de dois valores definida pelo usuário.
        <b style="color:green">
        void *lfind(const void *key, const void *base,size_t *pnelem, size_t width,
               int (*fcmp)(const void *, const void*));

        nResultado = (int *) lfind(&nProcurado, array, &nArrayTam,
                  sizeof(int), (int(*)(const void *,const void *))comparar);</b>

        nResultado........A função retorna zero quando o valor procurado não é
                          encontrado,e nonzero em caso de sucesso.

        &nProcurado.......O valor procurado deve ser passado por referência

        array.............Deve-se passar a Array aonde o valor vai ser pesquisado

        &nArrayTam........O número de elementos que contém a Array

        sizeof(int).......O tamanho do valor procurado

        camparar..........O nome da função que compara os valores com esta sintaxe:
                        (int(*)(const void *,const void *))comparar)
                        Esta função deve retornar 0 para igualidade e non-zero
                        para diferenças.

                        Exemplo de função comparadora:<font color="darkblue">
                        int comparar(int *x, int *y) {
                        return( *x - *y ); }</font>

        Veja o programa exemplo, ilustrando lfind():<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int comparar(int *x, int *y) {
        static nNdx=0;
        nNdx++;
        printf("\nFunção comparar...nNdx: %d\n",nNdx);
        printf("%d %d\n",*x,*y);
        return( *x - *y ); }

        int main(void) {
        int array[5] = {35, 87, 46, 99, 12};
        size_t nArrayTam = 5;
        int nProcurado;
        int *nResultado;

        clrscr();

        nProcurado = 99;
        nResultado = (int *) lfind(&nProcurado, array, &nArrayTam,
                  sizeof(int), (int(*)(const void *,const void *))comparar);
        if (nResultado)
        printf("Número %d encontrado!\n",nProcurado);

        else
        printf("Número %d não encontrado!\n",nProcurado);

        puts("End of Program\n");
        getch();
        return 0; }</font>

        Este programa produz esta saída:

        Função comparar...nNdx: 1
        99 35

        Função comparar...nNdx: 2
        99 87

        Função comparar...nNdx: 3
        99 46

        Função comparar...nNdx: 4
        99 99
        Número 99 encontrado!
        End of Program

.......................................................................................
<A NAME="3.21"><b>3.21 _lrotl</b></A>
        Esta função roda os bits de um inteiro longo para a esquerda.
        <b style="color:green">
        unsigned long _lrotl(unsigned long value, int count);
        nLongRotatedNumber = _lrotl(nLongNumber, nTimes);</b>

        nLongRotatedNumber.....Esta função retorna o valor com os bits deslocados
        nLongNumber............Valor que terá que seus bits deslocados.
        nTimes.................Quantidade de bits para deslocar

        Ex.:    unsigned long int nCorRgb = 0xFFF;
                nCorRgb = _lrotl(nCorRgb,2);

        Detalhes:
        Os bits do valor são empurrados para a esquerda enquanto que
        na direita do valor as posições binárias são preenchidas com
        bits zero. Rodar um número uma vez para a esquerda equivale
        a multiplicá-lo por dois, sendo este processo mais rápido
        que uma multiplicação por dois pelas vias normais.

        Veja o programa exemplo que está na função _rotl() sobre
        rotação de bits.

.......................................................................................
<A NAME="3.22"><b>3.22 _lrotr</b></A>
        Esta função roda os bits de um inteiro longo para a direita.
        <b style="color:green">
        unsigned long _lrotr(unsigned long value, int count);
        nLongRotatedNumber = _lrotr(nLongNumber, nTimes);</b>

        nLongRotatedNumber.....Esta função retorna o valor com os bits deslocados
        nLongNumber............Valor que terá que seus bits deslocados.
        nTimes.................Quantidade de bits para deslocar

        Ex.:    unsigned long int nCorRgb = 0xFFF;
                nCorRgb = _lrotl(nCorRgb,2);

        Detalhes:
        Os bits do valor são empurrados para a direita enquanto que
        na esquerda do valor as posições binárias são preenchidas com
        bits zero. Rodar um número uma vez para a direita equivale
        a dividí-lo por dois, sendo este processo mais rápido
        que uma divisão por dois pelas vias normais.

        Veja o programa exemplo que está na função _rotl() sobre
        rotação de bits.

.......................................................................................
<A NAME="3.23"><b>3.23 lsearch</b></A>
        Esta função pesquisa linearmente um valor numa array com o auxílio
        de uma função de comparação de dois valores definida pelo usuário.
        <b style="color:green">
        void *lsearch(const void *key, const void *base,size_t *pnelem, size_t width,
               int (*fcmp)(const void *, const void*));

        nResultado = (int *) lsearch(&nProcurado, array, &nArrayTam,
                  sizeof(int), (int(*)(const void *,const void *))comparar);</b>

        nResultado........A função retorna o valor procurado, mesmo porque se
                          ele não for encontrado ele é adicionado na array.

        &nProcurado.......O valor procurado deve ser passado por referência

        array.............Deve-se passar a Array aonde o valor vai ser pesquisado

        &nArrayTam........O número de elementos que contém a Array

        sizeof(int).......O tamanho do valor procurado

        camparar..........O nome da função que compara os valores com esta sintaxe:
                        (int(*)(const void *,const void *))comparar)
                        Esta função deve retornar 0 para igualidade e non-zero
                        para diferenças.

                        Exemplo de função comparadora:<font color="darkblue">
                        int comparar(int *x, int *y) {
                        return( *x - *y ); }</font>

        Detalhes:       Esta função é totalmente semelhante a lfind() em sintaxe
                        e finalidade, exceto pelo fato de que lsearch() faz um
                        append na array do valor procurado caso ele não seja
                        encontrado. A array tem o seu número de elementos acrescido
                        em 1.

        Veja o programa exemplo, ilustrando lsearch():<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int comparar(int *x, int *y) {
        static nNdx=0;
        nNdx++;
        printf("\nFunção comparar...nNdx: %d\n",nNdx);
        printf("%d %d\n",*x,*y);
        return( *x - *y ); }

        int main(void) {
        int array[5] = {35, 87, 46, 99, 12};
        size_t nArrayTam = 5;
        int nProcurado;
        int *nResultado;

        clrscr();

        nProcurado = 99;
        nResultado = (int *) lsearch(&nProcurado, array, &nArrayTam,
                  sizeof(int), (int(*)(const void *,const void *))comparar);
        if (nResultado)
        printf("Número %d encontrado!\n",nProcurado);

        else
        printf("Número %d não encontrado!\n",nProcurado);

        puts("End of Program\n");
        getch();
        return 0; }</font>

        Este programa produz esta saída:
        Função comparar...nNdx: 1
        99 35

        Função comparar...nNdx: 2
        99 87

        Função comparar...nNdx: 3
        99 46

        Função comparar...nNdx: 4
        99 99
        Número 99 encontrado!
        End of Program

.......................................................................................
<A NAME="3.24"><b>3.24 ltoa</b></A>
        Esta função converte um número longo inteiro para uma string,
        para qualquer base numérica, binária, octal, decimal ou hexadecimal.
        <b style="color:green">
        char *ltoa(long value, char *string, int radix);
        sString = ltoa(nLongNumber,sLongNumber, nBase);</b>

        sString.......Esta função retorna um ponteiro para a string sLongNumber.
        nLongNumber...O número longo que será convertido.
        sLongNumber...A string que recebe o número convertido.
        nBase.........A base numérica para a conversão.

        Ex.:    char *sString;
                char sLongNumber[40];
                long nLongNumber=65536;
                ltoa(nLongNumber,sLongNumber,16);

        Para obter um maior domínio desta função, consulte ultoa() que
        apresenta maiores detalhes.

.......................................................................................
<A NAME="3.25"><b>3.25 malloc</b></A>
        Esta função aloca memória principal do sistema.
        <b style="color:green">
        void *malloc(size_t size);
        Ptr = malloc(nBytes);</b>

        Ex.:    int *IntPtr;
                IntPtr = (int *) malloc(100 * sizeof(int));

        Aqui neste exemplo, declaramos um ponteiro para inteiros.
        Em seguida,alocamos 100 lugares para inteiros, supondo que o
        tipo inteiro tenha 2 bytes cada um, o total de memória alocada
        é de 200 bytes para guardar estes 100 números inteiros.

        Sizeof(TipoDeDado) é de extrema importância na alocação da
        quantidade certa de memória, pois ele obtém o número exato de
        bytes exigido para cada tipo de dado e até de estruturas.

        Precedendo malloc() nós colocamos um cast (int *) para garantir
        que o ponteiro retornado seja do tipo inteiro ou do tipo que
        necessitamos.

        Caso não haja a memória requisitada, o ponteiro retornado
        apresenta valor NULL.

        Vejas mais estes exemplos:<font color="darkblue">

        /* Alocando espaço para inteiros */
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int main( int nCmd, char **sCmd) {

        /* void *malloc(size_t size) */

        int *IntPtr;
        int nBytes=200;

        clrscr();

        IntPtr = (int *) malloc (nBytes * sizeof(int));

        if (IntPtr==NULL) printf("Não conseguimos alocar a memória requisitada.");
        else printf("%d bytes foram alocados com sucesso.",nBytes*sizeof(int));

        getch();

        puts("End of Program."); }</font>

        Exemplo 02, alocando espaço para floats: <font color="darkblue">
        /* Alocando memória para números flutuantes */
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int main( int nCmd, char **sCmd) {

        /* void *malloc(size_t size) */

        float *FloatPtr;
        int nNumber=200;

        clrscr();

        FloatPtr = (float *) malloc (nNumber * sizeof(float));

        if (FloatPtr==NULL) printf("Não conseguimos alocar a memória requisitada.");
        else printf("%d bytes foram alocados com sucesso.",nNumber*sizeof(float));

        getch();

        puts("End of Program."); }</font>

        Exemplo 03, alocando espaço para estruturas:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        typedef struct {
        int x;
        int y;
        int z;
        } ponto3d;

        int main( int nCmd, char **sCmd) {

        /* void *malloc(size_t size) */

        ponto3d *Stru3dPtr;
        int nNumber,nBytes;

        nNumber = 100;

        clrscr();

        nBytes = nNumber * sizeof(ponto3d);

        Stru3dPtr = (ponto3d *) malloc (nBytes);

        if (Stru3dPtr==NULL) printf("Falha na alocação de memória.");
        else printf("%d bytes alocados com sucesso\n",nBytes);

        printf("Tamanho  da estrutura ponto3d: %d \n",sizeof(ponto3d));

        puts("End of Program.");
        getch(); }</font>

.......................................................................................
<A NAME="3.26"><b>3.26 max</b></A>
        Esta macro em forma de função retorna o valor máximo de dois números
        inteiros fornecidos.
        <b style="color:green">
        max(a,b)
        nMaior =(nNumberx, nNumbery);</b>

        Ex.:    int x=10,y=25;
                z = max(x,y);
                printf("%d",z);         /* Resulta em 25 */

        Detalhes: Você só pode usar inteiros e inteiros longos nesta função.

.......................................................................................
<A NAME="3.27"><b>3.27 min</b></A>
        Esta macro em forma de função retorna o valor mínimo de dois
        números inteiros fornecidos.
        <b style="color:green">
        min(a,b);
        nMenor = min(nNumberx,nNumbery);</b>

        Ex.:    int x=10,y=25;
                z = min(x,y);
                printf("%d",z);         /* Resulta em 10 */

        Detalhes: Você só pode usar inteiros e inteiros longos nesta função.

.......................................................................................
<A NAME="3.28"><b>3.28 putenv</b></A>
        Esta função configura uma nova ou reconfigura uma variável de
        ambiente.
        <b style="color:green">
        int putenv( const char *name);
        nSts = putenv(sAmbVar);</b>

        Ex.:    char sAmbVar[]="LIB=C:\\CLIP53\\LIB;"
                putenv(sAmbVar);

        Detalhes:
        Em caso de sucesso valor de retorno é zero, caso contrário -1.
        Em nossos testes, a variável de ambiente colocada no sistema
        com putenv() existiu apenas enquanto nosso programa estava
        em execução.

.......................................................................................
<A NAME="3.29"><b>3.29 qsort</b></A>
        Esta função organiza uma tabela de valores em ordem crescente
        com o auxílio de uma função comparadora definida pelo usuário.
        <b style="color:green">
        void qsort(void *base, size_t nelem, size_t width,
        int(*fcmp) (const void *, const void *));

        qsort(nMyArray, nArrayTam, nElementoTam,
        (int  (*) (const void *, const void*)) UserDefinedFunction);</b>

        nMyArray.......A tabela de valores que será organizada
        nArrayTam......O número de elementos da tabela
        nElementoTam...O tamanho geral do elemento obtido com sizeof()
        UserDefinedFunction....A função comparadora passada com esta sintaxe:
        (int  (*) (const void *, const void*)) UserDefinedFunction)

        Veja programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int comparar (int *x, int *y) {
        return(*x-*y); }

        int main (int nCmd, char **sCmd) {

        int nMyArray[] = {'j','a','i','r','x'};
        size_t nArrayTam = 5;
        int cx;

        clrscr();

        qsort(nMyArray, nArrayTam, sizeof(int),
        (int (*)(const void *, const void *))comparar);

        for (cx=0;cx<5;cx++) printf("%c %d\n",nMyArray[cx],nMyArray[cx]);

        puts("\End of Program");
        getch(); }</font>

        Este programa apresenta esta saída:
        a 97
        i 105
        j 106
        r 114
        x 120
        End of Program

.......................................................................................
<A NAME="3.30"><b>3.30 rand</b></A>
        Esta função retorna um número aleatório entre 0 e 32767.
        <b style="color:green">
        int rand(void);
        nNumberx = rand();</b>

        Ex.:    int nSorteio;
                nSorteio = rand();

        Detalhes:
        Não é necessário usar a função randomize() em conjunto com
        esta função.

.......................................................................................
<A NAME="3.31"><b>3.31 random</b></A>
        Esta função retorna um número aleatório entre 0 e o valor fornecido.
        <b style="color:green">
        int random(int num);
        nNumberx = (nMaxNumber);</b>

        Ex:     int nNumberx,nMaxNumber = 25000;
                nNumberx=random(nMaxNumber);
                printf("%d",nNumberx);

        Para gerar números aleatórios diferentes em cada execução
        do programa coloque randomize() em seu programa ou srand()

.......................................................................................
<A NAME="3.32"><b>3.32 randomize</b></A>
        Esta função ativa o gerador de números aleatórios. Para usá-la
        você deve incluir o arquivo time.h pois esta função depende
        do relógio interno.
        <b style="color:green">
        void randomize(void);
        randomize();</b>

        Ex.:    randomize();

        Geralmente, você usará randomize() em conjunto com random()
        para gerar números aleatórios diferentes em cada execução
        do programa.

.......................................................................................
<A NAME="3.33"><b>3.33 realloc</b></A>
        Esta função realoca memória para um bloco que foi pré-alocado com malloc()
        ou calloc(). O bloco pode ter seu tamanho reduzido ou aumentado
        conforme a requisição do novo pedido de memória for maior ou menor
        que o tamanho do bloco atual.
        <b style="color:green">
        void *realloc (void *block, size_t size);
        MemPtr = (DataType *) realloc(MemPtr, nBytes);</b>

        MemPtr....Bloco alocado anteriormente com calloc() ou malloc()
        nBytes....Nova requisição de tamanho do bloco

        Ex.:    char *sNomes;
                int nNome = 10;
                int nBytes = sizeof(char) * 20;
                sNome = (char *) calloc (nNome,nBytes);
                sNome = (char *) realloc (sNome,5000);

        Em caso de falha, o valor de retorno é NULL.
        O tamanho máximo do bloco que pode ser alocado com
        malloc(), calloc() e realloc() é de 64K.

        Veja mais este programa:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"

        int main(void) {
        char *str = NULL;

        clrscr();

        str = (char *) calloc(10, sizeof(char));

        if (str==NULL) {
        printf("Memória insuficiente\n");
        abort();}

        strcpy(str, "Reservado");

        printf("%s \t %p \n", str,str);

        str = (char *) realloc (str,2000);
        if (str==NULL) {
        printf("Memória insuficiente\n");
        getch();
        abort();}

        printf("%s \t %p \n", str,str);

        free(str);
        getch();
        return 0; }</font>

.......................................................................................
<A NAME="3.34"><b>3.34 _rotl</b></A>
        Esta função roda os bits de um número inteiro para a esquerda.
        <b style="color:green">
        unsigned int _rotl(unsigned value, int count);
        nRotatedNumber = _rotl(nNumber,nTimes);</b>

        nRotatedNumber...Esta função retorna o número com os bits deslocados.
        nNumber..........O valor que terá seus bits deslocados para a esquerda.
        nTimes...........O número de bits que será deslocado.

        Ex.:    unsigned int nNumber =10;
                nNumber = _rotl(nNumber,1);

        Detalhes:
        Na rotação de um bit para a esquerda, todos os bits do número
        são empurrados para a esquerda e a extrema direita é preenchida
        com zeros. Rodar um bit uma vez para a esquerda equivale a
        multiplicar o número por dois. A rotação é mais rápida do que
        o processo de multiplicar o número por dois pelas vias normais.

        Veja o programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        /* Esta função converte um inteiro para uma string binária */
        char *sBin(int x);
        char *sBin(int x) {
        int cx;
        char *sBuffer="????????\0";
        int nResto;

        for (cx=7;cx>=0;cx--) {
        nResto = (x%2);
        x /= 2;
        sBuffer[cx]=nResto+'0'; }

        return(sBuffer); }

        int main( int nCmd, char **sCmd) {

        unsigned int nNumber;
        char *sBinNumber;

        clrscr();

        nNumber=10;
        printf("nNumber before left rotation: %d %s\n",nNumber,sBin(nNumber));
        nNumber = _rotl(nNumber,1);
        printf("nNumber after left rotation: %d %s\n",nNumber,sBin(nNumber));

        printf("\nnNumber before right rotation: %d %s\n",nNumber,sBin(nNumber));
        nNumber = _rotr(nNumber,1);
        printf("nNumber after right rotation: %d %s\n",nNumber,sBin(nNumber));

        puts("\nEnd of Program\n");
        getch(); }</font>

        Este programa produz esta saída:
        nNumber before left rotation: 10 00001010
        nNumber after left rotation:  20 00010100

        nNumber before right rotation: 20 00010100
        nNumber after right rotation:  10 00001010

.......................................................................................
<A NAME="3.35"><b>3.35 _rotr</b></A>
        Esta função roda os bits de um número inteiro para a direita.
        <b style="color:green">
        unsigned int _rotr(unsigned value, int count);
        nRotatedNumber = _rotr(nNumber, nTimes);</b>

        Ex.:    unsigned int nNumber=20;
                nNumber = _rotr(nNumber,1);

        nRotatedNumber...Esta função retorna o número com os bits deslocados.
        nNumber..........O valor que terá seus bits deslocados para a direita.
        nTimes...........O número de bits que será deslocado.


        Detalhes:
        Na rotação para a direita, todos os bits são empurrados para
        a direita enquanto o lado esquerdo vai sendo preenchido com zeros.
        Rodar um bit para a direita de um número equivale a dividí-lo por
        dois, sendo esta divisão mais rápida que a divisão pelas vias
        normais.

        Veja na função _rotl() o programa que exemplifica melhor a rotação de bits.

.......................................................................................
<A NAME="3.36"><b>3.36 srand</b></A>
        Esta função inicializa o gerador de números aleatórios.
        <b style="color:green">
        void srand(unsigned seed);
        srand(nSeed);</b>

        Ex.:    int nSorteio;
                srand(48);
                nSorteio=random(100);


        Detalhes:
        Geralmente, em conjunto com esta função você vai usar random()
        que retorna o número aleatório. Para cada valor que você colocar
        em nSeed você vai obter uma sequência diferente de números aleatórios
        que vão se repetir para cada valor de nSeed.

.......................................................................................
<A NAME="3.37"><b>3.37 strtod</b></A>
        Esta função converte uma string para um número flutuante double.
        <b style="color:green">
        double strtod(const char *s, char **endptr);
        nDoubleNumber = strtod(sDoubleNumber, &EndPtr);</b>

        Ex.:    char *EndPtr;
                double nDoubleNumber;
                char sDoubleNumber[] = "6.283032";
                nDoubleNumber = strtod(sDoubleNumber,&EndPtr);
                printf("Escaneamento da string parou em %s",EndPtr);

        Detalhes:
        Esta função não funcionou em TurboC, seu uso ocasiona a seguinte
        mensagem deveras equivocada: 'floating point formats not linked'
        Porém, o mesmo teste funcionou em Turbo C++ também da Borland.

        O argumento endptr representa o ponteiro aonde o escaneamento
        da string foi interrompido por um carácter não-reconhecido.
        Este argumento é útil para detecção de erros.

        Veja o programa exemplo que rodou no Turbo C++ Borland:<font color="darkblue">
        #include <stdio.h>
        #include "conio.h"
        #include <stdlib.h>

        int main(void) {
        char *endptr;
        char sNumber[]="6.28";
        double nDoubleNumber;

        clrscr();
        nDoubleNumber = strtod(sNumber, &endptr);
        printf("sNumber: %s \tnDoubleNumber: %lf\n", sNumber, nDoubleNumber);
        printf("%s",endptr);

        getch();
        return 0; }</font>

.......................................................................................
<A NAME="3.38"><b>3.38 strtol</b></A>
        Esta função função converte uma string para um número inteiro longo,
        esta string pode trazer um número na base binária, decimal, octal
        ou hexadecimal.
        <b style="color:green">
        long strtol(const char *s, char **endptr, int radix);
        nLongNumber = strtol(sLongNumber, &EndPtr, nBase);</b>

        nLongNumber...A função retorna um inteiro longo originado por sLongNumber
        sLongNumber...A string que traz um número para ser convertido.
        nBase.........A base numérica, podendo ser 2,8,10 ou 16.
        EndPtr........Em caso de erro ocasionado por um carácter impróprio, este
                      argumento aponta para este carácter.

        Ex.:    char *EndPtr;
                int nBase=10;
                char sLongNumber="1048850";
                long nLongNumber;
                nLongNumber = strtol(sLongNumber,&EndPtr, nBase);

        Detalhes:
        É muito útil esta função porque ela converte de uma base
        para outra, podendo sLongNumber trazer um número em formato
        hexadecimal, decimal, octal ou binário.

        Veja mais este programa ilustrando esta função: <font color="darkblue">
        #include "stdlib.h"
        #include "stdio.h"
        #include "conio.h"

        /* long strtol(const char *s, char **endptr, int radix); */
        int main(void) {
        char *sNumber = "0xFFFFF", *EndPtr;
        long nLongNumber;

        /* strtol converte uma string para um inteiro longo */

        clrscr();

        nLongNumber = strtol(sNumber, &EndPtr, 16);
        printf("sNumber = %s  nLongNumber = %ld\n", sNumber, nLongNumber);

        getch();
        return 0; }</font>

.......................................................................................
<A NAME="3.39"><b>3.39 strtoul</b></A>
        Esta função converte uma string, que pode trazer um número em qualquer
        base numérica, para um número inteiro longo não-sinalizado.
        <b style="color:green">
        unsigned long = strtoul(const char *s, char **endptr, int radix);
        nLongNumber = strtoul(sLongNumber,&EndPtr, nBase);</b>

        nLongNumber...A função retorna um longo nao sinalizado originado de sLongNumber
        sLongNumber...A string que traz um número para ser convertido.
        nBase.........A base numérica, podendo ser 2,8,10 ou 16.
        EndPtr........Em caso de erro ocasionado por um carácter impróprio, este
                      argumento aponta para este carácter.

        Ex.:    char *EndPtr;
                char sBigNumber="268435455";
                unsigned long nNumber;
                nNumber = strtoul(sBigNumber, &EndPtr, 10);
                printf("%lu",nNumber);

        Veja mais este programa exemplo ilustrando strtoul():<font color="darkblue">
        #include "stdlib.h"
        #include "stdio.h"
        #include "conio.h"

        /* long strtoul(const char *s, char **endptr, int radix); */
        int main(void) {

        char *sNumber = "0xFFFFFFF", *EndPtr;

        unsigned long nLongNumber;

        /* strtol converte uma string para um inteiro longo */

        clrscr();

        nLongNumber = strtoul(sNumber, &EndPtr, 16);
        printf("sNumber = %s  nLongNumber = %lu\n", sNumber, nLongNumber);

        getch();
        return 0; }</font>

.......................................................................................
<A NAME="3.40"><b>3.40 swab</b></A>
        Esta função copia o número especificado de bytes de uma string fonte para uma
        string de destino, permutando bytes pares pelos bytes impares.
        <b style="color:green">
        void swab(const char *from, const char *to, int nbytes);
        swab(sFonte,sDestino,nBytes);</b>

        Ex.:    char sFonte[]="Rigor";
                char sDestino[]="????";
                swab(sFonte,sDestino,4);
                printf("%ssDestino:",sDestino); /* Resulta em sDestino: iRog */

.......................................................................................
<A NAME="3.41"><b>3.41 system</b></A>
        Esta função executa um comando ou programa do Ms_Dos e também
        arquivos de lote (bat).
        <b style="color:green">
        int system(const char *command);
        nSts = system(sCmdLine);</b>

        nSts....Esta função retorna zero no sucesso, e nonzero para falhas.

        Ex.:    char sCmdLine[]="dir /w";
                system(sCmdLine);

.......................................................................................
<A NAME="3.42"><b>3.42 ultoa</b></A>
        Esta função converte um número inteiro longo não sinalizado
        para uma string. A conversão pode ser feita para qualquer
        base numérica.
        <b style="color:green">
        char *ultoa (unsigned long value, const char *s, int radix);
        sString = ultoa (nLongNumber,sNumber, nBase);</b>

        sString.......A função retorna nLongNumber convertido numa string.
        nLongNumber...Número inteiro longo que será convertido.
        sNumber.......Variável string que recebe o número convertido.
        nBase.........Base numérica para a conversão, pode ser 2,8,10 ou 16.

        Ex.:    char *sString;
                char sNumber;
                unsigned long int nLongNumber = 0xFFFFFFFF;
                ultoa(nLongNumber,sNumber,10);

        Detalhes:
        Esta é uma função muito interessante, porque vc pode
        converter rapidamente números de uma base para outra
        e ter esta string para outros processos.

        Veja mais este programa exemplificando ultoa(): <font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int main (int nCmd, char **sCmd) {
        char sNumber[40];
        unsigned long int nLongNumber = 0xFFFFFFFF;
        char *sString;

        clrscr();
        sString= ultoa (nLongNumber,sNumber, 2);

        printf("nLongNumber: %lu \nsNumber: %s \n",nLongNumber,sNumber);
        printf("String retornada: %s\n",sString);

        puts("End of Program");
        getch(); }</font>

        Este programa apresenta a seguinte saída:
        nLongNumber:4294967295
        sNumber:11111111111111111111111111111111
        String retornada:11111111111111111111111111111111
        End of Program


<table align=bottom border=0 cellspacing=0 cellpadding=0 width=20%><tr><td><a href=cbiblioteca.html style='color:blue'> index </a></td><td><a href='track02.html'style='color:blue'>&lt;&lt;</a></td><td><a href='track04.html'style='color:blue'>&gt;&gt;</a></td></tr></table><hr><div style='background-color:lightyellow;color:blue'>
<center>Produzido por Gameprog: Jair Pereira - Fev/2006 - Junho/2013 ©
gameprog.br@gmail.com
<a href='http://www.gameprog.com.br'>http://www.gameprog.com.br</a></center><hr></div></body></html>
