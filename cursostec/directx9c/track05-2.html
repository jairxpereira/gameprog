<html>
<head>
<title>dx9cpp_fase05-2</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}


.sc1 {
	color: darkgreen;
	font-weight: bold;
}

.sntx {
	color: darkgreen;
	}


.sc2 {
	color: #008000;
}
.sc4 {
	color: #ff8000; font-weight: bold;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #FF0000;
}
.sc9 {
	color: #804000;
	font-weight: bold;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #400080;
}

.prg {
	color: #0000FF;
}

.prg-saida {

	margin-left:0px;
	width:500pt;
	background-color:lightblue;	
}

.prg-code {
	margin-left:0px;
	width:515pt;
	background-color:lightyellow;
	padding:10px;
	font-weight:bold;
}


.niceview {
	margin-left:0px;
	width:500pt;
	background-color:white;
	border-color:lightgray;
	border-width:1px;
	border-style:solid;
	padding:10px;
}

td
{
padding:3px;
}

table.dados
{
margin-left:0px;
width:53.5em;
border-collapse:collapse;
border:1px solid red;
text-align:center;
}

th
{
background-color:darkgreen;
color:yellow;
font-weight:bold;
text-transform:uppercase;
}

.pagebody
{
padding:10px;
margin-left:50px;
border-width:1px;
border-style:solid;
border-color:white;
background-color:white;
width:90%;
}
.mybody
{
margin-top:20pt;
margin-bottom:20pt;
margin-left:20pt;
margin-right:20pt;
border-color:lightgray;
background-image:url('background.png');
}
</style>
</head>
<body class=mybody><font color='black'>
<div class=pagebody>
<hr>
<center><b style='font-size:1.5em;' >Curso completo de DirectX 9 com C\C++</b><br>
Gameprog - Escola de programação de jogos digitais<br>
Contato: gameprog.br@gmail.com<br>
<b>Fase 05-2</b></center>
<hr>
<table align='left' border='0' cellspacing='0' cellpadding='0' width='20%'>
<tr><td><a href='dx9cpp.html#start' style='color:blue'> index </a></td>
<td><a href='track05-1.html' style='color:blue'>&lt;&lt;</a></td>
<td><a href='track05-3.html' style='color:blue'>&gt;&gt;</a></td></tr></table><br><pre>
<hr><a name='topo'></a>
<h3 style='background-color:#80ff80'>05.2 Teclado e mouse via api Win 32</h3><pre>
<b><u>1.1 Visão geral</b></u>
<div class=prg-code><img src=images\prj_apiWin32.png></div>
A  aplicação  deste  tópico mostra um exemplo de como manipular mouse
e  teclado  utilizando  a  biblioteca  nativa  do  Windows geralmente
conhecida como 'api Win 32'.
O suporte ao mouse e teclado  dado por essa api é muito mais fácil de
usar  do  quê  o suporte dado pelo <span class=sc16>DirectInput</span> que tem o custo de uma
complexidade muito grande adicionada ao código da aplicação.

Com   relação   ao   teclado   vamos   usar   extensamente  a  função
<span class=prg>GetAsyncKeyState( nTecla )</span>  que retorna o status de pressionamento da
tecla indicada.  A indicação das teclas é feita utilizando os códigos
de  mapeamento  virtual  do Windows tipo <span class=sc4>VK_LEFT</span> ou <span class=sc4>VK_RIGHT</span> entre os
outros <b class=sc4>255</b> valores possíveis.

Com  relação  ao  mouse  vamos utilizar o fluxo normal dos eventos de
mouse recebidos pela janela para tratamento  e vamos utilizar algumas
funções  que  fazem  a leitura e reposicionamento do ponteiro sobre a 
a tela.  No tocante ao posicionamento do mouse há um pequeno conflito
da aplicação que se expressa em coordenadas de janela e as funções de
mouse  que  se  expressam  em  coordenadas  de  tela. Esse conflito é
resolvido  com  funções  que  perfazem a conversão entre um sistema e
outro de coordenada.

<u>Interface de operação da aplicação de exemplo</u>
- A movimentação do mouse e as setas do teclado movem o jogador;

- Os  botões esquerdo \ direito  testam leitura e reposicionamento do
mouse;

- A tecla 'E' e 'M' esconde e mostra respectivamente o ponteiro.

- A tecla 'R' testa leitura e reposicionamento do mouse.


<b><u>1.2 Estrutura principal da aplicação</b></u>
<div class=prg-code><b class=sc2>Arquivo: motor.cpp</b>
<div class=niceview style="border-style:dashed;">
initGfx()
	Inicializa o motor gráfico	
	Inicializa objeto para mostrar texto via inicializarTexto()
	<b class=sc16>Configura forma e posição inicial do jogador</b>
	
<b class=sc16>tratarTeclado()</b>
	Verifica pressionamento das setas
	Atualiza os respectivos flags de movimento
	Atualiza coordenada (xcol, ylin) conforme flags de movimento
	Atualização posição do ponteiro do mouse
	
<b class=sc16>setJogadorPos()</b>
	Converte coordenadas de aplicação para coordenadas de <u>tela</u>
	Configura posição do ponteiro do mouse
	
	Faz leitura da posição do ponteiro do mouse
	Converte coordenadas de <u>tela</u> para coordenadas de aplicação	
	Configura posição do jogador	
	
<b class=sc16>tratarMouse()</b>
	Reconfigura posição do jogador no pressionamento dos botões
	Atualiza coordenada (xcol, ylin) na movimentação do mouse

Renderizar()
	<b class=sc16>Verifica teclado via tratarTeclado()
	
	mostra jogador com  mostrarTexto(xcol, ylin, sjogador)</b>

<b>processaJanela()</b>
	 
	<b class=sc16>chama tratarMouse() para tratamento de eventos de mouse</b>
</div></div>

<b><u>2.1 Aspectos globais - Arquivo motor.h </u></b>
<div class=niceview>//-----------------------------------------------------------------------------</span>
<span class=sc2>// Projeto: prj_apiWin32 - Arquivo: motor.h</span>
<span class=sc2>// Esta aplicação mostra como manipular mouse e teclado</span>
<span class=sc2>// utilizando a api nativa do Windows.</span>
<span class=sc2>// Produzido por www.gameprog.com.br</span>
//-----------------------------------------------------------------------------</span>
<span class=sc16>#ifndef </span>motor_h 
  <span class=sc16>#define </span>motor_h 

  <span class=sc2>// Esta função inicializa o Direct3D</span>
  <span class=sc16>HRESULT </span>initGfx (<span class=sc16>HWND </span>hJanela);  

  <span class=sc2>// Essa função libera os objetos utilizados</span>
  <span class=prg>void </span>Limpar();  

  <span class=sc2>// Essa função desenha a cena</span>
  <span class=prg>void </span>Renderizar();  

  <span class=sc2>// Esta função inicializa o objeto para mostrar texto</span>
  <span class=prg>void </span>inicializarTexto();  

  <span class=sc2>// Verifica e processa o pressionamento das teclas</span>
  <span class=prg>void </span>tratarTeclado(<span class=prg>void</span>);   

  <span class=sc2>// verifica e processa o pressionamento do mouse</span>
  <span class=prg>void </span>tratarMouse (<span class=prg>UINT </span>mensagem, <span class=sc16>WPARAM </span>wParam, <span class=sc16>LPARAM </span>lParam);  

  <span class=sc2>// Essa função configura a posição do jogador</span>
  <span class=prg>void </span>setJogadorPos( <span class=prg>int </span>xpos, <span class=prg>int </span>ypos);  

  <span class=sc2>// Esta função mostra um texto na coordenada (x, y) da janela</span>
  <span class=prg>void </span>mostrarTexto( <span class=prg>int </span>x, <span class=prg>int </span>y, <span class=prg>char* </span>texto);  

  <span class=sc2>// Declaração da função que atende as mensagens da janela</span>
  <span class=sc16>LRESULT </span><span class=sc16>CALLBACK </span>processaJanela (<span class=sc16>HWND </span>hJanela, <span class=prg>UINT </span>mensagem, 
      <span class=sc16>WPARAM </span>wParam, <span class=sc16>LPARAM </span>lParam);  
<span class=sc16>#endif</span>

</div>
<b><span class=prg>void </span>tratarTeclado(<span class=prg>void</span>); </b>
Essa função mostra como verificar e tratar o pressionamento das teclas
que são interessantes para a aplicação.  Em nosso caso,  vamos tratar
principalmente  as  setas  dos  teclados utilizadas para movimentar o 
nosso jogador simbólico.

<b><span class=prg>void </span>Renderizar();   </b>
Antes  da  renderização  da  cena, a aplicação vai verificar de forma
antecipada  o  teclado  com  a  função <b>tratarTeclado()</b> e isso traz um
melhor desempenho geral para a aplicação.

<b><span class=prg>void </span>tratarMouse (<span class=prg>UINT </span>mensagem, <span class=sc16>WPARAM </span>wParam, <span class=sc16>LPARAM </span>lParam);  </b>
Essa função vai tratar o fluxo normal dos eventos de mouse.

<b><span class=prg>void </span>setJogadorPos( <span class=prg>int </span>xpos, <span class=prg>int </span>ypos);  </b>
Essa  função  recoloca  o nosso jogador simbólico em uma nova posição
dentro da janela. Nesse contexto vamos conhecer as funções  de  mouse
<span class=prg>GetCursorPos()</span> e <span class=prg>SetCursorPos()</span> que fazem leitura e reconfiguração da
posição do mouse na janela.

<b><span class=sc16>LRESULT </span><span class=sc16>CALLBACK </span>processaJanela ( <b class=sc2>// (...)</b> ); </b>
Essa função será utilizada para recepcionar alguns eventos de mouse e
desviá-los para a função <b>tratarMouse()</b> aonde serão tratados. 

<b><u>2.2 Aspectos globais - Arquivo: motor.cpp </u></b>
<div class=niceview><span class=sc2>// Representação símbólica do jogador</span>
<span class=prg>char* </span>smove_esquerda = <span class=sc6>"&lt;</span>(<span class=sc6>-:"</span>; 
<span class=prg>char* </span>smove_direita = <span class=sc6>":-</span>)<span class=sc6>&gt;"</span>; 
<span class=prg>char* </span>sjogador; 

<span class=sc2>// Controle de movimentação</span>
<span class=prg>int </span>xcol = 320; 
<span class=prg>int </span>ylin = 240; 
<span class=prg>int </span>nVelocidade = <span class=sc4>2</span>; 
</div>
<b><span class=prg>char* </span>smove_esquerda = <span class=sc6>"&lt;</span>(<span class=sc6>-:"</span>; 
<span class=prg>char* </span>smove_direita = <span class=sc6>":-</span>)<span class=sc6>&gt;"</span>; 
<span class=prg>char* </span>sjogador;  </b>
O nosso jogador simbólico é representado por estas variáveis.

<b><span class=prg>int </span>xcol = 320; 
<span class=prg>int </span>ylin = 240; 
<span class=prg>int </span>nVelocidade = <span class=sc4>2</span>; </b>
Estas variáveis são para o processamento da movimentação  do  jogador
na tela que é disparado pelo mouse ou as setas do teclado.


<b><u>2.3 Inicialização do motor gráfico </u></b>
<div class=niceview><span class=sc2>// initGfx() - Inicializa o Direct3D</span>
<span class=sc16>HRESULT </span>initGfx( <span class=sc16>HWND </span>hJanela ) 
<span class=sc16>{</span>
  <span class=sc2>// Cria o objeto D3D que é necessário para criar o dispositivo gráfico</span>
  g_Direct3d = <span class=prg>Direct3DCreate9</span>( <span class=sc4>D3D_SDK_VERSION</span>);  

  <span class=sc2>// Verifica se objeto Direct3D foi criado</span>
  <span class=sc9>if</span>(g_Direct3d == <span class=prg>NULL</span>)  
  <span class=sc16>{</span>
    <span class=prg>MessageBox </span>(<span class=prg>NULL</span>, 
      <span class=sc6>"Falha na inialização do Direct3D"</span>, <span class=sc6>"InitGfx</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
    <span class=sc6>return </span><span class=sc4>E_FAIL</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>


  <span class=sc2>// Declara  a variável para os parâmetros de apresentação</span>
  <span class=sc5>D3DPRESENT_PARAMETERS </span>pps; 

  <span class=sc2>// Limpa a estrutura</span>
  <span class=prg>ZeroMemory</span>( &pps, <span class=sc16>sizeof</span>(pps) );  

  <span class=sc2>// Configura os parâmetros de apresentação</span>
  <span class=sc2>// A aplicação vai ter janela</span>
  <span class=prg>pps.Windowed </span>= <span class=prg>TRUE</span>; 

  <span class=sc2>// Esse método vira rapidamente o backbuffer para a tela imediata</span>
  <span class=prg>pps.SwapEffect </span>= <span class=sc4>D3DSWAPEFFECT_DISCARD</span>; 

  <span class=sc2>// Esse formato vai procurar se encaixar no modo de video corrente</span>
  <span class=prg>pps.BackBufferFormat </span>= <span class=sc4>D3DFMT_UNKNOWN</span>; 

  <span class=sc2>// Configuração do renderizador a ser criado</span>
  <span class=sc2>// Adaptador default (0)</span>
  <span class=prg>int </span>nAdaptador = <span class=sc4>D3DADAPTER_DEFAULT</span>; 

  <span class=sc2>// Tipo de dispositivo Hardware ou emulador de referência (software)</span>
  <span class=prg>D3DDEVTYPE </span>dispositivo_tipo = <span class=sc4>D3DDEVTYPE_HAL</span>; 

  <span class=sc2>// Flags de configuração do dispositivo</span>
  <span class=prg>DWORD </span>create_flags = <span class=sc4>D3DCREATE_SOFTWARE_VERTEXPROCESSING</span>; 

  <span class=sc2>// Criamos aqui o dispositivo renderizador</span>
  g_hr = <span class=prg>g_Direct3d-&gt;CreateDevice</span>( nAdaptador, dispositivo_tipo, 
    hJanela, create_flags, &pps, &g_device );  

  <span class=sc2>// Verifica se houve falha no processo</span>
  <span class=sc9>if</span>( <span class=prg>FAILED</span>( g_hr ) ) <span class=sc16>{</span>
    <span class=prg>MessageBox </span>(<span class=prg>NULL</span>, <span class=sc6>"Falha na criação: g_device"</span>, <span class=sc6>"initGfx</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
    <span class=sc6>return </span><span class=sc4>E_FAIL</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=sc2>// Faz inicialização da interface de texto</span>
  inicializarTexto();  <b>

  <span class=sc2>// Define forma do jogador</span>
  sjogador = smove_esquerda; 

  <span class=sc2>// Configura a posição inicial do jogador</span>
  setJogadorPos(320, 240);  </b>

  <span class=sc6>return </span><span class=sc4>S_OK</span>; 
<span class=sc16>} <span class=sc2>// initGfx().fim</span></span>
</div>
<b>sjogador = smove_esquerda; 
setJogadorPos(320, 240);  </b>
Aqui simplesmente definimos a forma e posição inicial do jogador.

<b><u>2.4 Renderização da cena </u></b>
O  destaque  da  função  <b>Renderizar()</b>  é  o acionamento antecipado da
leitura e processamento do teclado via <b>tratarTeclado()</b>.

<div class=niceview><span class=sc2>// -----------------------------------------------------------------------------</span>
<span class=sc2>// Renderizar() - Desenha a cena</span>
<span class=sc2>// -----------------------------------------------------------------------------</span>
<span class=prg>VOID </span>Renderizar() 
<span class=sc16>{</span>
  <b><span class=sc2>// verificar teclado</span>
  tratarTeclado()</b>;  

  <span class=sc2>// Retorne se o dispositivo estiver nulo</span>
  <span class=sc9>if</span>( g_device == <span class=prg>NULL</span>)  <span class=sc6>return</span>; 

  <span class=sc2>// Cor de fundo da janela</span>
  <span class=sc16>const </span><span class=sc5>D3DCOLOR </span>branco = <span class=prg>D3DCOLOR_XRGB</span>( 255, 255, 255 );  

  <span class=sc2>// Limpa o backbuffer com uma cor branca</span>
  <span class=prg>g_device-&gt;Clear</span>( <span class=sc4>0</span>, <span class=prg>NULL</span>, <span class=sc4>D3DCLEAR_TARGET</span>, branco, <span class=sc4>1.0f</span>, <span class=sc4>0</span>);   

  <span class=sc2>// Começa a cena</span>
  <span class=sc9>if</span>( <span class=prg>SUCCEEDED</span>( <span class=prg>g_device-&gt;BeginScene</span>() ) ) 
  <span class=sc16>{</span> <b>
    <span class=sc2>// Desenha o jogador na posição dada por (xcol, ylin)</span>
    mostrarTexto (xcol, ylin, sjogador);  

    <span class=sc2>// Desenha mensagens</span>
    mostrarTexto (10, 10, <span class=sc6>"Setas\\Mouse: movimentação"</span>);   
    mostrarTexto (10, 50, <span class=sc6>"R ou Botão direito: Resseta posição"</span>);   
	</b>
    <span class=sc2>// Finalizando a cena</span>
    <span class=prg>g_device-&gt;EndScene</span>();  
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=prg>g_device-&gt;Present</span>( <span class=prg>NULL</span>, <span class=prg>NULL</span>, <span class=prg>NULL</span>, <span class=prg>NULL</span>);  
<span class=sc16>} <span class=sc2>// Renderizar().fim</span></span>
</div>

<b><u>2.5 Tratamento do teclado </u></b>
<div class=niceview><span class=prg>void </span>tratarTeclado(<span class=prg>void</span>)  
<span class=sc16>{</span>
  <span class=sc2>// Declara uma variável para verificar movimento</span>
  static <span class=prg>int </span>movOcorrido = <span class=sc4>0</span>; 

  <span class=sc2>// Configura como zero (0)</span>
  movOcorrido = <span class=sc4>0</span>; 

  <span class=sc2>// Declara variáveis de estados das setas</span>
  <span class=prg>int </span>seta_direita, seta_esquerda, seta_cima, seta_baixo; 
  seta_direita  = <span class=sc4>0</span>; 
  seta_esquerda = <span class=sc4>0</span>; 
  seta_cima     = <span class=sc4>0</span>; 
  seta_baixo    = <span class=sc4>0</span>; 

  <span class=sc2>// Verifica as setas pressionadas</span>
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>(<span class=sc4>VK_LEFT</span> )  & <span class=sc4>0x8000f</span> ) seta_esquerda = <span class=sc4>1</span>; 
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>(<span class=sc4>VK_RIGHT</span>)  & <span class=sc4>0x8000f</span> ) seta_direita  = <span class=sc4>1</span>; 
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>(<span class=sc4>VK_UP</span>   )  & <span class=sc4>0x8000f</span> ) seta_cima     = <span class=sc4>1</span>; 
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>(<span class=sc4>VK_DOWN</span> )  & <span class=sc4>0x8000f</span> ) seta_baixo    = <span class=sc4>1</span>; 

  <span class=sc2>// Tratamento da seta esquerda</span>
  <span class=sc9>if</span>( seta_esquerda ) 
  <span class=sc16>{</span>
    xcol = xcol - nVelocidade; 
    sjogador = smove_esquerda; 
  <span class=sc16>} <span class=sc2>// endif seta_esquerda</span></span>

  <span class=sc2>// Tratamento da seta direita</span>
  <span class=sc9>if</span>( seta_direita ) 
  <span class=sc16>{</span>
    xcol = xcol + nVelocidade; 
    sjogador = smove_direita; 
  <span class=sc16>} <span class=sc2>// endif seta_direita</span></span>

    <span class=sc2>// Tratamento da seta cima \ seta baixo</span>
    <span class=sc9>if</span>( seta_cima  ) ylin = ylin - nVelocidade; 
    <span class=sc9>if</span>( seta_baixo ) ylin = ylin + nVelocidade; 

  <span class=sc2>// Resseta posição do jogador</span>
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>('R') & <span class=sc4>0x8000f</span>) setJogadorPos(320, 240);  

  <span class=sc2>// Esconde ou Mostra o cursor</span>
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>('E') & <span class=sc4>0x8000f</span>) <span class=prg>ShowCursor</span>(<span class=prg>false</span>);   
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>('M') & <span class=sc4>0x8000f</span>) <span class=prg>ShowCursor</span>(<span class=prg>true</span>);   

  <span class=sc2>// Atualiza posição do mouse em caso de movimento ocorrido</span>
  movOcorrido = seta_cima + seta_baixo + seta_esquerda + seta_direita; 
  <span class=sc9>if </span>(movOcorrido) 
  <span class=sc16>{</span>
  <span class=sc5>POINT </span>pt; 
  <span class=prg>pt.x </span>= xcol - 20; 
  <span class=prg>pt.y </span>= ylin - 20; 
  <span class=prg>ClientToScreen</span>(hJanela, &pt);  
  <span class=prg>SetCursorPos </span>(<span class=prg>pt.x</span>, <span class=prg>pt.y</span>);   
  <span class=sc16>} <span class=sc2>// endif movimento ocorrido</span></span>
<span class=sc16>} <span class=sc2>// tratarTeclado().fim</span></span>
</div>

<span class=sc2>// Declara uma variável para verificar movimento</span>
<b>static <span class=prg>int </span>movOcorrido = <span class=sc4>0</span>; </b> <b>movOcorrido = <span class=sc4>0</span>; </b>
Esta variável vai refletir a presença de movimento ou não. Em caso de
movimento  ocorrido  essa  variável  vai  ser utilizada para ativar o
processo de atualização da posição do mouse na janela.
Essa    variável    precisa  ser  zerada no início de cada frame para
evitar resultados indesejados.

<b><span class=prg>int </span>seta_direita, seta_esquerda, seta_cima, seta_baixo; 
seta_direita  = <span class=sc4>0</span>; seta_esquerda = <span class=sc4>0</span>; seta_cima = <span class=sc4>0</span>; seta_baixo = <span class=sc4>0</span>;  </b>
Estas  variáveis  refletem  o  movimento realizado e também devem ser
zeradas no início de cada frame.

<b><span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>(<span class=sc4>VK_LEFT</span> )  & <span class=sc4>0x8000f</span> ) seta_esquerda = <span class=sc4>1</span>; 
<span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>(<span class=sc4>VK_RIGHT</span>)  & <span class=sc4>0x8000f</span> ) seta_direita  = <span class=sc4>1</span>; 
<span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>(<span class=sc4>VK_UP</span>   )  & <span class=sc4>0x8000f</span> ) seta_cima     = <span class=sc4>1</span>; 
<span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>(<span class=sc4>VK_DOWN</span> )  & <span class=sc4>0x8000f</span> ) seta_baixo    = <span class=sc4>1</span>; </b>
Aqui ocorre a verificação de status de pressionamento  das  setas  do
teclado  e  na  ocorrência  de movimentação do jogador as respectivas
variáveis de movimento são atualizadas.

<u>Atualização do jogador e das variáveis de movimento</u>
<div class=niceview><b><span class=sc2>// Tratamento da seta esquerda</span>
<span class=sc9>if</span>( seta_esquerda ) <span class=sc16>{</span>
xcol = xcol - nVelocidade; 
sjogador = smove_esquerda;   <span class=sc16>} <span class=sc2>// endif seta_esquerda</span></span>

<span class=sc2>// Tratamento da seta direita</span>
<span class=sc9>if</span>( seta_direita ) <span class=sc16>{</span>
xcol = xcol + nVelocidade; 
sjogador = smove_direita; <span class=sc16>} <span class=sc2>// endif seta_direita</span></span>

<span class=sc2>// Tratamento da seta cima \ seta baixo</span>
<span class=sc9>if</span>( seta_cima  ) ylin = ylin - nVelocidade; 
<span class=sc9>if</span>( seta_baixo ) ylin = ylin + nVelocidade;</b></div>
Esse bloco atualiza as coordenadas (xcol, ylin)  e  a forma simbólica
do jogador conforme a seta pressionada.   Esse bloco gera o movimento
efetivo do jogador.

<b><span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>('R') & <span class=sc4>0x8000f</span>) setJogadorPos(320, 240);  </b>
Aqui o jogador recebe um reset ou uma reconfiguração na sua posicão.

<b><span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>('E') & <span class=sc4>0x8000f</span>) <span class=prg>ShowCursor</span>(<span class=prg>false</span>);   
<span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>('M') & <span class=sc4>0x8000f</span>) <span class=prg>ShowCursor</span>(<span class=prg>true</span>);   </b>
O pressionamento das teclas 'E' ou 'M' esconde ou mostra  o  ponteiro
do mouse com a função <span class=prg>ShowCursor()</span> testada aqui.  Aqui consolidamos o
exemplo  de  como  usar  <span class=prg>GetAsyncKeyState()</span>  para  ler  o  teclado  e
<span class=prg>ShowCursor()</span>  para   mostrar   ou  esconder  o  ponteiro  do  mouse.

<b>movOcorrido = seta_cima + seta_baixo + seta_esquerda + seta_direita; </b>
Aqui qualquer movimento com qualquer seta coloca <b>movOcorrido</b> em estado
de verdadeiro que é aproveitado no bloco de código seguinte.

<u>Atualizando o ponteiro do mouse na janela</u>
<div class=niceview><b><span class=sc9>if </span>(movOcorrido) <span class=sc16>{</span>
<span class=sc5>POINT </span>pt; 
<span class=prg>pt.x </span>= xcol - 20; 
<span class=prg>pt.y </span>= ylin - 20; 
<span class=prg>ClientToScreen</span>(hJanela, &pt);  
<span class=prg>SetCursorPos </span>(<span class=prg>pt.x</span>, <span class=prg>pt.y</span>);   <span class=sc16>} <span class=sc2>// endif movimento ocorrido</span></span></b></div>
Aqui o ponteiro do mouse é atualizado na janela com um distanciamento
de 20 pixels do jogador. Como a aplicação se expressa com coordenadas
de  janela,  a  função  <span class=prg>ClientToScreen()</span> é utilizada para converter o
posicionamento do ponteiro em  coordenadas de tela para a obtenção do
resultado  correto  com  a  função  <span class=prg>SetCursorPos()</span>  que  efetivamente
reposiciona o mouse na tela sobre nossa janela.

No caso de leitura da posição do mouse  o contexto de conversão sofre
uma inversão.  Nesse contexto utilizamos <span class=prg>GetMousePos()</span> para verificar
aonde o mouse está na  tela  e  <span class=prg>ScreenToClient()</span>  para  converter  as
coordenadas  para  os  termos  da  área  cliente  de  nossa  janela.

<b><u>2.6 Tratamento do mouse </u></b>
<div class=niceview><span class=prg>void </span>tratarMouse (<span class=prg>UINT </span>mensagem, <span class=sc16>WPARAM </span>wParam, <span class=sc16>LPARAM </span>lParam) 
<span class=sc16>{</span>
  <span class=sc2>// Pega coordenada do mouse</span>
  <span class=prg>int </span>xmouse = <span class=prg>LOWORD </span>(lParam);  
  <span class=prg>int </span>ymouse = <span class=prg>HIWORD </span>(lParam);  

  <span class=sc2>// trata as mensagens de mouse</span>
  <span class=sc9>switch </span>(mensagem) 
  <span class=sc16>{</span>

    <span class=sc9>case </span><span class=sc4>WM_LBUTTONDOWN:</span>
    setJogadorPos(10, 100);  
    <span class=sc6>break</span>; 

    <span class=sc9>case </span><span class=sc4>WM_RBUTTONDOWN:</span>
    setJogadorPos(320, 240);  
    <span class=sc6>break</span>; 

    <span class=sc9>case </span><span class=sc4>WM_MOUSEMOVE:</span>
    xcol = xmouse + 20; 
    ylin = ymouse + 20; 
    <span class=sc6>break</span>; 

  <span class=sc16>} <span class=sc2>// endswitch</span></span>
<span class=sc16>}</span>
</div>
<b><span class=prg>int </span>xmouse = <span class=prg>LOWORD </span>(lParam);  
<span class=prg>int </span>ymouse = <span class=prg>HIWORD </span>(lParam);   </b>
Nos  eventos  de mouse a posição do ponteiro chega através de <b>lParam</b>.
Esse  bloco  de  código  é  um  exemplo  de como extrair a posição do
ponteiro sintetizada no argumento <b>lParam</b>.

<b><span class=sc9>case </span><span class=sc4>WM_LBUTTONDOWN:</span> setJogadorPos(10,  100);  <span class=sc6>break</span>;
<span class=sc9>case </span><span class=sc4>WM_RBUTTONDOWN:</span> setJogadorPos(320, 240);  <span class=sc6>break</span>;  </b>
Esse  código  apenas  reposiciona o jogador em diferentes posições na
janela conforme o botão pressionado.
Aqui  é  um  exemplo simples e funcional de como tratar os eventos de
pressionamento  dos  botões    direito  ( <b class=sc4>WM_RBUTTONDOWN</b> ) e esquerdo
(  <b class=sc4>WM_LBUTTONDOWN</b>  )  do  mouse.  Na  documentação original da função
<span class=prg>GetAsyncKeyState()</span>  informa  que  ela também percebe o pressionamento
dos  botões  do  mouse  tendo naturalmente o código virtual (<b class=sc4>VK_...</b>)
referente aos botões.

<b><span class=sc9>case </span><span class=sc4>WM_MOUSEMOVE:</span>
xcol = xmouse + 20; ylin = ymouse + 20; <span class=sc6>break</span>; </b>
Na movimentação do mouse  o jogador acompanha o movimento mantendo um
distanciamento de 20 pixels do ponteiro do mouse.

<b><u>2.7 Tratamento das mensagens da janela </u></b>
<div class=niceview><span class=sc2>//  Esta função é chamada por DispatchMessage()</span>
<span class=sc16>LRESULT </span><span class=sc16>CALLBACK </span>processaJanela (<span class=sc16>HWND </span>hJanela, <span class=prg>UINT </span>mensagem, 
                                 <span class=sc16>WPARAM </span>wParam, <span class=sc16>LPARAM </span>lParam) 
<span class=sc16>{</span>
  <span class=sc9>switch </span>(mensagem) 
  <span class=sc16>{</span>
  <span class=sc9>case </span><span class=sc4>WM_DESTROY:</span>
    <span class=sc2>// Coloca uma mensagem WM_QUIT na fila de mensagem</span>
    Limpar();  
    <span class=prg>PostQuitMessage </span>(<span class=sc4>0</span>);   
    <span class=sc6>break</span>; 

  <span class=sc9>case </span><span class=sc4>WM_KEYDOWN:</span>
    <span class=sc9>if </span>(wParam == <span class=sc4>VK_ESCAPE</span>)  
    <span class=sc16>{</span>
      Limpar();  
      <span class=prg>PostQuitMessage</span>( <span class=sc4>0</span>);  
    <span class=sc16>} <span class=sc2>// endif</span></span>
    <span class=sc6>break</span>; 

  <span class=sc9>case </span><span class=sc4>WM_RBUTTONDOWN:</span>
  <span class=sc9>case </span><span class=sc4>WM_LBUTTONDOWN:</span>
  <span class=sc9>case </span><span class=sc4>WM_MOUSEMOVE:</span>
    tratarMouse (mensagem, wParam, lParam);  
    <span class=sc6>break</span>; 

  <span class=sc2>// Essa mensagem vai ocorrer a todo momento</span>
  <span class=sc9>case </span><span class=sc4>WM_PAINT:</span>
    <span class=sc2>// Renderiza a cena</span>
    Renderizar();  
    <span class=sc2>// Invalida a tela para chamar WM_PAINT novamente</span>
    <span class=prg>InvalidateRect</span>( hJanela, <span class=prg>NULL</span>, <span class=prg>false</span>);  
    <span class=sc6>break</span>; 

  <span class=sc2>// Processamento default de mensagens não tratada pela aplicação</span>
  <span class=sc9>default:</span>
    <span class=sc6>return </span><span class=prg>DefWindowProc </span>(hJanela, mensagem, wParam, lParam);  
  <span class=sc16>} <span class=sc2>// endswitch</span></span>

  <span class=sc6>return </span><span class=sc4>0</span>; 
<span class=sc16>} <span class=sc2>// processaJanela().fim</span></span>
</div>

<b><span class=sc9>case </span><span class=sc4>WM_RBUTTONDOWN:</span>
<span class=sc9>case </span><span class=sc4>WM_LBUTTONDOWN:</span>
<span class=sc9>case </span><span class=sc4>WM_MOUSEMOVE:</span>
tratarMouse (mensagem, wParam, lParam);  
<span class=sc6>break</span>;  </b>
Aqui  simplesmente  transferimos  os  eventos  de  mouse que queremos
processar para a função <b>tratarMouse()</b>.

<b><u>2.8 Configuração da posição do jogador </u></b>
<div class=niceview><span class=prg>void </span>setJogadorPos( <span class=prg>int </span>xpos, <span class=prg>int </span>ypos) 
<span class=sc16>{</span>
    <span class=sc2>// Variáveis de apoio: (pt.x, pt.y)</span>
    <span class=sc5>POINT </span>pt; 
	
    <span class=sc2>// Posiciona o mouse convertendo coordenada de janela</span>
    <span class=sc2>// para coordenada de tela</span>
    <span class=prg>pt.x </span>= xpos; 
    <span class=prg>pt.y </span>= ypos; 
    <span class=prg>ClientToScreen </span>(hJanela, &pt);  
    <span class=prg>SetCursorPos</span>(<span class=prg>pt.x</span>, <span class=prg>pt.y</span>);  

    <span class=sc2>// Recupera a posição do mouse</span>
    <span class=prg>GetCursorPos </span>(&pt);  

    <span class=sc2>// Converte coordenada de tela para coordenada de janela</span>
    <span class=prg>ScreenToClient </span>(hJanela, &pt);  

    <span class=sc2>// Configura posição do jogador</span>
    xcol = <span class=prg>pt.x </span>+ 20; 
    ylin = <span class=prg>pt.y </span>+ 20; 

<span class=sc16>} <span class=sc2>// setJogadorPos().fim</span></span>
</div>
<b><span class=sc5>POINT </span>pt; 	 </b>
Estas variáveis (pt.x, pt.y) servem como um  buffer  temporário  para
intermediar  o  processo  de  conversão  entre  os  dois sistemas  de
coordenadas: coordenadas de janela (aplicação), coordenadas de tela (
funções de leitura e posicionamento do mouse).

<b><span class=prg>pt.x </span>= xpos; <span class=prg>pt.y </span>= ypos; 
<span class=prg>ClientToScreen </span>(hJanela, &pt);  
<span class=prg>SetCursorPos</span>(<span class=prg>pt.x</span>, <span class=prg>pt.y</span>);  </b>
Aqui  posicionamos  o  mouse  convertendo  coordenada  de janela para
coordenada de tela

<b><span class=prg>GetCursorPos </span>(&pt); 
<span class=prg>ScreenToClient </span>(hJanela, &pt);  </b>
Aqui  obtemos  o  posicionamento  do mouse e fazemos a conversão para
coordenada de janela.

<b>xcol = <span class=prg>pt.x </span>+ 20; 
ylin = <span class=prg>pt.y </span>+ 20; </b>
Aqui configuramos a posição do jogador mantendo-o distante  do  mouse
por 20 pixels.

(*)O código dessa  função poderia  ficar mais compacto mas preferimos
um código mais detalhado  para mostrar o vai e vem da conversão entre
os sistemas de coordenadas.

<b><u>3. Código fonte do projeto de exemplo: prj_apiWin32</u></b>
<div class=prg-code><img src=images\prj_apiWin32.png>

//-----------------------------------------------------------------------------</span>
<span class=sc2>// Projeto: prj_apiWin32 - Arquivo: motor.h</span>
<span class=sc2>// Esta aplicação mostra como manipular mouse e teclado</span>
<span class=sc2>// utilizando a api nativa do Windows.</span>
<span class=sc2>// Produzido por www.gameprog.com.br</span>
//-----------------------------------------------------------------------------</span>
<span class=sc16>#ifndef </span>motor_h 
  <span class=sc16>#define </span>motor_h 

  <span class=sc2>// Esta função inicializa o Direct3D</span>
  <span class=sc16>HRESULT </span>initGfx (<span class=sc16>HWND </span>hJanela);  

  <span class=sc2>// Essa função libera os objetos utilizados</span>
  <span class=prg>void </span>Limpar();  

  <span class=sc2>// Essa função desenha a cena</span>
  <span class=prg>void </span>Renderizar();  

  <span class=sc2>// Esta função inicializa o objeto para mostrar texto</span>
  <span class=prg>void </span>inicializarTexto();  

  <span class=sc2>// Verifica e processa o pressionamento das teclas</span>
  <span class=prg>void </span>tratarTeclado(<span class=prg>void</span>);   

  <span class=sc2>// verifica e processa o pressionamento do mouse</span>
  <span class=prg>void </span>tratarMouse (<span class=prg>UINT </span>mensagem, <span class=sc16>WPARAM </span>wParam, <span class=sc16>LPARAM </span>lParam);  

  <span class=sc2>// Essa função configura a posição do jogador</span>
  <span class=prg>void </span>setJogadorPos( <span class=prg>int </span>xpos, <span class=prg>int </span>ypos);  

  <span class=sc2>// Esta função mostra um texto na coordenada (x, y) da janela</span>
  <span class=prg>void </span>mostrarTexto( <span class=prg>int </span>x, <span class=prg>int </span>y, <span class=prg>char* </span>texto);  

    <span class=sc2>//  Declaração da função que atende as mensagens da janela</span>
  <span class=sc16>LRESULT </span><span class=sc16>CALLBACK </span>processaJanela (<span class=sc16>HWND </span>hJanela, <span class=prg>UINT </span>mensagem, 
      <span class=sc16>WPARAM </span>wParam, <span class=sc16>LPARAM </span>lParam);  
<span class=sc16>#endif</span>
</div>

<div class=prg-code><span class=sc2>// -----------------------------------------------------------------------------</span>
<span class=sc2>// Projeto: prj_apiWin32 - arquivo: motor.cpp</span>
<span class=sc2>// Esta aplicação mostra como manipular mouse e teclado</span>
<span class=sc2>// utilizando a api nativa do Windows.</span>
<span class=sc2>// Produzido por www.gameprog.com.br</span>
<span class=sc2>// -----------------------------------------------------------------------------</span>
<span class=sc16>#include </span><span class=prg>&lt;windows.h&gt;</span>
<span class=sc16>#include </span><span class=prg>&lt;d3d9.h&gt;</span>
<span class=sc16>#include </span><span class=prg>&lt;d3dx9.h&gt;</span>
<span class=sc16>#include </span><span class=sc6>"motor.h"</span>

<span class=sc2>// Inclui as bibliotecas do Direct3D</span>
<span class=sc16>#pragma </span><span class=prg>comment</span>(lib, <span class=sc6>"d3d9.lib"</span>) 
<span class=sc16>#pragma </span><span class=prg>comment</span>(lib, <span class=sc6>"d3dx9.lib"</span>)  

<span class=sc2>// Variáveis globais</span>
<span class=sc2>// Representa o dispositivo D3D</span>
<span class=sc5>LPDIRECT3D9 </span>            g_Direct3d = <span class=prg>NULL</span>; 

<span class=sc2>// Representa o dispositivo Renderizador</span>
<span class=sc5>IDirect3DDevice9 </span>      *g_device = <span class=prg>NULL</span>; 

<span class=sc2>// Ponteiro para uma fonte do directx</span>
<b class=prg>ID3DXFont</b>        *gdxFonte = <span class=prg>NULL</span>; 

<span class=sc2>// Essa variável recebe informação de erro do Directx</span>
<span class=sc16>HRESULT </span>g_hr = <span class=sc4>0</span>; 

<span class=sc16>extern </span><span class=prg>int </span>g_xtela; 
<span class=sc16>extern </span><span class=prg>int </span>g_ytela; 
<span class=sc16>extern </span><span class=sc16>HWND </span>hJanela; 

<span class=sc2>// Representação símbólica do jogador</span>
<span class=prg>char* </span>smove_esquerda = <span class=sc6>"&lt;</span>(<span class=sc6>-:"</span>; 
<span class=prg>char* </span>smove_direita = <span class=sc6>":-</span>)<span class=sc6>&gt;"</span>; 
<span class=prg>char* </span>sjogador; 

<span class=sc2>// Controle de movimentação</span>
<span class=prg>int </span>xcol = 320; 
<span class=prg>int </span>ylin = 240; 
<span class=prg>int </span>nVelocidade = <span class=sc4>2</span>; 

<span class=sc2>// initGfx() - Inicializa o Direct3D</span>
<span class=sc16>HRESULT </span>initGfx( <span class=sc16>HWND </span>hJanela ) 
<span class=sc16>{</span>
  <span class=sc2>// Cria o objeto D3D que é necessário para criar o dispositivo gráfico</span>
  g_Direct3d = <span class=prg>Direct3DCreate9</span>( <span class=sc4>D3D_SDK_VERSION</span>);  

  <span class=sc2>// Verifica se objeto Direct3D foi criado</span>
  <span class=sc9>if</span>(g_Direct3d == <span class=prg>NULL</span>)  
  <span class=sc16>{</span>
    <span class=prg>MessageBox </span>(<span class=prg>NULL</span>, 
      <span class=sc6>"Falha na inialização do Direct3D"</span>, <span class=sc6>"InitGfx</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
    <span class=sc6>return </span><span class=sc4>E_FAIL</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=sc2>// Declara  a variável para os parâmetros de apresentação</span>
  <span class=sc5>D3DPRESENT_PARAMETERS </span>pps; 

  <span class=sc2>// Limpa a estrutura</span>
  <span class=prg>ZeroMemory</span>( &pps, <span class=sc16>sizeof</span>(pps) );  

  <span class=sc2>// Configura os parâmetros de apresentação</span>
  <span class=sc2>// A aplicação vai ter janela</span>
  <span class=prg>pps.Windowed </span>= <span class=prg>TRUE</span>; 

  <span class=sc2>// Esse método vira rapidamente o backbuffer para a tela imediata</span>
  <span class=prg>pps.SwapEffect </span>= <span class=sc4>D3DSWAPEFFECT_DISCARD</span>; 

  <span class=sc2>// Esse formato vai procurar se encaixar no modo de video corrente</span>
  <span class=prg>pps.BackBufferFormat </span>= <span class=sc4>D3DFMT_UNKNOWN</span>; 

  <span class=sc2>// Configuração do renderizador a ser criado</span>
  <span class=sc2>// Adaptador default (0)</span>
  <span class=prg>int </span>nAdaptador = <span class=sc4>D3DADAPTER_DEFAULT</span>; 

  <span class=sc2>// Tipo de dispositivo Hardware ou emulador de referência (software)</span>
  <span class=prg>D3DDEVTYPE </span>dispositivo_tipo = <span class=sc4>D3DDEVTYPE_HAL</span>; 

  <span class=sc2>// Flags de configuração do dispositivo</span>
  <span class=prg>DWORD </span>create_flags = <span class=sc4>D3DCREATE_SOFTWARE_VERTEXPROCESSING</span>; 

  <span class=sc2>// Criamos aqui o dispositivo renderizador</span>
  g_hr = <span class=prg>g_Direct3d-&gt;CreateDevice</span>( nAdaptador, dispositivo_tipo, 
    hJanela, create_flags, &pps, &g_device );  

  <span class=sc2>// Verifica se houve falha no processo</span>
  <span class=sc9>if</span>( <span class=prg>FAILED</span>( g_hr ) ) <span class=sc16>{</span>
    <span class=prg>MessageBox </span>(<span class=prg>NULL</span>, <span class=sc6>"Falha na criação: g_device"</span>, <span class=sc6>"initGfx</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
    <span class=sc6>return </span><span class=sc4>E_FAIL</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=sc2>// Faz inicialização da interface de texto</span>
  inicializarTexto();  

  <span class=sc2>// Define forma do jogador</span>
  sjogador = smove_esquerda; 

  <span class=sc2>// Configura a posição inicial do jogador</span>
  setJogadorPos(320, 240);  

  <span class=sc6>return </span><span class=sc4>S_OK</span>; 
<span class=sc16>} <span class=sc2>// initGfx().fim</span></span>

<span class=prg>void </span>inicializarTexto() 
<span class=sc16>{</span>

  <span class=sc2>// Altura</span>
  <span class=prg>int </span> nAltura = 24; 

  <span class=sc2>// Largura</span>
  <span class=prg>UINT </span>nLargura = <span class=sc4>0</span>; 

  <span class=sc2>// Peso ( weight )</span>
  <span class=prg>UINT </span>nPeso = <span class=sc4>FW_BOLD</span>; 

  <span class=sc2>// Nível de mipmap - 0: mipmap automático</span>
  <span class=prg>UINT </span>nMipmap = <span class=sc4>0</span>; 

  <span class=sc2>// Efeito itálico</span>
  <span class=prg>bool </span>bItalico = <span class=prg>false</span>; 

  <span class=sc2>// Conjunto de caracteres (charset)</span>
  <span class=prg>DWORD </span>nCharset = <span class=sc4>DEFAULT_CHARSET</span>; 

  <span class=sc2>// Precisão (OutputPrecision)</span>
  <span class=prg>DWORD </span>nPrecisao = <span class=sc4>OUT_DEFAULT_PRECIS</span>; 

  <span class=sc2>// Qualidade</span>
  <span class=prg>DWORD </span>nQualidade = <span class=sc4>DEFAULT_QUALITY</span>; 

  <span class=sc2>// Pitch e família</span>
  <span class=prg>DWORD </span>nFamilia = <span class=sc4>DEFAULT_PITCH </span>| <span class=sc4>FF_DONTCARE</span>; 

  <span class=sc2>// Nome da fonte</span>
  <span class=prg>char* </span>sFonte = <span class=sc6>"Arial"</span>; 

  g_hr = <span class=prg>D3DXCreateFont</span>( g_device, nAltura, nLargura, nPeso, nMipmap, bItalico, 
    nCharset, nPrecisao, nQualidade, nFamilia, sFonte, &gdxFonte );  

  <span class=sc9>if</span>(<span class=prg>FAILED </span>(g_hr) ) 
    <span class=prg>MessageBox</span>(<span class=prg>NULL</span>, <span class=sc6>"Texto: falha na inicialização"</span>, <span class=sc6>"inicializarTexto</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   

<span class=sc16>} <span class=sc2>// inicializarTexto()</span></span>

<span class=prg>void </span>mostrarTexto(<span class=prg>int </span>x, <span class=prg>int </span>y, <span class=prg>char* </span>texto) 
<span class=sc16>{</span>
  <span class=sc2>// Retorne se não houver fonte inicializada</span>
  <span class=sc9>if</span>(gdxFonte == <span class=prg>NULL</span>) <span class=sc6>return</span>; 

  <span class=sc2>// Cor de fundo da janela</span>
  <span class=sc5>D3DCOLOR </span>azul = <span class=prg>D3DCOLOR_XRGB</span>(<span class=sc4>0</span>, <span class=sc4>0</span>, 255);  

  <span class=sc2>// Configura a área limite</span>
  <span class=sc5>RECT </span>area_limite; 
  <span class=prg>SetRect</span>( &area_limite, x, y, g_xtela, g_ytela );  

  <span class=sc2>// Desenha o texto</span>
  <span class=prg>gdxFonte-&gt;DrawText</span>( <span class=prg>NULL</span>, texto, <span class=sc4>-1</span>, &area_limite, <span class=sc4>0</span>,  azul );  

<span class=sc16>} <span class=sc2>// mostrarTexto(); </span></span>
<span class=sc2>// Limpar() -  Libera todos os objetos previamente inicializados</span>
<span class=sc2>// -----------------------------------------------------------------------------</span>
<span class=prg>VOID </span>Limpar() 
<span class=sc16>{</span>

  <span class=sc2>// Libera objeto de mostrar texto</span>
  <span class=sc9>if</span>( gdxFonte != <span class=prg>NULL</span>)  <span class=prg>gdxFonte-&gt;Release</span>();  

  <span class=sc2>// Libera o dispositivo gráfico</span>
  <span class=sc9>if</span>( g_device != <span class=prg>NULL</span>)  <span class=prg>g_device-&gt;Release</span>();  

  <span class=sc2>// Libera o motor do Direct3D</span>
  <span class=sc9>if</span>( g_Direct3d != <span class=prg>NULL</span>)  <span class=prg>g_Direct3d-&gt;Release</span>();  

<span class=sc16>} <span class=sc2>// Limpar().fim</span></span>

<span class=sc2>// -----------------------------------------------------------------------------</span>
<span class=sc2>// Renderizar() - Desenha a cena</span>
<span class=sc2>// -----------------------------------------------------------------------------</span>
<span class=prg>VOID </span>Renderizar() 
<span class=sc16>{</span>
  <span class=sc2>// verificar teclado</span>
  tratarTeclado();  

  <span class=sc2>// Retorne se o dispositivo estiver nulo</span>
  <span class=sc9>if</span>( g_device == <span class=prg>NULL</span>)  <span class=sc6>return</span>; 

  <span class=sc2>// Cor de fundo da janela</span>
  <span class=sc16>const </span><span class=sc5>D3DCOLOR </span>branco = <span class=prg>D3DCOLOR_XRGB</span>( 255, 255, 255 );  

  <span class=sc2>// Limpa o backbuffer com uma cor branca</span>
  <span class=prg>g_device-&gt;Clear</span>( <span class=sc4>0</span>, <span class=prg>NULL</span>, <span class=sc4>D3DCLEAR_TARGET</span>, branco, <span class=sc4>1.0f</span>, <span class=sc4>0</span>);   

  <span class=sc2>// Começa a cena</span>
  <span class=sc9>if</span>( <span class=prg>SUCCEEDED</span>( <span class=prg>g_device-&gt;BeginScene</span>() ) ) 
  <span class=sc16>{</span>
    <span class=sc2>// Desenha jogador</span>
    mostrarTexto (xcol, ylin, sjogador);  

    <span class=sc2>// Desenha mensagens</span>
    mostrarTexto (10, 10, <span class=sc6>"Setas\\Mouse: movimentação"</span>);   
    mostrarTexto (10, 50, <span class=sc6>"R ou Botão direito: Resseta posição"</span>);   

    <span class=sc2>// Finalizando a cena</span>
    <span class=prg>g_device-&gt;EndScene</span>();  
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=prg>g_device-&gt;Present</span>( <span class=prg>NULL</span>, <span class=prg>NULL</span>, <span class=prg>NULL</span>, <span class=prg>NULL</span>);  
<span class=sc16>} <span class=sc2>// Renderizar().fim</span></span>


<span class=prg>void </span>tratarTeclado(<span class=prg>void</span>)  
<span class=sc16>{</span>
  <span class=sc2>// Declara uma variável para verificar movimento</span>
  static <span class=prg>int </span>movOcorrido = <span class=sc4>0</span>; 

  <span class=sc2>// Configura como zero (0)</span>
  movOcorrido = <span class=sc4>0</span>; 

  <span class=sc2>// Declara variáveis de estados das setas</span>
  <span class=prg>int </span>seta_direita, seta_esquerda, seta_cima, seta_baixo; 
  seta_direita  = <span class=sc4>0</span>; 
  seta_esquerda = <span class=sc4>0</span>; 
  seta_cima = <span class=sc4>0</span>; 
  seta_baixo = <span class=sc4>0</span>; 

  <span class=sc2>// Verifica as setas pressionadas</span>
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>(<span class=sc4>VK_LEFT</span>)  & <span class=sc4>0x8000f</span>)seta_esquerda = <span class=sc4>1</span>; 
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>(<span class=sc4>VK_RIGHT</span>)  & <span class=sc4>0x8000f</span>)seta_direita = <span class=sc4>1</span>; 
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>(<span class=sc4>VK_UP</span>)  & <span class=sc4>0x8000f</span>)seta_cima = <span class=sc4>1</span>; 
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>(<span class=sc4>VK_DOWN</span>)  & <span class=sc4>0x8000f</span>)seta_baixo = <span class=sc4>1</span>; 

  <span class=sc2>// Tratamento da seta esquerda</span>
  <span class=sc9>if</span>( seta_esquerda ) 
  <span class=sc16>{</span>
    xcol = xcol - nVelocidade; 
    sjogador = smove_esquerda; 
  <span class=sc16>} <span class=sc2>// endif seta_esquerda</span></span>

  <span class=sc2>// Tratamento da seta direita</span>
    <span class=sc9>if</span>( seta_direita ) 
  <span class=sc16>{</span>
    xcol = xcol + nVelocidade; 
    sjogador = smove_direita; 
  <span class=sc16>} <span class=sc2>// endif seta_direita</span></span>

    <span class=sc2>// Tratamento da seta cima \ seta baixo</span>
    <span class=sc9>if</span>( seta_cima)ylin = ylin - nVelocidade; 
    <span class=sc9>if</span>( seta_baixo ) ylin = ylin + nVelocidade; 

  <span class=sc2>// Reseta posição do jogador</span>
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>('R') & <span class=sc4>0x8000f</span>) 
    setJogadorPos(320, 240);  

  <span class=sc2>// Esconde ou Mostra o cursor</span>
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>('E') & <span class=sc4>0x8000f</span>) <span class=prg>ShowCursor</span>(<span class=prg>false</span>);   
  <span class=sc9>if</span>( <span class=prg>GetAsyncKeyState</span>('M') & <span class=sc4>0x8000f</span>) <span class=prg>ShowCursor</span>(<span class=prg>true</span>);   

  <span class=sc2>// Atualiza posição do mouse em caso de movimento ocorrido</span>
  movOcorrido = seta_cima + seta_baixo + seta_esquerda + seta_direita; 
  <span class=sc9>if </span>(movOcorrido) 
  <span class=sc16>{</span>
  <span class=sc5>POINT </span>pt; 
  <span class=prg>pt.x </span>= xcol - 20; 
  <span class=prg>pt.y </span>= ylin - 20; 
  <span class=prg>ClientToScreen</span>(hJanela, &pt);  
  <span class=prg>SetCursorPos </span>(<span class=prg>pt.x</span>, <span class=prg>pt.y</span>);   
  <span class=sc16>} <span class=sc2>// endif movimento ocorrido</span></span>

<span class=sc16>} <span class=sc2>// tratarTeclado().fim</span></span>


<span class=prg>void </span>tratarMouse (<span class=prg>UINT </span>mensagem, <span class=sc16>WPARAM </span>wParam, <span class=sc16>LPARAM </span>lParam) 
<span class=sc16>{</span>
  <span class=sc2>// Pega coordenada do mouse</span>
  <span class=prg>int </span>xmouse = <span class=prg>LOWORD </span>(lParam);  
  <span class=prg>int </span>ymouse = <span class=prg>HIWORD </span>(lParam);  

  <span class=sc2>// trata as mensagens de mouse</span>
  <span class=sc9>switch </span>(mensagem) 
  <span class=sc16>{</span>

    <span class=sc9>case </span><span class=sc4>WM_LBUTTONDOWN:</span>
    setJogadorPos(10, 100);  
    <span class=sc6>break</span>; 

    <span class=sc9>case </span><span class=sc4>WM_RBUTTONDOWN:</span>
    setJogadorPos(320, 240);  
    <span class=sc6>break</span>; 

    <span class=sc9>case </span><span class=sc4>WM_MOUSEMOVE:</span>
    xcol = xmouse + 20; 
    ylin = ymouse + 20; 
    <span class=sc6>break</span>; 

  <span class=sc16>} <span class=sc2>// endswitch</span></span>
<span class=sc16>}</span>


<span class=sc2>//  Esta função é chamada por DispatchMessage()</span>
<span class=sc16>LRESULT </span><span class=sc16>CALLBACK </span>processaJanela (<span class=sc16>HWND </span>hJanela, <span class=prg>UINT </span>mensagem, 
                                 <span class=sc16>WPARAM </span>wParam, <span class=sc16>LPARAM </span>lParam) 
<span class=sc16>{</span>
  <span class=sc9>switch </span>(mensagem) 
  <span class=sc16>{</span>
  <span class=sc9>case </span><span class=sc4>WM_DESTROY:</span>
    <span class=sc2>// Coloca uma mensagem WM_QUIT na fila de mensagem</span>
    Limpar();  
    <span class=prg>PostQuitMessage </span>(<span class=sc4>0</span>);   
    <span class=sc6>break</span>; 

  <span class=sc9>case </span><span class=sc4>WM_KEYDOWN:</span>
    <span class=sc9>if </span>(wParam == <span class=sc4>VK_ESCAPE</span>)  
    <span class=sc16>{</span>
      Limpar();  
      <span class=prg>PostQuitMessage</span>( <span class=sc4>0</span>);  
    <span class=sc16>} <span class=sc2>// endif</span></span>
    <span class=sc6>break</span>; 

  <span class=sc9>case </span><span class=sc4>WM_RBUTTONDOWN:</span>
  <span class=sc9>case </span><span class=sc4>WM_LBUTTONDOWN:</span>
  <span class=sc9>case </span><span class=sc4>WM_MOUSEMOVE:</span>
    tratarMouse (mensagem, wParam, lParam);  
    <span class=sc6>break</span>; 

    <span class=sc2>// Essa mensagem vai ocorrer a todo momento</span>
  <span class=sc9>case </span><span class=sc4>WM_PAINT:</span>
    <span class=sc2>// Renderiza a cena</span>
    Renderizar();  
    <span class=sc2>// Invalida a tela para chamar WM_PAINT novamente</span>
    <span class=prg>InvalidateRect</span>( hJanela, <span class=prg>NULL</span>, <span class=prg>false</span>);  
    <span class=sc6>break</span>; 

    <span class=sc2>// Processamento default de mensagens não tratada pela aplicação</span>
  <span class=sc9>default:</span>
    <span class=sc6>return </span><span class=prg>DefWindowProc </span>(hJanela, mensagem, wParam, lParam);  
  <span class=sc16>} <span class=sc2>// endswitch</span></span>

  <span class=sc6>return </span><span class=sc4>0</span>; 
<span class=sc16>} <span class=sc2>// processaJanela().fim</span></span>


<span class=prg>void </span>setJogadorPos( <span class=prg>int </span>xpos, <span class=prg>int </span>ypos) 
<span class=sc16>{</span>
    <span class=sc2>// Variáveis de apoio: (pt.x, pt.y)</span>
    <span class=sc5>POINT </span>pt;  

    <span class=sc2>// Posiciona o mouse convertendo coordenada de janela</span>
    <span class=sc2>// para coordenada de tela</span>
    <span class=prg>pt.x </span>= xpos; 
    <span class=prg>pt.y </span>= ypos; 
    <span class=prg>ClientToScreen </span>(hJanela, &pt);  
    <span class=prg>SetCursorPos</span>(<span class=prg>pt.x</span>, <span class=prg>pt.y</span>);  

    <span class=sc2>// Recupera a posição do mouse</span>
    <span class=prg>GetCursorPos </span>(&pt);  

    <span class=sc2>// Converte coordenada de tela para coordenada de janela</span>
    <span class=prg>ScreenToClient </span>(hJanela, &pt);  

    <span class=sc2>// Configura posição do jogador</span>
    xcol = <span class=prg>pt.x </span>+ 20; 
    ylin = <span class=prg>pt.y </span>+ 20; 

<span class=sc16>} <span class=sc2>// setJogadorPos().fim</span></span>
</div>

<div class=prg-code>//-----------------------------------------------------------------------------
<span class=sc2>// Projeto: prj_apiWin32 - arquivo: entrada.cpp</span>
<span class=sc2>// Esta aplicação mostra como manipular mouse e teclado</span>
<span class=sc2>// utilizando a api nativa do Windows.</span>
<span class=sc2>// Produzido por www.gameprog.com.br</span>
//-----------------------------------------------------------------------------</span>
<span class=sc16>#include </span><span class=prg>&lt;windows.h&gt;</span>
<span class=sc16>#include </span><span class=prg>&lt;d3d9.h&gt;</span>
<span class=sc16>#include </span><span class=prg>&lt;d3dx9.h&gt;</span>
<span class=sc16>#include </span><span class=sc6>"motor.h"</span>

<span class=sc2>// Variável global da classe da janela</span>
<span class=prg>char </span>sclasseJanela[ ] = <span class=sc6>"cls_directx"</span>; 

<span class=sc2>// Dimensões da janela</span>
<span class=prg>int </span>g_xtela = 640; 
<span class=prg>int </span>g_ytela = 480; 

<span class=sc2>// alça da janela</span>
<span class=sc16>HWND </span>hJanela; 

<span class=prg>int </span><span class=sc16>WINAPI </span><span class=prg>WinMain </span>(<span class=sc16>HINSTANCE </span>app_instancia, <span class=sc16>HINSTANCE </span>app_anterior, 
                    <span class=prg>LPSTR </span>sComando,<span class=prg>int </span>nExibir) <span class=sc16>{</span>

  <span class=sc2>// Estrutura de recepção das mensagens</span>
  <span class=sc5>MSG </span>mensagem; 

  <span class=sc2>// Estrutura de descrição da janela</span>
  <span class=sc5>WNDCLASSEX </span>wcls; 

  <span class=sc2>// Estrutura que descreve a janela</span>
  <span class=prg>wcls.hInstance </span>= app_instancia; 
  <span class=prg>wcls.lpszClassName </span>= sclasseJanela; 
  <span class=prg>wcls.lpfnWndProc </span>= processaJanela; 
  <span class=prg>wcls.style </span>= <span class=sc4>CS_HREDRAW </span>| <span class=sc4>CS_VREDRAW</span>; 
  <span class=prg>wcls.cbSize </span>= <span class=sc16>sizeof </span>(<span class=sc5>WNDCLASSEX</span>);   

  <span class=sc2>// O cursor e os ícones da aplicação são default</span>
  <span class=prg>wcls.hIcon </span>  = <span class=prg>LoadIcon </span>(<span class=prg>NULL</span>, <span class=sc4>IDI_APPLICATION</span>);   
  <span class=prg>wcls.hIconSm </span>= <span class=prg>LoadIcon </span>(<span class=prg>NULL</span>, <span class=sc4>IDI_APPLICATION</span>);   
  <span class=prg>wcls.hCursor </span>= <span class=prg>LoadCursor </span>(<span class=prg>NULL</span>, <span class=sc4>IDC_ARROW</span>);   

  <span class=sc2>// Aplicação sem menu</span>
  <span class=prg>wcls.lpszMenuName </span>= <span class=prg>NULL</span>; 

  <span class=sc2>// Nada de espaço extra atrelado a classe da janela (wcls)</span>
  <span class=prg>wcls.cbClsExtra </span>= <span class=sc4>0</span>; 

  <span class=sc2>// Nada de espaço extra atrelado a janela</span>
  <span class=prg>wcls.cbWndExtra </span>= <span class=sc4>0</span>; 

  <span class=sc2>// Cor default da janela</span>
  <span class=prg>wcls.hbrBackground </span>= ( <span class=sc16>HBRUSH</span>) <span class=sc4>COLOR_BACKGROUND</span>; 

  <span class=sc2>// Registra a janela e retorna se esta operação falhar</span>
  <span class=prg>int </span>status = <span class=prg>RegisterClassEx </span>(&wcls);  
  <span class=sc9>if</span>(status == <span class=sc4>0</span>)  <span class=sc16>{</span>
  <span class=prg>MessageBox</span>(<span class=prg>NULL</span>, <span class=sc6>"Registro falhou!"</span>, <span class=sc6>"WinMain</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
  <span class=sc6>return </span><span class=sc4>0</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=sc2>// Com a classe criada pode-se criar a janela</span>
  <span class=prg>DWORD </span>estiloExtra = <span class=sc4>0</span>; 
  <span class=sc16>const </span><span class=prg>char </span>janelaTitulo[] = <span class=sc6>"prj_apiWin32"</span>; 
  <span class=prg>DWORD </span>controleEstilo = <span class=sc4>WS_OVERLAPPED </span>| <span class=sc4>WS_SYSMENU </span>| <span class=sc4>WS_MINIMIZEBOX</span>; 
  <span class=prg>int </span>xpos = 160; 
  <span class=prg>int </span>ypos = 120; 
  <span class=sc16>HWND </span>hjanelaPai = <span class=sc16>HWND_DESKTOP</span>; 
  <span class=sc16>HMENU </span>sem_menu = <span class=prg>NULL</span>; 
  <span class=prg>LPVOID </span>dadoExtra = <span class=prg>NULL</span>; 

  <span class=sc2>// Cria a janela</span>
  hJanela = <span class=prg>CreateWindowEx</span>(estiloExtra, sclasseJanela, janelaTitulo, 
    controleEstilo, xpos, xpos,  g_xtela, g_ytela, hjanelaPai, sem_menu, 
    app_instancia, dadoExtra );  

  <span class=sc2>// Verifica se janela foi criada</span>
  <span class=sc9>if</span>(hJanela == <span class=prg>NULL</span>)  <span class=sc16>{</span>
  <span class=prg>MessageBox</span>(<span class=prg>NULL</span>, <span class=sc6>"Falha na criação da janela!"</span>, <span class=sc6>"WinMain</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
  <span class=sc6>return </span><span class=sc4>0</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=sc2>// Essa variável recebe informação de erro do Directx</span>
  <span class=sc16>HRESULT </span>hr; 
  <span class=sc2>// Inicia o Direct3D</span>
  hr = initGfx ( hJanela );  

  <span class=sc2>// Encerre a aplicação se houve falha</span>
  <span class=sc9>if</span>(<span class=prg>FAILED </span>(hr) ) <span class=sc16>{</span>
    <span class=prg>MessageBox </span>(hJanela, 
      <span class=sc6>"Direct3D: falha na inicialização"</span>, <span class=sc6>"WinMain</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
    <span class=prg>UnregisterClass</span>( sclasseJanela, <span class=prg>wcls.hInstance</span>);  
    <span class=sc6>return </span><span class=sc4>E_FAIL</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=sc2>// Mostra a janela</span>
  <span class=prg>ShowWindow</span>(hJanela, nExibir);  
  <span class=prg>UpdateWindow</span>(hJanela );  

  <span class=sc2>// Rode a bombeamento de mensagens até GetMessage() retornar 0</span>
  <span class=sc9>while </span>(<span class=prg>GetMessage</span>(&mensagem, <span class=prg>NULL</span>, <span class=sc4>0</span>, <span class=sc4>0</span>)) 
  <span class=sc16>{</span>
    <span class=sc2>// Traduz mensagem de tecla virtual em mensagem de caracteres</span>
    <span class=prg>TranslateMessage</span>( &mensagem );  

    <span class=sc2>// Despacha a mensagem para a função  processaJanela */</span>
    <span class=prg>DispatchMessage</span>( &mensagem );  
  <span class=sc16>} <span class=sc2>// endwhile</span></span>

  <span class=sc2>// O valor de retorno é zero(0) passado por PostQuitMessage()</span>
  <span class=prg>UnregisterClass</span>( sclasseJanela, <span class=prg>wcls.hInstance</span>);  
  <span class=sc6>return </span><span class=prg>mensagem.wParam</span>; 
<span class=sc16>} <span class=sc2>// WinMain().fim</span></span>
</div>
<hr>
<table align='bottom' border='0' cellspacing='0' cellpadding='0' width='20%'>
<tr><td><a href='dx9cpp.html#start' style='color:blue'> index </a></td>
<td><a href='track05-1.html' style='color:blue'>&lt;&lt;</a></td>
<td><a href='track05-3.html' style='color:blue'>&gt;&gt;</a></td></tr></table><pre>
<hr><div style='background-color:lightyellow;color:blue'>
<center>Produzido por Gameprog: Jair Pereira - Agosto/2014 ©
gameprog.br@gmail.com
<a href='http://www.gameprog.com.br'>http://www.gameprog.com.br</center><hr></div></div></body></html>