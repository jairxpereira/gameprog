<html>
<head>
<title>dx9cpp_fase04-1</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}


.sc1 {
	color: darkgreen;
	font-weight: bold;
}

.sntx {
	color: darkgreen;
	}


.sc2 {
	color: #008000;
}
.sc4 {
	color: #ff8000; font-weight: bold;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #FF0000;
}
.sc9 {
	color: #804000;
	font-weight: bold;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #400080;
}

.prg {
	color: #0000FF;
}

.prg-saida {

	margin-left:0px;
	width:500pt;
	background-color:lightblue;	
}

.prg-code {
	margin-left:0px;
	width:515pt;
	background-color:lightyellow;
	padding:10px;
	font-weight:bold;
}


.niceview {
	margin-left:0px;
	width:500pt;
	background-color:white;
	border-color:lightgray;
	border-width:1px;
	border-style:solid;
	padding:10px;
}

td
{
padding:3px;
}

table.dados
{
margin-left:0px;
width:53.5em;
border-collapse:collapse;
border:1px solid red;
text-align:center;
}

th
{
background-color:darkgreen;
color:yellow;
font-weight:bold;
text-transform:uppercase;
}

.pagebody
{
padding:10px;
margin-left:50px;
border-width:1px;
border-style:solid;
border-color:white;
background-color:white;
width:90%;
}
.mybody
{
margin-top:20pt;
margin-bottom:20pt;
margin-left:20pt;
margin-right:20pt;
border-color:lightgray;
background-image:url('background.png');
}
</style>
</head>
<body class=mybody><font color='black'>
<div class=pagebody>
<hr>
<center><b style='font-size:1.5em;' >Curso completo de DirectX 9 com C\C++</b><br>
Gameprog - Escola de programação de jogos digitais<br>
Contato: gameprog.br@gmail.com<br>
<b>Fase 04-1</b></center>
<hr>
<table align='left' border='0' cellspacing='0' cellpadding='0' width='20%'>
<tr><td><a href='dx9cpp.html#start' style='color:blue'> index </a></td>
<td><a href='track03-6.html' style='color:blue'>&lt;&lt;</a></td>
<td><a href='track04-2.html' style='color:blue'>&gt;&gt;</a></td></tr></table><br><pre>
<hr><a name='topo'></a>
<h3 style='background-color:#80ff80'>04.1 Formas primitivas</h3><pre>
<b><u>1.1 Visão geral</b></u>
<div class=prg-code><img src=images\prj_Primitivas.png></div>
<b><span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_TRIANGLELIST</span>, <b class=sc2>// (...)</b> ); </b>
Em nossos primeiros exemplos usamos  a  primitiva  <b>triangleList</b>  para
desenhar o triângulo ou o quadrado.   Além  desta  primitiva  que  já 
conhecemos  há  mais  cinco formas primitivas diferentes apresentadas 
abaixo.

<b><u>a) LineStrips e TriangleList</u></b>
<div class=prg-code>
<img src=images\LineStripsTriangleList.png></div>
<b class=prg>D3DPT_LINESTRIP</b>
Nesta configuração,  os vértices vão sendo ligados formando uma linha
contínua. Esse tipo é usado para desenhar <b>polyline</b>, isto é, múltiplas
linhas costuradas gerando polígonos com grande frequência.

<b class=prg>D3DPT_TRIANGLELIST</b>
Este tipo monta um triângulo independente a cada 3 vértices.

<b><u>b) PointList e LineList</u></b>
<div class=prg-code>
<img src=images\LinePointList.png></div>
<b class=prg>D3DPT_POINTLIST</b>
Os vértices são renderizados como  pontos  na  tela.   A configuração
do  estado  <b>D3DRS_POINTSIZE</b>  determina  o  tamanho  do  ponto  final:
<span class=prg>float nTamanho = 10.0f; 
g_device->SetRenderState(<b class=sc4>D3DRS_POINTSIZE</b>, <b>*(( DWORD*)</b>  &nTamanho ));  </span>

<b class=prg>D3DPT_LINELIST</b>
Cada  par  de  vértices  é  renderizado como  um  segmento  de  linha
independente.  O número  de  vértices à disposição dessa configuração
deve ser par.

<b><u>c) TriangleStrips e TriangleFan</u></b>
<div class=prg-code>
<img src=images\TriangleStripsTriangleFan.png></div>
<b class=prg>D3DPT_TRIANGLESTRIP</b>
Os  vértices  são  renderizados  como  uma  sequência  costurada  de
triângulos. Esse  tipo  é  o  mais usado na construção de modelos 3d.
Tal como <span class=prg>TriangleFan</span>,   essa  configuração  é  mais eficiente porque 
evita a duplicação de vértices.

<b class=prg>D3DPT_TRIANGLEFAN</b>
Os  vértices  são  renderizados  como  uma  sequência  costurada  de
triângulos tendo o primeiro vértice como base de todos os triângulos
sequentes.


<b><u>1.2 Estrutura principal da aplicação</b></u>
<div class=prg-code><b class=sc2>Arquivo: motor.cpp</b>
<div class=niceview style="border-style:dashed;">
Aspectos globais
	Declaração do ponteiro global para o buffer de vértices
	
initGfx()
	Inicializa o objeto Direct3d
	Inicializa o dispositivo renderizador
	chama inicializar_Buffers() para criar o vertexbuffer
	chama inicializar_Camera() para a configuração inicial da câmera
	chama montar_Geometria() para configurar os vértices do vertexbuffer
		
inicializar_Buffers()
	Criação do buffer de vértices (vertexbuffer)		
	
montar_Geometria()
	Acessa o buffer de vértices
	<b class=sc16>calcula a posição circular de cada vértice</b>
	joga a posição do vértice no vertexbuffer
	
renderizar_Geometria()
	Declara o formato de vértice utilizado ao directx
	Indica ao dispositivo o buffer de vértices que será utilizado	
	<b class=sc16>O temporizador indica a cada dois segundos uma primitiva diferente
	Renderiza os vértices com g_device->DrawPrimitive() </b>

Renderizar()
	Limpa a tela	
	chama renderizar_Geometria() para desenhar as primitivas
	Apresenta a cena

Limpar()	
	Libera o buffer de vértices	
	Libera dispositivo renderizador
	Libera objeto Direct3d	
</div></div>

<b><u>2.1.1 Aspectos globais - Arquivo: motor.h</u></b>
<div class=niceview>//-----------------------------------------------------------------------------</span>
<span class=sc2>// Projeto: prj_Primitivas - Arquivo: motor.h</span>
<span class=sc2>// Esta aplicação mostra como renderizar as formas primitivas</span>
<span class=sc2>// By www.gameprog.com.br</span>
//-----------------------------------------------------------------------------</span>
<span class=sc16>#ifndef </span>motor_h 
  <span class=sc16>#define </span>motor_h 

<span class=sc2>// Inclui as bibliotecas do Direct3D</span>
<span class=sc16>#pragma </span><span class=prg>comment</span>(lib, <span class=sc6>"d3d9.lib"</span>) 
<span class=sc16>#pragma </span><span class=prg>comment</span>(lib, <span class=sc6>"d3dx9.lib"</span>)  

<span class=sc2>// Definição do formato de vértice utilizado por esta aplicação</span>
<span class=sc16>#define </span><span class=sc4>CustomVertex_PositionColored_Format</span>(<span class=sc4>D3DFVF_XYZ </span>| <span class=sc4>D3DFVF_DIFFUSE</span>) 

<span class=sc2>// Estrutura do vértice customizado</span>
<span class=prg>struct </span><span class=sc5>CustomVertex_PositionColored</span>
<span class=sc16>{</span>
  <span class=prg>float </span>x, y, z; 
  <span class=prg>DWORD </span>cor; 

  <span class=sc2>// Construtor default</span>
  <span class=sc5>CustomVertex_PositionColored</span>() {} 

  <span class=sc5>CustomVertex_PositionColored</span>( <span class=prg>float </span>_x, <span class=prg>float </span>_y, <span class=prg>float </span>_z,  <span class=prg>DWORD </span>_cor) 
  <span class=sc16>{</span>
    x = _x; 
    y = _y; 
    z = _z; 
    cor = _cor; 
  <span class=sc16>}</span>
<span class=sc16>}; <span class=sc2>// fim da estrutura CustomVertex_PositionColored</span></span>

  <span class=sc2>// Esta função inicializa o Direct3D</span>
  <span class=sc16>HRESULT </span>initGfx (<span class=sc16>HWND </span>hJanela);  

  <span class=sc2>// Essa função libera os objetos utilizados</span>
  <span class=prg>void </span>Limpar();  

  <span class=sc2>// Essa função desenha a cena</span>
  <span class=prg>void </span>Renderizar();  

  <span class=sc2>// Essa função inicializa o buffer de vértices</span>
  <span class=prg>void </span>inicializar_Buffers(<span class=prg>void</span>);   

  <span class=sc2>// Essa função monta formas geométricas</span>
  <span class=prg>void </span>montar_Geometria (<span class=prg>void</span>);   

  <span class=sc2>// Renderiza os vértices em formas geométricas</span>
  <span class=prg>void </span>renderizar_Geometria (<span class=prg>void</span>);   

  <span class=sc2>// Faz a configuração inicial da câmera</span>
  <span class=prg>void </span>inicializar_Camera(<span class=prg>void</span>);   

  <span class=sc2>// Configura o texto da barra de títulos da janela</span>
  <span class=prg>void </span>config_texto( <span class=prg>char </span>*texto);  

  <span class=sc2>//  Declaração da função que atende as mensagens da janela</span>
<span class=sc16>LRESULT </span><span class=sc16>CALLBACK </span>processaJanela (<span class=sc16>HWND </span>hJanela, <span class=prg>UINT </span>mensagem, 
                                 <span class=sc16>WPARAM </span>wParam, <span class=sc16>LPARAM </span>lParam);  
<span class=sc16>#endif</span>
</div>
<b><span class=prg>void </span>inicializar_Buffers(<span class=prg>void</span>);  </b>
Esta função faz a criação do vertexbuffer. 

<b><span class=prg>void </span>montar_Geometria (<span class=prg>void</span>);  </b>
Essa função faz a configuração dos vértices dentro  do  vertexbuffer,
distribuindo-os numa forma circular pelo espaço 3d usando  a  fórmula
de produção do círculo.

<b><span class=prg>void </span>renderizar_Geometria (<span class=prg>void</span>);   </b>
Essa função  utilizando  o  temporizador  faz  uso  de  uma  primitiva
diferente a cada dois segundos e mostra a primitiva utilizada na barra
de títulos da janela.

<b><u>2.1.2 Aspectos globais: Arquivo: motor.cpp</u></b>
<div class=niceview><b><span class=sc2>// Representa o buffer de vértices</span>
<span class=sc5>IDirect3DVertexBuffer9* </span>g_vbVertices   = <span class=prg>NULL</span>; 

<span class=sc2>// Quantidade de vértices utilizados nesta aplicação</span>
<span class=sc16>const </span><span class=prg>UINT </span>g_nVerticesQtd = 60; 
</b></div>
<b><span class=sc5>IDirect3DVertexBuffer9* </span>g_vbVertices   = <span class=prg>NULL</span>; </b>
Declaração do vertexbuffer.

<b><span class=sc16>const </span><span class=prg>UINT </span>g_nVerticesQtd = 60; </b>
O vertexbuffer vai conter 60 vértices distribuidos com igual distância
um do outro dentro de um perímetro circular.

<b><u>2.2 Inicialização do vertexbuffer</u></b>
Segue abaixo a listagem da criação do vertexbuffer.

<div class=niceview><span class=prg>void </span>inicializar_Buffers(<span class=prg>void</span>)  
<span class=sc16>{</span>
  <span class=sc2>// Tamanho do vertexbuffer em bytes</span>
  <span class=prg>UINT </span> vbTamanho = <span class=sc16>sizeof</span>(<span class=sc5>CustomVertex_PositionColored</span>)  * g_nVerticesQtd; 

  <span class=sc2>// Dica de uso.</span>
  <span class=prg>DWORD </span> uso_flags = <span class=sc4>D3DUSAGE_WRITEONLY</span>; 

  <span class=sc2>// Formato do vértice dos vértices do vertexbuffer</span>
  <span class=prg>DWORD </span> vbFormato = <span class=sc4>CustomVertex_PositionColored_Format</span>; 

  <span class=sc2>// Definição da classe de memória (alojamento)</span>
  <span class=sc4>D3DPOOL </span>Piscina  = <span class=sc4>D3DPOOL_MANAGED</span>; 

  <span class=sc2>// Criação efetiva do buffer de vértices (vertexbuffer)</span>
  g_hr = <span class=prg>g_device-&gt;CreateVertexBuffer</span>(vbTamanho, uso_flags, 
    vbFormato, Piscina, &g_vbVertices, <span class=prg>NULL</span>);   

  <span class=sc2>// Verifica falha na criação</span>
  <span class=sc9>if</span>(<span class=prg>FAILED </span>(g_hr) ) <span class=sc16>{</span>
    <span class=prg>MessageBox </span>(<span class=prg>NULL</span>, 
      <span class=sc6>"Falha na criação do buffer de vértices"</span>, 
      <span class=sc6>"inicializar_Buffers</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
    <span class=sc6>return</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>
<span class=sc16>} <span class=sc2>// inicializar_Buffers().fim</span></span>
</div>

<b><u>2.3 Montagem da geometria</u></b>
<div class=niceview><span class=prg>void </span>montar_Geometria(<span class=prg>void</span>)  
<span class=sc16>{</span>
  <span class=sc2>// Variáveis para configurar o posicionamento dos vértices</span>
  <span class=prg>float </span>xcol = <span class=sc4>0.0f</span>; 
  <span class=prg>float </span>ylin = <span class=sc4>0.0f</span>; 
  <span class=prg>float </span>zpos = <span class=sc4>0.0f</span>; 

  <span class=sc2>// Utilizado para controlar o índice do vértice</span>
  <span class=prg>UINT </span>ndx = <span class=sc4>0</span>; 

  <span class=sc2>// Distribuição circular dos vértices no espaço</span>
  <span class=prg>UINT </span>passo = 360 / g_nVerticesQtd; 

  <span class=sc2>// Ponteiro de acesso aos dados do buffer de vértices</span>
  <span class=sc5>CustomVertex_PositionColored </span>*pVerts; 

  <span class=sc2>// Aqui a aplicação ganha acesso à memória do buffer de vértices</span>
  <span class=prg>g_vbVertices-&gt;Lock</span>( <span class=sc4>0</span>, <span class=sc4>0</span>, (<span class=prg>void**</span>) &pVerts, <span class=sc4>0</span>);  

  <span class=sc2>// Vamos posicionar os vértices em círculo</span>
  <span class=prg>for </span>(<span class=prg>float </span>ncx = <span class=sc4>0.0f</span>; ncx &lt;= <span class=sc4>360.0f</span>; ncx += passo) 
  <span class=sc16>{</span>
    <span class=sc2>// Converte graus para radianos</span>
    <span class=prg>double </span>radianos = ncx * (<span class=sc4>D3DX_PI </span>/ <span class=sc4>180.0f</span>);   

    <span class=sc2>// Tamanho do círculo</span>
    <span class=prg>float </span>nRaio = <span class=sc4>2.0f</span>; 

    <span class=sc2>// (x,y) distribuidos de maneira circular</span>
    xcol = (<span class=prg>float</span>)  <span class=prg>cos</span>(radianos) * nRaio; 
    ylin = (<span class=prg>float</span>)  <span class=prg>sin</span>(radianos) * nRaio; 

    <span class=sc2>// Posicionamento do vértice</span>
    pVerts[ndx] = <span class=sc5>CustomVertex_PositionColored</span>( xcol, ylin, zpos, vermelho);  

    <span class=sc2>// Coloca no centro o terceiro vértice de cada triângulo</span>
    <span class=sc9>if </span>(ndx % <span class=sc4>3 </span>== <span class=sc4>0</span>)  
      pVerts[ndx] = <span class=sc5>CustomVertex_PositionColored</span>( <span class=sc4>0</span>, <span class=sc4>0</span>, zpos, amarelo);  

    <span class=sc2>// Atualiza índice de controle do vértice</span>
    ndx = ndx + <span class=sc4>1</span>; 

  <span class=sc16>} <span class=sc2>// endfor</span></span>

  <span class=sc2>// Liberação do vertexbuffer</span>
  <span class=prg>g_vbVertices-&gt;Unlock</span>();  

<span class=sc16>} <span class=sc2>//  montar_Geometria().fim</span></span>
</div>
<b><span class=prg>float </span>xcol = <span class=sc4>0.0f</span>;  <span class=prg>float </span>ylin = <span class=sc4>0.0f</span>;  <span class=prg>float </span>zpos = <span class=sc4>0.0f</span>; </b>
Estas   variáveis   temporárias   são   usadas   na  configuração  de
posicionamento dos vértices.

<b><span class=prg>UINT </span>ndx = <span class=sc4>0</span>; </b>
Esta  variável  é  para  o  controle  do  índice  de  cada vértice do
vertexbuffer.

<b><span class=prg>UINT </span>passo = 360 / g_nVerticesQtd; </b>
Dado que o círculo tem um perímetro de 360 graus e a quantidade de
vértices é 60, o valor <b>passo</b> vai ser 6  graus  que  consistirá  na
base para distanciar os vértices do perímetro circular.

<b><span class=sc5>CustomVertex_PositionColored </span>*pVerts; </b>
Este aqui é o ponteiro para acessar o espaço reservado de 60 vértices
no vertexbuffer.

<b><span class=prg>g_vbVertices-&gt;Lock</span>( <span class=sc4>0</span>, <span class=sc4>0</span>, (<span class=prg>void**</span>) &pVerts, <span class=sc4>0</span>);  </b>
Aqui é a forma de ganhar acesso ao espaço total do vertexbuffer.


<b><span class=prg>for </span>(<span class=prg>float </span>ncx = <span class=sc4>0.0f</span>; ncx &lt;= <span class=sc4>360.0f</span>; ncx += passo) <span class=sc16>{</span> </b>
ncx vai assumir valores de 0 a 360 em múltiplos do valor da variável <b>passo</b>.

<b><span class=prg>double </span>radianos = ncx * (<span class=sc4>D3DX_PI </span>/ <span class=sc4>180.0f</span>);  </b>
As funções matemáticas que vamos usar trabalham com ângulos expressos
em radianos por isso aqui está a fórmula para converter ângulos  para
radianos.

<b><span class=prg>float </span>nRaio = <span class=sc4>2.0f</span>; 
xcol = (<span class=prg>float</span>)  <span class=prg>cos</span>(radianos) * nRaio; 
ylin = (<span class=prg>float</span>)  <span class=prg>sin</span>(radianos) * nRaio; </b>
Aqui é a pequena fórmula que produz círculos  ou  elipses  se  houver
divergência nos raios (<b>nRaio</b>) dos eixos x (<b>xcol</b>) e y (<b>ylin</b>).

<b>pVerts[ndx] = <span class=sc5>CustomVertex_PositionColored</span>( xcol, ylin, zpos, vermelho); </b>
Aqui cada vértice do perímetro  vai recebendo sua configuração de cor
e posicionamento.

<b><span class=sc9>if </span>(ndx % <span class=sc4>3 </span>== <span class=sc4>0</span>)  pVerts[ndx] = <span class=sc5>CustomVertex_PositionColored</span>( <span class=sc4>0</span>, <span class=sc4>0</span>, zpos, amarelo); </b>
Aqui este cálculo com o operador módulus (%)  joga o terceiro vértice
de cada triângulo para centro do círculo.

<b>ndx = ndx + <span class=sc4>1</span>; <span class=sc16>} <span class=sc2>// endfor</span></span></b>
Esta linha atualiza o índice de acesso ao vértice.

<b><u>2.4 Renderização da geometria</u></b>
<div class=niceview><span class=prg>void </span>renderizar_Geometria() 
<span class=sc16>{</span>
  <span class=sc2>// Mensagens para a barra de títulos da janela</span>
  <span class=prg>char </span>*mensagem[] = <span class=sc16>{</span>
    <span class=sc6>"prj_Primitivas: D3DPT_POINTLIST"</span>, <span class=sc6>"prj_Primitivas: D3DPT_LINELIST"</span>, 
    <span class=sc6>"prj_Primitivas: D3DPT_LINESTRIP"</span>, <span class=sc6>"prj_Primitivas: D3DPT_TRIANGLELIST"</span>, 
    <span class=sc6>"prj_Primitivas: D3DPT_TRIANGLESTRIP"</span>, <span class=sc6>"prj_Primitivas: D3DPT_TRIANGLEFAN" </span><span class=sc16>}</span>; 

    <span class=sc2>// Produz a cada dois segundos um valor de 0 a 5.</span>
    temporizador = ( <span class=prg>clock</span>() / 2000 ) % <span class=sc4>6</span>; 

    <span class=sc2>// Configura o texto da janela</span>
    config_texto( mensagem[temporizador]);  

    <span class=sc2>// Declara o formato de vértice utilizado pela aplicação</span>
    <span class=prg>g_device-&gt;SetFVF</span>( <span class=sc4>CustomVertex_PositionColored_Format</span>);  

    <span class=sc2>// Configura tamanho do ponto para a renderização em  D3DPT_POINTLIST</span>
    <span class=prg>float </span>nTamanho = <span class=sc4>10.0f</span>; 
    <span class=prg>g_device-&gt;SetRenderState</span>(<span class=sc4>D3DRS_POINTSIZE</span>, *(( <span class=prg>DWORD*</span>)  &nTamanho ));  

    <span class=sc2>// Informação do buffer de vértices utilizado</span>
    <span class=prg>g_device-&gt;SetStreamSource</span>( <span class=sc4>0</span>, g_vbVertices, <span class=sc4>0</span>, 
                      <span class=sc16>sizeof</span>(<span class=sc5>CustomVertex_PositionColored</span>) );  

    <span class=sc2>// Renderiza a primitiva selecionada pelo tempo decorrido</span>
    <span class=sc9>switch</span>( temporizador ) 
    <span class=sc16>{</span>
    <span class=sc9>case </span>0: 
      <span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_POINTLIST</span>, <span class=sc4>0</span>, g_nVerticesQtd);  
      <span class=sc6>break</span>; 

    <span class=sc9>case </span>1: 
      <span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_LINELIST</span>, <span class=sc4>0</span>, g_nVerticesQtd / <span class=sc4>2</span>);   
      <span class=sc6>break</span>; 

    <span class=sc9>case </span>2: 
      <span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_LINESTRIP</span>, <span class=sc4>0</span>, g_nVerticesQtd - <span class=sc4>1</span>);   
      <span class=sc6>break</span>; 

    <span class=sc9>case </span>3: 
      <span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_TRIANGLELIST</span>, <span class=sc4>0</span>, g_nVerticesQtd / <span class=sc4>3</span>);   
      <span class=sc6>break</span>; 

    <span class=sc9>case </span>4: 
      <span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_TRIANGLESTRIP</span>, <span class=sc4>0</span>, g_nVerticesQtd - <span class=sc4>2</span>);   
      <span class=sc6>break</span>; 

    <span class=sc9>case </span>5: 
      <span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_TRIANGLEFAN</span>, <span class=sc4>0</span>, g_nVerticesQtd - <span class=sc4>2</span>);   
      <span class=sc6>break</span>; 

    <span class=sc16>} <span class=sc2>// fim do switch</span></span>
<span class=sc16>} <span class=sc2>// renderizar_Geometria().fim</span></span>
</div>

<b><span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_POINTLIST</span>,	<span class=sc4>0</span>, g_nVerticesQtd);  
<span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_LINELIST</span>, 	<span class=sc4>0</span>, g_nVerticesQtd / <span class=sc4>2</span>);   
<span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_LINESTRIP</span>,	<span class=sc4>0</span>, g_nVerticesQtd - <span class=sc4>1</span>);   
<span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_TRIANGLELIST</span>,	<span class=sc4>0</span>, g_nVerticesQtd / <span class=sc4>3</span>);   
<span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_TRIANGLESTRIP</span>,	<span class=sc4>0</span>, g_nVerticesQtd - <span class=sc4>2</span>);   
<span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_TRIANGLEFAN</span>,	<span class=sc4>0</span>, g_nVerticesQtd - <span class=sc4>2</span>);   </b>
Uma das coisas para ficar atento aqui  é  que  devido  a  conformação
particular de cada primitiva a mesma quantidade de vértices dá origem
a diferentes quantidades de primitivas.   Repare  então  na expressão
matemática que dá o valor final da quantidade  de  primitivas  a  ser
renderizada com o mesmo pacote de vértices.

<b><u>3. Código fonte do projeto de exemplo: prj_Primitivas</u></b>
<div class=prg-code><img src=images\prj_Primitivas.png>

//-----------------------------------------------------------------------------</span>
<span class=sc2>// Projeto: prj_Primitivas - Arquivo: motor.h</span>
<span class=sc2>// Esta aplicação mostra como renderizar as formas primitivas</span>
<span class=sc2>// By www.gameprog.com.br</span>
//-----------------------------------------------------------------------------</span>
<span class=sc16>#ifndef </span>motor_h 
  <span class=sc16>#define </span>motor_h 

<span class=sc2>// Inclui as bibliotecas do Direct3D</span>
<span class=sc16>#pragma </span><span class=prg>comment</span>(lib, <span class=sc6>"d3d9.lib"</span>) 
<span class=sc16>#pragma </span><span class=prg>comment</span>(lib, <span class=sc6>"d3dx9.lib"</span>)  

<span class=sc2>// Definição do formato de vértice utilizado por esta aplicação</span>
<span class=sc16>#define </span><span class=sc4>CustomVertex_PositionColored_Format</span>(<span class=sc4>D3DFVF_XYZ </span>| <span class=sc4>D3DFVF_DIFFUSE</span>) 

<span class=sc2>// Estrutura do vértice customizado</span>
<span class=prg>struct </span><span class=sc5>CustomVertex_PositionColored</span>
<span class=sc16>{</span>
  <span class=prg>float </span>x, y, z; 
  <span class=prg>DWORD </span>cor; 

  <span class=sc2>// Construtor default</span>
  <span class=sc5>CustomVertex_PositionColored</span>() {} 

  <span class=sc5>CustomVertex_PositionColored</span>( <span class=prg>float </span>_x, <span class=prg>float </span>_y, <span class=prg>float </span>_z,  <span class=prg>DWORD </span>_cor) 
  <span class=sc16>{</span>
    x = _x; 
    y = _y; 
    z = _z; 
    cor = _cor; 
  <span class=sc16>}</span>
<span class=sc16>}; <span class=sc2>// fim da estrutura CustomVertex_PositionColored</span></span>

  <span class=sc2>// Esta função inicializa o Direct3D</span>
  <span class=sc16>HRESULT </span>initGfx (<span class=sc16>HWND </span>hJanela);  

  <span class=sc2>// Essa função libera os objetos utilizados</span>
  <span class=prg>void </span>Limpar();  

  <span class=sc2>// Essa função desenha a cena</span>
  <span class=prg>void </span>Renderizar();  

  <span class=sc2>// Essa função inicializa o buffer de vértices</span>
  <span class=prg>void </span>inicializar_Buffers(<span class=prg>void</span>);   

  <span class=sc2>// Essa função monta formas geométricas</span>
  <span class=prg>void </span>montar_Geometria (<span class=prg>void</span>);   

  <span class=sc2>// Renderiza os vértices em formas geométricas</span>
  <span class=prg>void </span>renderizar_Geometria (<span class=prg>void</span>);   

  <span class=sc2>// Faz a configuração inicial da câmera</span>
  <span class=prg>void </span>inicializar_Camera(<span class=prg>void</span>);   

  <span class=sc2>// Configura o texto da barra de títulos da janela</span>
  <span class=prg>void </span>config_texto( <span class=prg>char </span>*texto);  

  <span class=sc2>//  Declaração da função que atende as mensagens da janela</span>
<span class=sc16>LRESULT </span><span class=sc16>CALLBACK </span>processaJanela (<span class=sc16>HWND </span>hJanela, <span class=prg>UINT </span>mensagem, 
                                 <span class=sc16>WPARAM </span>wParam, <span class=sc16>LPARAM </span>lParam);  

<span class=sc16>#endif</span>
</div>

<div class=prg-code><span class=sc2>// -----------------------------------------------------------------------------</span>
<span class=sc2>// Projeto: prj_Primitivas - arquivo: motor.cpp</span>
<span class=sc2>// Esta aplicação mostra como renderizar as formas primitivas</span>
<span class=sc2>// By www.gameprog.com.br</span>
<span class=sc2>// -----------------------------------------------------------------------------</span>
<span class=sc16>#include </span><span class=prg>&lt;windows.h&gt;</span>
<span class=sc16>#include </span><span class=prg>&lt;d3d9.h&gt;</span>
<span class=sc16>#include </span><span class=prg>&lt;d3dx9.h&gt;</span>
<span class=sc16>#include </span><span class=prg>&lt;math.h&gt;</span>
<span class=sc16>#include </span><span class=prg>&lt;time.h&gt;</span>
<span class=sc16>#include </span><span class=prg>&lt;string.h&gt;</span>
<span class=sc16>#include </span><span class=sc6>"motor.h"</span>

<span class=sc2>// Variáveis globais</span>
<span class=sc2>// Representa o dispositivo Direct3D</span>
<span class=sc5>LPDIRECT3D9 </span>            g_Direct3d = <span class=prg>NULL</span>; 

<span class=sc2>// Representa o dispositivo Renderizador</span>
<span class=sc5>IDirect3DDevice9* </span>      g_device = <span class=prg>NULL</span>; 


<span class=sc2>// Representa o buffer de vértices</span>
<span class=sc5>IDirect3DVertexBuffer9* </span>g_vbVertices   = <span class=prg>NULL</span>; 

<span class=sc2>// Quantidade de vértices utilizados nesta aplicação</span>
<span class=sc16>const </span><span class=prg>UINT </span>g_nVerticesQtd = 60; 


<span class=sc2>// Essa variável recebe informação de erro do Directx</span>
<span class=sc16>HRESULT </span>g_hr = <span class=sc4>0</span>; 

<span class=sc2>// Tamanho da janela</span>
<span class=sc16>extern </span><span class=prg>int </span> g_xtela; 
<span class=sc16>extern </span><span class=prg>int </span> g_ytela; 
<span class=sc16>extern </span><span class=sc16>HWND </span>hJanela; 

<span class=sc2>// Constante para cores</span>
<span class=sc16>const </span><span class=prg>DWORD </span>vermelho = <span class=sc4>0xFFFF0000</span>; 
<span class=sc16>const </span><span class=prg>DWORD </span>branco  = <span class=sc4>0xFFFFFFFF</span>; 
<span class=sc16>const </span><span class=prg>DWORD </span>amarelo  = <span class=sc4>0xFFFFFF00</span>; 

<span class=sc2>// Matrizes de configuração da câmera</span>
<span class=sc5>D3DXMATRIX </span>g_mtxMundo; 
<span class=sc5>D3DXMATRIX </span>g_mtxVisao; 
<span class=sc5>D3DXMATRIX </span>g_mtxProj; 

<span class=sc2>// Controla a mudança periodica da primitiva</span>
<span class=prg>UINT </span>temporizador = <span class=sc4>0</span>; 

<span class=sc2>// initGfx() - Inicializa o Direct3D</span>
<span class=sc16>HRESULT </span>initGfx( <span class=sc16>HWND </span>hJanela ) 
<span class=sc16>{</span>
  <span class=sc2>// Cria o objeto Direct3D que é necessário para criar o dispositivo gráfico</span>
  g_Direct3d = <span class=prg>Direct3DCreate9</span>( <span class=sc4>D3D_SDK_VERSION</span>);  

  <span class=sc2>// Verifica se o objeto Direct3D foi criado</span>
  <span class=sc9>if</span>(g_Direct3d == <span class=prg>NULL</span>)  
  <span class=sc16>{</span>
    <span class=prg>MessageBox </span>(<span class=prg>NULL</span>, 
      <span class=sc6>"Falha na inialização do Direct3D"</span>, <span class=sc6>"InitGfx</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
    <span class=sc6>return </span><span class=sc4>E_FAIL</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=sc2>// Declara  a variável para os parâmetros de apresentação</span>
  <span class=sc5>D3DPRESENT_PARAMETERS </span>pps; 

  <span class=sc2>// Limpa a estrutura</span>
  <span class=prg>ZeroMemory</span>( &pps, <span class=sc16>sizeof</span>(pps) );  

  <span class=sc2>// Configura os parâmetros de apresentação</span>
  <span class=sc2>// A aplicação vai ter janela</span>
  <span class=prg>pps.Windowed </span>= <span class=prg>TRUE</span>; 

  <span class=sc2>// Esse método transfere rapidamente o backbuffer para a tela imediata</span>
  <span class=prg>pps.SwapEffect </span>= <span class=sc4>D3DSWAPEFFECT_DISCARD</span>; 

  <span class=sc2>// Esse formato vai procurar se encaixar no modo de video corrente</span>
  <span class=prg>pps.BackBufferFormat </span>= <span class=sc4>D3DFMT_UNKNOWN</span>; 

  <span class=sc2>// Configuração do renderizador a ser criado</span>
  <span class=sc2>// Adaptador default (0)</span>
  <span class=prg>int </span>nAdaptador = <span class=sc4>D3DADAPTER_DEFAULT</span>; 

  <span class=sc2>// Tipo de dispositivo Hardware ou emulador de referência (software)</span>
  <span class=prg>D3DDEVTYPE </span>dispositivo_tipo = <span class=sc4>D3DDEVTYPE_HAL</span>; 

  <span class=sc2>// Flags de configuração do dispositivo</span>
  <span class=prg>DWORD </span>create_flags = <span class=sc4>D3DCREATE_SOFTWARE_VERTEXPROCESSING</span>; 

  <span class=sc2>// Criamos aqui o dispositivo renderizador</span>
  g_hr = <span class=prg>g_Direct3d-&gt;CreateDevice</span>( nAdaptador, dispositivo_tipo, 
    hJanela, create_flags, &pps, &g_device );  

  <span class=sc2>// Verifica se houve falha no processo</span>
  <span class=sc9>if</span>( <span class=prg>FAILED</span>( g_hr ) ) <span class=sc16>{</span>
    <span class=prg>MessageBox </span>(<span class=prg>NULL</span>, <span class=sc6>"Falha na criação: g_device"</span>, <span class=sc6>"initGfx</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
    <span class=sc6>return </span><span class=sc4>E_FAIL</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=sc2>// Inicializa o vertexbuffer</span>
  inicializar_Buffers();  

  <span class=sc2>// Configura o posicionamento dos vértices</span>
  montar_Geometria();  

  <span class=sc2>// Inicializa a câmera</span>
  inicializar_Camera();  

  <span class=sc2>// Habilita iluminação default</span>
  <span class=prg>g_device-&gt;SetRenderState </span>(<span class=sc4>D3DRS_LIGHTING</span>, <span class=prg>false</span>);  

  <span class=sc6>return </span><span class=sc4>S_OK</span>; 
<span class=sc16>} <span class=sc2>// initGfx().fim</span></span>


<span class=prg>void </span>inicializar_Buffers(<span class=prg>void</span>)  
<span class=sc16>{</span>
  <span class=sc2>// Tamanho do vertexbuffer em bytes</span>
  <span class=prg>UINT </span> vbTamanho = <span class=sc16>sizeof</span>(<span class=sc5>CustomVertex_PositionColored</span>)  * g_nVerticesQtd; 

  <span class=sc2>// Dica de uso.</span>
  <span class=prg>DWORD </span> uso_flags = <span class=sc4>D3DUSAGE_WRITEONLY</span>; 

  <span class=sc2>// Formato do vértice dos vértices do vertexbuffer</span>
  <span class=prg>DWORD </span> vbFormato = <span class=sc4>CustomVertex_PositionColored_Format</span>; 

  <span class=sc2>// Definição da classe de memória (alojamento)</span>
  <span class=sc4>D3DPOOL </span>Piscina  = <span class=sc4>D3DPOOL_MANAGED</span>; 

  <span class=sc2>// Criação efetiva do buffer de vértices (vertexbuffer)</span>
  g_hr = <span class=prg>g_device-&gt;CreateVertexBuffer</span>(vbTamanho, uso_flags, 
    vbFormato, Piscina, &g_vbVertices, <span class=prg>NULL</span>);   

  <span class=sc2>// Verifica falha na criação</span>
  <span class=sc9>if</span>(<span class=prg>FAILED </span>(g_hr) ) <span class=sc16>{</span>
    <span class=prg>MessageBox </span>(<span class=prg>NULL</span>, 
      <span class=sc6>"Falha na criação do buffer de vértices"</span>, 
      <span class=sc6>"inicializar_Buffers</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
    <span class=sc6>return</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>
<span class=sc16>} <span class=sc2>// inicializar_Buffers().fim</span></span>


<span class=prg>void </span>montar_Geometria(<span class=prg>void</span>)  
<span class=sc16>{</span>
  <span class=sc2>// Variáveis para configuração do posicionamento dos vértices</span>
  <span class=prg>float </span>xcol = <span class=sc4>0.0f</span>; 
  <span class=prg>float </span>ylin = <span class=sc4>0.0f</span>; 
  <span class=prg>float </span>zpos = <span class=sc4>0.0f</span>; 

  <span class=sc2>// Utilizado para controlar o índice do vértice</span>
  <span class=prg>UINT </span>ndx = <span class=sc4>0</span>; 

  <span class=sc2>// Distribuição circular dos vértices no espaço</span>
  <span class=prg>UINT </span>passo = 360 / g_nVerticesQtd; 

  <span class=sc2>// Ponteiro de acesso aos dados do buffer de vértices</span>
  <span class=sc5>CustomVertex_PositionColored </span>*pVerts; 

  <span class=sc2>// Aqui a aplicação ganha acesso à memória do buffer de vértices</span>
  <span class=prg>g_vbVertices-&gt;Lock</span>( <span class=sc4>0</span>, <span class=sc4>0</span>, (<span class=prg>void**</span>) &pVerts, <span class=sc4>0</span>);  

  <span class=sc2>// Vamos posicionar os vértices em círculo</span>
  <span class=prg>for </span>(<span class=prg>float </span>ncx = <span class=sc4>0.0f</span>; ncx &lt;= <span class=sc4>360.0f</span>; ncx += passo) 
  <span class=sc16>{</span>
    <span class=sc2>// Converte graus para radianos</span>
    <span class=prg>double </span>radianos = ncx * (<span class=sc4>D3DX_PI </span>/ <span class=sc4>180.0f</span>);   

    <span class=sc2>// Tamanho do círculo</span>
    <span class=prg>float </span>nRaio = <span class=sc4>2.0f</span>; 

    <span class=sc2>// (x,y) distribuidos de maneira circular</span>
    xcol = (<span class=prg>float</span>)  <span class=prg>cos</span>(radianos) * nRaio; 
    ylin = (<span class=prg>float</span>)  <span class=prg>sin</span>(radianos) * nRaio; 

    <span class=sc2>// Posicionamento do vértice</span>
    pVerts[ndx] = <span class=sc5>CustomVertex_PositionColored</span>( xcol, ylin, zpos, vermelho);  

    <span class=sc2>// Coloca no centro o terceiro vértice de cada triângulo</span>
    <span class=sc9>if </span>(ndx % <span class=sc4>3 </span>== <span class=sc4>0</span>)  
      pVerts[ndx] = <span class=sc5>CustomVertex_PositionColored</span>( <span class=sc4>0</span>, <span class=sc4>0</span>, zpos, amarelo);  

    <span class=sc2>// Atualiza índice de controle do vértice</span>
    ndx = ndx + <span class=sc4>1</span>; 

  <span class=sc16>} <span class=sc2>// endfor</span></span>

  <span class=sc2>// Liberação do vertexbuffer</span>
  <span class=prg>g_vbVertices-&gt;Unlock</span>();  

<span class=sc16>} <span class=sc2>//  montar_Geometria().fim</span></span>


<span class=prg>void </span>renderizar_Geometria() 
<span class=sc16>{</span>
  <span class=sc2>// Mensagens para a barra de títulos da janela</span>
  <span class=prg>char </span>*mensagem[] = <span class=sc16>{</span>
    <span class=sc6>"prj_Primitivas: D3DPT_POINTLIST"</span>, <span class=sc6>"prj_Primitivas: D3DPT_LINELIST"</span>, 
    <span class=sc6>"prj_Primitivas: D3DPT_LINESTRIP"</span>, <span class=sc6>"prj_Primitivas: D3DPT_TRIANGLELIST"</span>, 
    <span class=sc6>"prj_Primitivas: D3DPT_TRIANGLESTRIP"</span>, <span class=sc6>"prj_Primitivas: D3DPT_TRIANGLEFAN" </span><span class=sc16>}</span>; 

    <span class=sc2>// Produz a cada dois segundos um valor de 0 a 5.</span>
    temporizador = ( <span class=prg>clock</span>() / 2000 ) % <span class=sc4>6</span>; 

    <span class=sc2>// Configura o texto da janela</span>
    config_texto( mensagem[temporizador]);  

    <span class=sc2>// Declara o formato de vértice utilizado pela aplicação</span>
    <span class=prg>g_device-&gt;SetFVF</span>( <span class=sc4>CustomVertex_PositionColored_Format</span>);  

    <span class=sc2>// Configura tamanho do ponto para a renderização em  D3DPT_POINTLIST</span>
    <span class=prg>float </span>nTamanho = <span class=sc4>10.0f</span>; 
    <span class=prg>g_device-&gt;SetRenderState</span>(<span class=sc4>D3DRS_POINTSIZE</span>, *(( <span class=prg>DWORD*</span>)  &nTamanho ));  

    <span class=sc2>// Informação do buffer de vértices utilizado</span>
    <span class=prg>g_device-&gt;SetStreamSource</span>( <span class=sc4>0</span>, g_vbVertices, <span class=sc4>0</span>, 
                      <span class=sc16>sizeof</span>(<span class=sc5>CustomVertex_PositionColored</span>) );  

    <span class=sc2>// Renderiza a primitiva selecionada pelo tempo decorrido</span>
    <span class=sc9>switch</span>( temporizador ) 
    <span class=sc16>{</span>
    <span class=sc9>case </span>0: 
      <span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_POINTLIST</span>, <span class=sc4>0</span>, g_nVerticesQtd);  
      <span class=sc6>break</span>; 

    <span class=sc9>case </span>1: 
      <span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_LINELIST</span>, <span class=sc4>0</span>, g_nVerticesQtd / <span class=sc4>2</span>);   
      <span class=sc6>break</span>; 

    <span class=sc9>case </span>2: 
      <span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_LINESTRIP</span>, <span class=sc4>0</span>, g_nVerticesQtd - <span class=sc4>1</span>);   
      <span class=sc6>break</span>; 

    <span class=sc9>case </span>3: 
      <span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_TRIANGLELIST</span>, <span class=sc4>0</span>, g_nVerticesQtd / <span class=sc4>3</span>);   
      <span class=sc6>break</span>; 

    <span class=sc9>case </span>4: 
      <span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_TRIANGLESTRIP</span>, <span class=sc4>0</span>, g_nVerticesQtd - <span class=sc4>2</span>);   
      <span class=sc6>break</span>; 

    <span class=sc9>case </span>5: 
      <span class=prg>g_device-&gt;DrawPrimitive</span>( <span class=sc4>D3DPT_TRIANGLEFAN</span>, <span class=sc4>0</span>, g_nVerticesQtd - <span class=sc4>2</span>);   
      <span class=sc6>break</span>; 

    <span class=sc16>} <span class=sc2>// fim do switch</span></span>
<span class=sc16>} <span class=sc2>// renderizar_Geometria().fim</span></span>


<span class=sc2>//  Esta função é chamada por DispatchMessage()</span>
<span class=sc16>LRESULT </span><span class=sc16>CALLBACK </span>processaJanela (<span class=sc16>HWND </span>hJanela, <span class=prg>UINT </span>mensagem, 
                                 <span class=sc16>WPARAM </span>wParam, <span class=sc16>LPARAM </span>lParam) 
<span class=sc16>{</span>
  <span class=sc9>switch </span>(mensagem) 
  <span class=sc16>{</span>
  <span class=sc9>case </span><span class=sc4>WM_DESTROY:</span>
    <span class=sc2>// Coloca uma mensagem WM_QUIT na fila de mensagem</span>
    Limpar();  
    <span class=prg>PostQuitMessage </span>(<span class=sc4>0</span>);   
    <span class=sc6>break</span>; 

  <span class=sc9>case </span><span class=sc4>WM_KEYDOWN:</span>
    <span class=sc9>if </span>(wParam == <span class=sc4>VK_ESCAPE</span>)  
    <span class=sc16>{</span>
      Limpar();  
      <span class=prg>PostQuitMessage</span>( <span class=sc4>0</span>);  
    <span class=sc16>} <span class=sc2>// endif</span></span>
    <span class=sc6>break</span>; 

    <span class=sc2>// Essa mensagem vai ocorrer a todo momento</span>
  <span class=sc9>case </span><span class=sc4>WM_PAINT:</span>
    <span class=sc2>// Renderiza a cena</span>
    Renderizar();  
    <span class=sc2>// Invalida a tela para chamar WM_PAINT novamente</span>
    <span class=prg>InvalidateRect</span>( hJanela, <span class=prg>NULL</span>, <span class=prg>false</span>);  
    <span class=sc6>break</span>; 

    <span class=sc2>// Processamento default de mensagens não tratada pela aplicação</span>
  <span class=sc9>default:</span>
    <span class=sc6>return </span><span class=prg>DefWindowProc </span>(hJanela, mensagem, wParam, lParam);  
  <span class=sc16>} <span class=sc2>// endswitch</span></span>

  <span class=sc6>return </span><span class=sc4>0</span>; 
<span class=sc16>} <span class=sc2>// processaJanela().fim</span></span>

<span class=sc2>// Limpar() -  Libera todos os objetos previamente inicializados</span>
<span class=sc2>// -----------------------------------------------------------------------------</span>
<span class=prg>VOID </span>Limpar() 
<span class=sc16>{</span>
  <span class=sc2>// Libera o buffer de vértices</span>
  <span class=sc9>if</span>( g_vbVertices != <span class=prg>NULL</span>)  <span class=prg>g_vbVertices-&gt;Release</span>();  

  <span class=sc2>// Libera o dispositivo gráfico</span>
  <span class=sc9>if</span>( g_device != <span class=prg>NULL</span>)  <span class=prg>g_device-&gt;Release</span>();  

  <span class=sc2>// Libera o motor do Direct3D</span>
  <span class=sc9>if</span>( g_Direct3d != <span class=prg>NULL</span>)  <span class=prg>g_Direct3d-&gt;Release</span>();  

  <span class=sc2>// Limpa os ponteiros</span>
  g_vbVertices = <span class=prg>NULL</span>; 
  g_device   = <span class=prg>NULL</span>; 
  g_Direct3d  = <span class=prg>NULL</span>; 

<span class=sc16>} <span class=sc2>// Limpar().fim</span></span>


<span class=sc2>// -----------------------------------------------------------------------------</span>
<span class=sc2>// Renderizar() - Desenha a cena</span>
<span class=sc2>// -----------------------------------------------------------------------------</span>
<span class=prg>VOID </span>Renderizar() 
<span class=sc16>{</span>
  <span class=sc2>// Retorne se o dispositivo estiver nulo</span>
  <span class=sc9>if</span>( g_device == <span class=prg>NULL</span>)  <span class=sc6>return</span>; 

  <span class=sc2>// Limpa o backbuffer com uma cor branca</span>
  <span class=prg>g_device-&gt;Clear</span>( <span class=sc4>0</span>, <span class=prg>NULL</span>, <span class=sc4>D3DCLEAR_TARGET</span>, branco, <span class=sc4>1.0f</span>, <span class=sc4>0</span>);   

  <span class=sc2>// Começa a cena</span>
  <span class=sc9>if</span>( <span class=prg>SUCCEEDED</span>( <span class=prg>g_device-&gt;BeginScene</span>() ) ) 
  <span class=sc16>{</span>

    <span class=sc2>// Vamos renderizar a geometria</span>
    renderizar_Geometria();  

    <span class=sc2>// Finalizando a cena</span>
    <span class=prg>g_device-&gt;EndScene</span>();  
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=sc2>// Apresenta o conteúdo do backbuffer na tela</span>
  <span class=prg>g_device-&gt;Present</span>( <span class=prg>NULL</span>, <span class=prg>NULL</span>, <span class=prg>NULL</span>, <span class=prg>NULL</span>);  

<span class=sc16>} <span class=sc2>// Renderizar().fim</span></span>

<span class=prg>void </span>inicializar_Camera(<span class=prg>void</span>)  
<span class=sc16>{</span>
  <span class=sc2>// ***************************************************************************</span>
  <span class=sc2>// Inicializa todas as matrizes para elemento neutro</span>
  <span class=prg>D3DXMatrixIdentity</span>( &g_mtxMundo );  
  <span class=prg>D3DXMatrixIdentity</span>( &g_mtxVisao );  
  <span class=prg>D3DXMatrixIdentity</span>( &g_mtxProj );  

  <span class=sc2>// ***************************************************************************</span>
  <span class=sc2>// Configura a matriz de mundo no dispositivo renderizador</span>
  <span class=prg>g_device-&gt;SetTransform</span>( <span class=sc4>D3DTS_WORLD</span>, &g_mtxMundo );  

  <span class=sc2>// ***************************************************************************</span>
  <span class=sc2>// Dados para a configuração da matriz de visualização</span>
  <span class=sc2>// Aonde está a câmera? - posição da câmera</span>
  <span class=sc5>D3DXVECTOR3 </span>cam_pos (<span class=sc4>0.0f</span>, <span class=sc4>0.0f</span>, <span class=sc4>5.0f</span>);   
  <span class=sc2>// Para aonde a câmera está apontada ou olhando? Alvo da câmera</span>
  <span class=sc5>D3DXVECTOR3 </span>cam_alvo (<span class=sc4>0.0f</span>, <span class=sc4>0.0f</span>, <span class=sc4>0</span>);   
  <span class=sc2>// A câmera está de cabeça pra baixo? - orientação da câmera</span>
  <span class=sc5>D3DXVECTOR3 </span>cam_vetorcima (<span class=sc4>0.0f</span>, <span class=sc4>1.0f</span>, <span class=sc4>0.0f</span>);   

  <span class=sc2>// Configura a matriz de visão</span>
  <span class=prg>D3DXMatrixLookAtLH</span>( &g_mtxVisao, &cam_pos, &cam_alvo, &cam_vetorcima );  

  <span class=sc2>// Configura a matriz de visão no dispositivo renderizador</span>
  <span class=prg>g_device-&gt;SetTransform</span>( <span class=sc4>D3DTS_VIEW</span>, &g_mtxVisao );  

  <span class=sc2>// ***************************************************************************</span>
  <span class=sc2>// Argumentos de configuração da matriz de projeção</span>
  <span class=sc2>// aspecto dos gráficos</span>
  <span class=prg>float </span>aspecto = (<span class=prg>float</span>)   g_xtela / g_ytela; 
  <span class=sc2>// campo de visão</span>
  <span class=prg>float </span>campo_visao = <span class=sc4>D3DX_PI </span>/ <span class=sc4>4</span>; 
  <span class=sc2>// Trapézio de visualização da câmera ( Frustrum )</span>
  <span class=prg>float </span>corte_perto = <span class=sc4>1.0f</span>; 
  <span class=prg>float </span>corte_longe = <span class=sc4>1000.0f</span>; 

  <span class=sc2>// Configura a matriz de projeção</span>
  <span class=prg>D3DXMatrixPerspectiveFovLH</span>( &g_mtxProj, campo_visao, aspecto, 
    corte_perto, corte_longe);  

  <span class=sc2>// Configura a matriz de projeção no dispositivo renderizador</span>
  <span class=prg>g_device-&gt;SetTransform</span>( <span class=sc4>D3DTS_PROJECTION</span>, &g_mtxProj );  

<span class=sc16>} <span class=sc2>// inicializar_Camera().fim</span></span>

<span class=prg>void </span>config_texto( <span class=prg>char </span>*texto) 
<span class=sc16>{</span>
  <span class=sc2>// Pega o texto atual da janela</span>
  <span class=prg>char </span>temp_txt[80];  
  <span class=prg>GetWindowText </span>(hJanela, temp_txt, 80);  

  <span class=sc2>// Configura apenas se o texto de entrada for diferente</span>
  <span class=sc2>// do texto que está na janela</span>
  <span class=sc2>// Isto é para evitar efeitos visual desagradável na barra</span>
  <span class=sc2>// de título da janela.</span>
  <span class=sc9>if </span>(strcmp (temp_txt, texto)) 
    <span class=prg>SetWindowText </span>(hJanela, texto);  

<span class=sc16>} <span class=sc2>// config_texto().fim</span></span>
</div>

<div class=prg-code>//-----------------------------------------------------------------------------</span>
<span class=sc2>// Projeto: prj_Primitivas - arquivo: entrada.cpp</span>
<span class=sc2>// Esta aplicação mostra como renderizar as formas primitivas</span>
<span class=sc2>// By www.gameprog.com.br</span>
//-----------------------------------------------------------------------------</span>
<span class=sc16>#include </span><span class=prg>&lt;windows.h&gt;</span>
<span class=sc16>#include </span><span class=prg>&lt;d3d9.h&gt;</span>
<span class=sc16>#include </span><span class=prg>&lt;d3dx9.h&gt;</span>
<span class=sc16>#include </span><span class=sc6>"motor.h"</span>

<span class=sc2>// Variável global da classe da janela</span>
<span class=prg>char </span>sclasseJanela[ ] = <span class=sc6>"cls_directx"</span>; 

<span class=sc2>// Dimensões da janela</span>
<span class=prg>int </span>g_xtela = 640; 
<span class=prg>int </span>g_ytela = 480; 

<span class=sc2>// Handle (alça) da janela</span>
<span class=sc16>HWND </span>hJanela; 

<span class=prg>int </span><span class=sc16>WINAPI </span><span class=prg>WinMain </span>(<span class=sc16>HINSTANCE </span>app_instancia, <span class=sc16>HINSTANCE </span>app_anterior, 
                    <span class=prg>LPSTR </span>sComando,<span class=prg>int </span>nExibir) <span class=sc16>{</span>

  <span class=sc2>// Estrutura de recepção das mensagens</span>
  <span class=sc5>MSG </span>mensagem; 

  <span class=sc2>// Estrutura de descrição da janela</span>
  <span class=sc5>WNDCLASSEX </span>wcls; 

  <span class=sc2>// Estrutura que descreve a janela</span>
  <span class=prg>wcls.hInstance </span>= app_instancia; 
  <span class=prg>wcls.lpszClassName </span>= sclasseJanela; 
  <span class=prg>wcls.lpfnWndProc </span>= processaJanela; 
  <span class=prg>wcls.style </span>= <span class=sc4>CS_HREDRAW </span>| <span class=sc4>CS_VREDRAW</span>; 
  <span class=prg>wcls.cbSize </span>= <span class=sc16>sizeof </span>(<span class=sc5>WNDCLASSEX</span>);   

  <span class=sc2>// O cursor e os ícones da aplicação são default</span>
  <span class=prg>wcls.hIcon </span>  = <span class=prg>LoadIcon </span>(<span class=prg>NULL</span>, <span class=sc4>IDI_APPLICATION</span>);   
  <span class=prg>wcls.hIconSm </span>= <span class=prg>LoadIcon </span>(<span class=prg>NULL</span>, <span class=sc4>IDI_APPLICATION</span>);   
  <span class=prg>wcls.hCursor </span>= <span class=prg>LoadCursor </span>(<span class=prg>NULL</span>, <span class=sc4>IDC_ARROW</span>);   

  <span class=sc2>// Aplicação sem menu</span>
  <span class=prg>wcls.lpszMenuName </span>= <span class=prg>NULL</span>; 

  <span class=sc2>// Nada de espaço extra atrelado a classe da janela (wcls)</span>
  <span class=prg>wcls.cbClsExtra </span>= <span class=sc4>0</span>; 

  <span class=sc2>// Nada de espaço extra atrelado a janela</span>
  <span class=prg>wcls.cbWndExtra </span>= <span class=sc4>0</span>; 

  <span class=sc2>// Cor default da janela</span>
  <span class=prg>wcls.hbrBackground </span>= ( <span class=sc16>HBRUSH</span>) <span class=sc4>COLOR_BACKGROUND</span>; 

  <span class=sc2>// Registra a janela e retorna se esta operação falhar</span>
  <span class=prg>int </span>status = <span class=prg>RegisterClassEx </span>(&wcls);  
  <span class=sc9>if</span>(status == <span class=sc4>0</span>)  <span class=sc16>{</span>
  <span class=prg>MessageBox</span>(<span class=prg>NULL</span>, <span class=sc6>"Registro falhou!"</span>, <span class=sc6>"WinMain</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
  <span class=sc6>return </span><span class=sc4>0</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=sc2>// Com a classe criada pode-se criar a janela</span>
  <span class=prg>DWORD </span>estiloExtra = <span class=sc4>0</span>; 
  <span class=sc16>const </span><span class=prg>char </span>janelaTitulo[] = <span class=sc6>"prj_Primitivas"</span>; 
  <span class=prg>DWORD </span>controleEstilo = <span class=sc4>WS_OVERLAPPED </span>| <span class=sc4>WS_SYSMENU </span>| <span class=sc4>WS_MINIMIZEBOX</span>; 
  <span class=prg>int </span>xpos = 160; 
  <span class=prg>int </span>ypos = 120; 
  <span class=sc16>HWND </span>hjanelaPai = <span class=sc16>HWND_DESKTOP</span>; 
  <span class=sc16>HMENU </span>sem_menu = <span class=prg>NULL</span>; 
  <span class=prg>LPVOID </span>dadoExtra = <span class=prg>NULL</span>; 

  <span class=sc2>// Cria a janela</span>
  hJanela = <span class=prg>CreateWindowEx</span>(estiloExtra, sclasseJanela, janelaTitulo, 
    controleEstilo, xpos, xpos,  g_xtela, g_ytela, hjanelaPai, sem_menu, 
    app_instancia, dadoExtra );  

  <span class=sc2>// Verifica se janela foi criada</span>
  <span class=sc9>if</span>(hJanela == <span class=prg>NULL</span>)  <span class=sc16>{</span>
  <span class=prg>MessageBox</span>(<span class=prg>NULL</span>, <span class=sc6>"Falha na criação da janela!"</span>, <span class=sc6>"WinMain</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
  <span class=sc6>return </span><span class=sc4>0</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=sc2>// Essa variável recebe informação de erro do Directx</span>
  <span class=sc16>HRESULT </span>hr; 
  <span class=sc2>// Inicia o Direct3D</span>
  hr = initGfx ( hJanela );  

  <span class=sc2>// Encerre a aplicação se houve falha</span>
  <span class=sc9>if</span>(<span class=prg>FAILED </span>(hr) ) <span class=sc16>{</span>
    <span class=prg>MessageBox </span>(hJanela, 
      <span class=sc6>"Direct3D: falha na inicialização"</span>, <span class=sc6>"WinMain</span>()<span class=sc6>"</span>, <span class=sc4>MB_OK</span>);   
    <span class=prg>UnregisterClass</span>( sclasseJanela, <span class=prg>wcls.hInstance</span>);  
    <span class=sc6>return </span><span class=sc4>E_FAIL</span>; 
  <span class=sc16>} <span class=sc2>// endif</span></span>

  <span class=sc2>// Mostra a janela</span>
  <span class=prg>ShowWindow</span>(hJanela, nExibir);  
  <span class=prg>UpdateWindow</span>(hJanela );  

  <span class=sc2>// Rode a bombeamento de mensagens até GetMessage() retornar 0</span>
  <span class=sc9>while </span>(<span class=prg>GetMessage</span>(&mensagem, <span class=prg>NULL</span>, <span class=sc4>0</span>, <span class=sc4>0</span>)) 
  <span class=sc16>{</span>
    <span class=sc2>// Traduz mensagem de tecla virtual em mensagem de caracteres</span>
    <span class=prg>TranslateMessage</span>( &mensagem );  

    <span class=sc2>// Despacha a mensagem para a função  processaJanela */</span>
    <span class=prg>DispatchMessage</span>( &mensagem );  
  <span class=sc16>} <span class=sc2>// endwhile</span></span>

  <span class=sc2>// O valor de retorno é zero(0) passado por PostQuitMessage()</span>
  <span class=prg>UnregisterClass</span>( sclasseJanela, <span class=prg>wcls.hInstance</span>);  
  <span class=sc6>return </span><span class=prg>mensagem.wParam</span>; 
<span class=sc16>} <span class=sc2>// WinMain().fim</span></span>
</div>
<hr>
<table align='bottom' border='0' cellspacing='0' cellpadding='0' width='20%'>
<tr><td><a href='dx9cpp.html#start' style='color:blue'> index </a></td>
<td><a href='track03-6.html' style='color:blue'>&lt;&lt;</a></td>
<td><a href='track04-2.html' style='color:blue'>&gt;&gt;</a></td></tr></table><pre>
<hr><div style='background-color:lightyellow;color:blue'>
<center>Produzido por Gameprog: Jair Pereira - Agosto/2014 ©
gameprog.br@gmail.com
<a href='http://www.gameprog.com.br'>http://www.gameprog.com.br</center><hr></div></div></body></html>