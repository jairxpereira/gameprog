<html><head>
<title>cbiblioteca_track07_graphics</title>
<style type="text/css">

span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc2 {
	color: #008000;
}
.sc4 {
	color: #ff8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #FF0000;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #400080;
}

.prg {
	color: #0000FF;
}
</style></head>
<body><font color="black"><pre>
<hr>
<center><b>GAMEPROG - Escola de programação de jogos digitais</b><br><b>Contato: Jair Pereira - gameprog.br@gmail.com</b><br><b>Guia completo de referência da biblioteca padrão da Linguagem C [Borland Turbo C/++ ver 3.1]</b><br><b>track07.html</b><br></center><table align=bottom border=0 cellspacing=0 cellpadding=0 width=20%><tr><td><a href=cbiblioteca.html style='color:blue'> index </a></td><td><a href='track06.html'style='color:blue'>&lt;&lt;</a></td><td><a href='track08.html'style='color:blue'>&gt;&gt;</a></td></tr></table>
<HR>
<A NAME="7.00"></A>
<CENTER><H2>7.00 graphics.h</H2></CENTER>
<A HREF="#7.01">7.01</a> arc...............Desenha um arco
<A HREF="#7.02">7.02</a> bar...............Desenha uma barra
<A HREF="#7.03">7.03</a> bar3d.............Desenha uma barra 3d
<A HREF="#7.04">7.04</a> circle............Desenha um círculo na coordenada especificada
<A HREF="#7.05">7.05</a> cleardevice.......Limpa completamente a tela em modo gráfico
<A HREF="#7.06">7.06</a> clearviewport.....Limpa a janela gráfica
<A HREF="#7.07">7.07</a> closegraph........Encerra o modo gráfico, aciona o modo texto.
<A HREF="#7.08">7.08</a> detectgraph.......Pesquisa o hardware e determina o melhor driver e modo gráfico
<A HREF="#7.09">7.09</a> drawpoly..........Desenha um polígono
<A HREF="#7.10">7.10</a> ellipse...........Desenha uma elipse na coordenada especificada
<A HREF="#7.11">7.11</a> fillellipse.......Preenche com um estilo uma área elíptica ou circular
<A HREF="#7.12">7.12</a> fillpoly..........Preenche com um estilo uma área polígonal

<A HREF="#7.13">7.13</a> floodfill.........Preenche com um estilo uma área
<A HREF="#7.14">7.14</a> getarccoords......Obtém as coordenadas do último arco desenhado
<A HREF="#7.15">7.15</a> getaspectratio....Obtém a razão do aspecto da tela
<A HREF="#7.16">7.16</a> getbkcolor........Obtém a cor de fundo atual
<A HREF="#7.17">7.17</a> getcolor..........Obtém a cor de frente atual
<A HREF="#7.18">7.18</a> getdefaultpalette.Obtém a palheta default do driver gráfico corrente
<A HREF="#7.19">7.19</a> getdrivername.....Obtém o nome do driver gráfico corrente
<A HREF="#7.20">7.20</a> getfillpattern....Obtém string sUserStyle que é a configuração de estilo do usuário
<A HREF="#7.21">7.21</a> getfillsettings...Obtém a configuração de preenchimento pré-definido
<A HREF="#7.22">7.22</a> getgraphmode......Obtém o valor do modo gráfico corrente
<A HREF="#7.23">7.23</a> getimage..........Captura uma imagem da tela

<A HREF="#7.24">7.24</a> getlinesettings...Obtém configuração de linha
<A HREF="#7.25">7.25</a> getmaxcolor.......Obtém o maior valor de cor possível
<A HREF="#7.26">7.26</a> getmaxmode........Obtém o maior valor de modo de vídeo possível</A>
<A HREF="#7.27">7.27</a> getmaxx...........Obtém o valor máximo da coordenada absoluta x
<A HREF="#7.28">7.28</a> getmaxy...........Obtém o valor máximo da coordenada absoluta y
<A HREF="#7.29">7.29</a> getmodename.......Obtém o nome do modo gráfico corrente
<A HREF="#7.30">7.30</a> getmoderange......Obtém o valor do modo de vídeo baixa e alta resolução
<A HREF="#7.31">7.31</a> getpalette........Obtém os valores da palheta cores para cada registro de cor
<A HREF="#7.32">7.32</a> getpalettesize....Obtém o tamanho da palheta de cores
<A HREF="#7.33">7.33</a> getpixel..........Obtém a cor do pixel da coordenada fornecida
<A HREF="#7.34">7.34</a> gettextsettings...Obtém a configuração de saída de texto atual

<A HREF="#7.35">7.35</a> getviewsettings...Obtém a configuração da janela gráfica atual
<A HREF="#7.36">7.36</a> getx..............Obtém a posição corrente do cursor gráfico no eixo x
<A HREF="#7.37">7.37</a> gety..............Obtém a posição corrente do cursor gráfico no eixo y
<A HREF="#7.38">7.38</a> graphdefaults.....Restaura os valores originais da configuração gráfica
<A HREF="#7.39">7.39</a> grapherrormsg.....Obtém a mensagem de erro correspondente ao número do erro ocorrido
<A HREF="#7.40">7.40</a> _graphfreemem.....Libera memória usada pelas funções gráficas
<A HREF="#7.41">7.41</a> _graphgetmem......Requisita memória para uso das funções gráficas
<A HREF="#7.42">7.42</a> graphresult.......Retorna o código numérico do último erro numa operação gráfica
<A HREF="#7.43">7.43</a> imagesize.........Calcula o tamanho requerido de espaço para uma imagem
<A HREF="#7.44">7.44</a> initgraph.........Inicializa o modo gráfico para uso
<A HREF="#7.45">7.45</a> installuserdriver.Instala um driver gráfico de terceiros

<A HREF="#7.46">7.46</a> installuserfont...Instala uma fonte de terceiros
<A HREF="#7.47">7.47</a> line..............Desenha uma linha através da conexão de duas coordenadas
<A HREF="#7.48">7.48</a> linerel...........Desenha linha através de deslocamentos relativos
<A HREF="#7.49">7.49</a> lineto............Desenha linha conectando a posição gráfica atual com coordenada fornecida
<A HREF="#7.50">7.50</a> moverel...........Reposiciona o cursor gráfico de maneira relativa
<A HREF="#7.51">7.51</a> moveto............Reposiciona o cursor gráfico
<A HREF="#7.52">7.52</a> outtext...........Imprime strings em modo gráfico
<A HREF="#7.53">7.53</a> outtextxy.........Imprime strings em modo gráfico na coordenada especificada</A>
<A HREF="#7.54">7.54</a> pieslice..........Desenha gráfico tipo pizza (ou torta) na tela</A>
<A HREF="#7.55">7.55</a> putimage..........Apresenta uma imagem capturada com getimage() na tela
<A HREF="#7.56">7.56</a> putpixel..........Acende um pixel na tela na cor e coordenada especificada

<A HREF="#7.57">7.57</a> rectangle.........Desenha um retângulo
<A HREF="#7.58">7.58</a> registerbgidriver.Registra um driver BGI que foi linkado ao executável
<A HREF="#7.59">7.59</a> registerbgifont...Registra uma fonte linkada ao executável
<A HREF="#7.60">7.60</a> restorecrtmode....Restaura os valores de video aos originais antes de initgraph()
<A HREF="#7.61">7.61</a> sector............Desenha gráfico pizza usando ellipse
<A HREF="#7.62">7.62</a> setactivepage.....Define a página ativa de vídeo
<A HREF="#7.63">7.63</a> setallpalette.....Reconfigura toda a palheta de cores</A>
<A HREF="#7.64">7.64</a> setaspectratio....Estabelece uma nova razão de aspecto
<A HREF="#7.65">7.65</a> setbkcolor........Estabelece a cor de fundo
<A HREF="#7.66">7.66</a> setcolor..........Estabelece a cor de frente
<A HREF="#7.67">7.67</a> setfillpattern....Configura o estilo de preenchimento de área

<A HREF="#7.68">7.68</a> setfillstyle......Estabelece um estilo de preenchimento interno pré-definido
<A HREF="#7.69">7.69</a> setgraphbufsize...Redefine o tamanho do buffer gráfico
<A HREF="#7.70">7.70</a> setgraphmode......Estabelece um novo modo gráfico
<A HREF="#7.71">7.71</a> setlinestyle......Configura estilo e espessura da linha
<A HREF="#7.72">7.72</a> setpalette........Reconfigura a matiz de uma cor
<A HREF="#7.73">7.73</a> setrgbpalette.....Reconfigura a matiz de uma cor usando valores de RGB
<A HREF="#7.74">7.74</a> settextjustify....Configura justificação de texto

<A HREF="#7.75">7.75</a> settextstyle......Estabelece e configura a fonte para o modo gráfico
<A HREF="#7.76">7.76</a> setusercharsize...Estabelece o tamanho da fonte definido pelo usuário
<A HREF="#7.77">7.77</a> setviewport.......Reconfigura a janela gráfica
<A HREF="#7.78">7.78</a> setvisualpage.....Apresenta a página de vídeo fornecida na tela
<A HREF="#7.79">7.79</a> setwritemode......Define o modo de escrita de linha
<A HREF="#7.80">7.80</a> textheight........Retorna a altura da string em pixels
<A HREF="#7.81">7.81</a> textwidth.........Retorna a largura da string em pixels
.......................................................................................
<A NAME="7.01"><b>7.01 arc</b></A>
        Esta função desenha um arco tendo como centro a coordenada especificada.
        <b style="color:green">
        void far arc(int x, int y, int stangle, int endangle, int radius);
        arc(xCol,yLin, nStartAngle, nEndAngle, nRaio);</b>

        Ex.:    arc(320,240,0,180,100);

        xCol e yLin são as coordenadas do centro
        nStartAngle e nEndAngle são respectivamente ângulo inicial e
        ãngulo final, dados em graus.
        nRaio é o raio do arco.

.......................................................................................
<A NAME="7.02"><b>7.02 bar</b></A>
        Esta função desenha uma barra, usando a configuração de estilo definida
        em setfillstyle(), aplicando imediatamente este preenchimento.
        <b style="color:green">
        void far bar(int left, int top, int right, int bottom);
        bar(nLeft, nTop, nRight, nBottom);</b>

        Ex.:    bar(50,50,100,250);

.......................................................................................
<A NAME="7.03"><b>7.03 bar3d</b></A>
        Desenha uma barra 3d, usando a configuração de estilo definida em
        setfillstyle(), aplicando imediatamente este estilo.
        <b style="color:green">
        void far bar3d(int left, int top, int right, int bottom,int depth, int topflag);
        bar3d(nLeft, nTop, nRight, nBottom, nProfundidade, nCobertura);</b>

        Ex.:    bar3d(50,50,100,250,10,1);

        nProfundidade é o parâmetro que dá o efeito 3d na barra.
        nCobertura é um flag que indica se a barra vai ter topo ou não,
        seu valor pode ser zero ou um.

.......................................................................................
<A NAME="7.04"><b>7.04 circle</b></A>
        Esta função desenha um círculo na coordenada especificada.
        <b style="color:green">
        void far circle(int x, int y, int radius);
        circle(xCol,yLin,nRaio);</b>

        Ex.:    circle(320,240,80);

.......................................................................................
<A NAME="7.05"><b>7.05 cleardevice</b></A>
        Esta função limpa completamente a tela em modo gráfico.
        <b style="color:green">
        void far cleardevice(void);
        cleardevice();</b>

        Ex:     rectangle(150,110,490,370);
                setviewport(160,120,480,360);
                outtext("Testando setviewport().");
                circle(60,60,100);
                getch();
                cleardevice();

.......................................................................................
<A NAME="7.06"><b>7.06 clearviewport</b></A>
        Esta função limpa a janela gráfica, isto é, ela aplica um clrscr()
        em modo gráfico. O efeito da limpeza é parcial, pois só atinge a
        região da janela gráfica.
        <b style="color:green">
        void far clearviewport(void);
        clearviewport();</b>

        Ex:     rectangle(150,110,490,370);
                setviewport(160,120,480,360);
                outtext("Testando setviewport().");
                circle(60,60,100);
                getch();
                clearviewport();

.......................................................................................
<A NAME="7.07"><b>7.07 closegraph</b></A>
        Esta função encerra o modo gráfico, e aciona o modo texto.
        <b style="color:green">
        void far closegraph(void);
        closesegraph();</b>

        Ex.:    closegraph();

.......................................................................................
<A NAME="7.08"><b>7.08 detectgraph</b></A>
        Esta função pesquisa o hardware e determina o melhor driver gráfico
        e o modo de vídeo com a resolução mais alta que seu sistema suporte
        em modo MsDos.
        <b style="color:green">
        void far detectgraph(int far *graphdriver, int far *graphmode);
        detectgraph(&nDriver,&nMode);</b>

        Ex.:    int nDriver, nMode;
                detectgraph(&nDrive,&nMode);
                printf("Melhor driver: %d\n",nDriver);
                printf("Melhor modo:   %d\n",nMode);
                /* Resulta em
                                Melhor driver: 9
                                Melhor modo:   2        */

.......................................................................................
<A NAME="7.09"><b>7.09 drawpoly</b></A>
        Esta função desenha um polígono através da conexão sucessiva de
        vários pontos declarados numa array.
        <b style="color:green">
        void far drawpoly(int numpoints, int far polypoints[]);
        drawpoly(nPoints, &nPoly[]);</b>

        nPoints.........Número de pontos que tem o polígono. Cada ponto deve corresponder
                        a uma coordenada (x,y) presente na array nPoly[].
        nPoly...........Array de coordenadas consecutivas que formam o polígono.

        Ex.:    int nPoly[]={240,240,400,240,320,160,240,240};
                drawpoly(4,&nPoly);

        Nosso exemplo desenha um triângulo com o último ponto se encontrando com
        o primeiro para fechar o polígono.

.......................................................................................
<A NAME="7.10"><b>7.10 ellipse</b></A>
        Esta função desenha uma elipse tendo como centro a coordenada especificada.
        <b style="color:green">
        void far ellipse(int x, int y, int stangle, int endangle,
                                        int xradius, int yradius);

        ellipse(int xCol,yLin,nStartAngle, nEndAngle, xRadius, yRadius);</b>

        Ex.:    ellipse(320,240,0,360,110,130);

        xCol e yLine definem o centro da elipse.
        nStartAngle e nEndAngle são respectivamente ângulo inicial e
        ângulo final que são dados em graus.
        xRadius é o raio horizontal da elipse, yRadius é o raio vertical da
        elipse.Você definindo o mesmo valor para estes raios você desenha
        um circulo.

.......................................................................................
<A NAME="7.11"><b>7.11 fillellipse</b></A>
        Esta função preenche com um estilo uma área elíptica ou circular.
        <b style="color:green">
        void far fillellipse(int x, int y,int xradius, int yradius);

        fillellipse(int xCol,yLin,xRadius, yRadius);</b>

        Ex.:    fillellipse(320,240,110,130);

        Na verdade esta função não leva em consideração se há uma elipse desenhada
        na área fornecida. Ela simplesmente desenha uma elipse preenchida com a
        atual configuração de estilo definida por setfillpattern().
        xCol e yLine definem o centro da elipse.
        xRadius é o raio horizontal da elipse, yRadius é o raio vertical da
        elipse.Você definindo o mesmo valor para estes raios você preenche
        uma área circular.


.......................................................................................
<A NAME="7.12"><b>7.12 fillpoly</b></A>
        Esta função preenche uma área poligonal com o estilo configurado
        pela função setfillpattern().
        <b style="color:green">
        void far fillpoly(int numpoints, int far polypoint[]);
        fillpoly(nPoints, &nPoly[]);</b>

        nPoints.........Número de pontos que tem o polígono. Cada ponto deve corresponder
                        a uma coordenada (x,y) presente na array nPoly[].
        nPoly...........Array de coordenadas consecutivas que formam o polígono.

        Ex.:    int nPoly[]={240,240,400,240,320,160,240,240};
                char sUserStyle[8]={0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88};
                setfillpattern(sUserStyle,10);
                setlinestyle(SOLID_LINE,0,NORM_WIDTH);
                drawpoly(4,&nPoly);
                fillpoly(4,&nPoly)

        Nosso exemplo desenha um triângulo com o último ponto se encontrando com
        o primeiro para fechar o polígono.

.......................................................................................
<A NAME="7.13"><b>7.13 floodfill</b></A>
        Esta função preenche com o estilo definido por setfillpattern()
        uma área da tela até encontrar a cor limite.
        <b style="color:green">
        void far floodfill(int x, int y, int border);
        floodfill(xCol,yLin, nCorLimite);</b>

        Ex.:    char sUserStyle[8]={0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88};
                setfillpattern(sUserStyle,10);
                setlinestyle(SOLID_LINE,0,NORM_WIDTH);
                setcolor(14);
                rectangle(40,80,60,160);
                floofill(41,81,14);

        A linha da área demarcada deve ser sólida.
        Veja também a função setfillstyle() que trabalha com floofill().

.......................................................................................
<A NAME="7.14"><b>7.14 getarccoords</b></A>
        Esta função obtém as coordenadas do último arco desenhado.
        <b style="color:green">
        void far getarccoords(struct arccoordstype far *arccoords);
        getarccoords(&xArc);</b>

        Elementos da estrutura xArc:
        --------------------------------------------
        xArc.x ............Posição x do centro do arco
        xArc.y ............Posição y do centro do arco
        xArc.xstart .......Posição x da extremidade inicial do arco
        xArc.ystart .......Posição y da extremidade inicial do arco
        xArc.xend .........Posição x da extremidade final do arco
        xArc.yend .........Posição y da extremidade final do arco

        Ex.:    struct arccoordstype xArc;
                arc(320,240,90,180,50);
                getarccoords(&xArc);
                line(xArc.xstart, xArc.ystart, xArc.xend, xArc.yend);

.......................................................................................
<A NAME="7.15"><b>7.15 getaspectratio</b></A>
        Obtém a razão do aspecto da tela.
        <b style="color:green">
        void far getaspectratio(int far *xasp, int far *yasp);
        getaspectratio(&xAspect,&yAspect);</b>

        Ex.:    int xAspect, yAspect;
                getaspectratio(&xAspect, &yAspect);
                printf("xAspect: %d\n",xAspect);
                printf("yAspect: %d\n",yAspect);

        /* Resulta em
                        xAspect: 10000
                        yAspect: 10000  */

        Outras fontes informam que a razão do aspecto é uma relação existente
        entre o eixo x e y da tela, que descreve a resolução da tela; por
        exemplo, na resolução VGA 640x480 tal número é obtido pela divisão
        do total de colunas pelo total de linhas com a aplicação de uma outra
        variável que não é de meu conhecimento agora.

        A partir do momento que o total de linhas é diferente do total de colunas
        e que o espaçamento horizontal e vertical entre um pixel e outro é desigual
        isto dá origem a gráficos imperfeitos tal como um círculo oval, um quadrado
        retangular. Como forma de corrigir isso, outras funções obtém a razão do
        aspecto para compensar sua influência sobre as saídas gráficas.

        A Borland recomenda que na resolução VGA xAspect deve ser igual a 10000,
        quando o pixel for quadrado e xAspect menor que 10000 quando o pixel for
        retangular.

.......................................................................................
<A NAME="7.16"><b>7.16 getbkcolor</b></A>
        Esta função obtém a cor de fundo atual, em outras palavras, a cor
        do background.
        <b style="color:green">
        int far getbkcolor(void);
        nCor = getbkcolor();</b>

        Ex.:    int nCor;
                nCor = getbkcolor();

.......................................................................................
<A NAME="7.17"><b>7.17 getcolor</b></A>
        Esta função obtém a cor de frente atual.
        <b style="color:green">
        int far getcolor(void);
        nCor = getcolor();</b>

        Ex.:    int nCor;
                nCor = getcolor();

.......................................................................................
<A NAME="7.18"><b>7.18 getdefaultpalette</b></A>
        Esta função retorna um ponteiro para a palheta de cores default
        do driver gráfico corrente.
        <b style="color:green">
        struct palettetype *far getdefaultpalette(void);
        xPal = getdefaultpalette();</b>

        Veja os elementos de xPal na função getpalette().

        Ex.:    struct palettetype far *xPal= (void *) 0;
                xPal = getdefaultpalette();
                printf("Registro[01]= %d/n",xPal->color[0]);

        Lamentavelmente esta função não apresentou os resultados que ela
        devia em nossos testes. O programa exemplo da Borland também não
        retornou a palheta de cores do driver corrente.

.......................................................................................
<A NAME="7.19"><b>7.19 getdrivername</b></A>
        Esta função obtém o nome do driver gráfico corrente.
        <b style="color:green">
        char *far getdrivername(void);
        sName = getdrivername();</b>

        Ex.:    char *sName;
                sName = getdrivername();
                printf("%s\n",sName);
                /* Resulta em EGAVGA */

.......................................................................................
<A NAME="7.20"><b>7.20 getfillpattern</b></A>
        Esta função obtém a string sUserStyle (borland: far *upattern) que
        representa a configuração de estilo definida por usuário.
        <b style="color:green">
        void far getfillpattern(char far *uppattern);
        getfillpattern(sUserStyle);</b>

        Ex.:    char sBuffer[8];
                getfillpattern(sBuffer);

        Para maior domínio desta função veja a função setfillpattern();

.......................................................................................
<A NAME="7.21"><b>7.21 getfillsettings</b></A>
        Esta função obtém a configuração atual do esquema de preenchimento
        pré-definido, esta função obtém a cor e o estilo de preenchimento.
        <b style="color:green">
        void var getfillsettings(struct fillsettingstype far *fillinfo);
        getfillsettings(&xFill);</b>

        Elementos de xFill:
        ------------------------------------------------------
        int xFill.pattern...........Estilo de preenchimento
        int xFill.color.............Cor do preenchimento

        Verifique a função setfillstyle() para obter os valores possíveis
        que são retornados em xFill.pattern.

        Ex.:    struct fillsettingstype xFill;
                setfillstyle(XHATCH_FILL,12);
                getfillsettings(&xFill);
                printf("xFill.pattern: %d\n",xFill.pattern);
                printf("xFill.color: %d\n",xFill.color);
                /* Resulta em
                                xFill.pattern: 8
                                xFill.color: 12 */

.......................................................................................
<A NAME="7.22"><b>7.22 getgraphmode</b></A>
        Esta função obtém o valor do modo gráfico corrente.
        <b style="color:green">
        int far getgraphmode(void);
        nMode = getgraphmode();</b>

        Ex.:    int nMode;
                nMode = getgraphmode();
                printf("nMode: %d",nMode);
                /* Resulta em nMode: 2 */

        Esta função somente será efetiva depois que o modo gráfico é estabelecido
        pela função initgraph() ou setgraphmode().

.......................................................................................
<A NAME="7.23"><b>7.23 getimage</b></A>
        Esta função captura uma imagem da tela.
        <b style="color:green">
        void far getimage(int left, int top, int right, int bottom, void far *bitmap);
        getimage(nLeft, nTop, nRight, nBottom, sBitMap);</b>

        Ex.:    char sBitMap[6000];
                setlinestyle(SOLID_LINE,0,NORM_WIDTH);
                setfillstyle(XHATCH_FILL,12);
                bar(50,50,100,100);
                setcolor(14);
                rectangle(50,50,100,100);
                getimage(50,50,100,100,sBitMap);
                putimage(90,90,sBitMap,COPY_PUT);

        sBitMap deve ter tamanho suficiente para comportar a imagem capturada,
        você encontra este tamanho multiplicando a largura pela altura e pelo
        número de bytes empregado para representar a cor no modo de video corrente.

.......................................................................................
<A NAME="7.24"><b>7.24 getlinesettings</b></A>
        Esta função obtém a configuração do desenho de linha, tal como
        estilo, estilo de usuário e espessura da linha.
        <b style="color:green">
        void far getlinesettings(struct linesettingstype far *lineinfo);
        getlinesettings(&xLine);</b>

        Elementos da estrutura xLine:
        --------------------------------------
        xLine.linestyle...........Configuração de estilo da linha
        xLine.upattern............Estilo definido por usuário
        xLine.thickness...........Configuração de espessura

        Verifique a função setlinestyle() para obter os valores retornados
        nestes três elementos.

        Ex.:    struct linesettingstype xLine;
                setlinestyle(DASHED_LINE,0,THICK_WIDTH);
                getlinesettings(&xLine);
                printf("xLine.thickness: %d",xLine.thickness);
                /* Resulta em xLine.thickness: 3 */

.......................................................................................
<A NAME="7.25"><b>7.25 getmaxcolor</b></A>
        Esta função retorna o maior valor de cor que se pode usar para acessar
        cores no modo de vídeo corrente.
        <b style="color:green">
        int far getmaxcolor(void);
        nMaxCor = getmaxcolor();</b>

        Ex.:    int nMaxCor;
                nMaxCor = getmaxcolor();
                printf("nMaxCor: %d\n",nMaxCor);
                /* Resulta em nMaxCor: 15 */

.......................................................................................
<A NAME="7.26"><b>7.26 getmaxmode</b></A>
        Esta função obtém o maior valor possível para modo de vídeo válido
        para o driver gráfico corrente.
        <b style="color:green">
        int far getmaxmode(void);
        nMaxMode = getmaxmode();</b>

        Ex.:    int nMaxMode;
                nMaxMode = getmaxmode();
                printf("nMaxMode: %d\n",nMaxMode);
                /* Resulta em nMaxMode: 2 */

.......................................................................................
<A NAME="7.27"><b>7.27 getmaxx</b></A>
        Esta função obtém o valor máximo da coordenada absoluta do eixo x.
        <b style="color:green">
        far int getmaxx(void);
        nXmax = getmaxx();</b>

        Ex.:    int nXmax;
                nXmax = getmaxx();
                printf("nXmax: %d\n",nXmax);
                /* Resulta em nXmax: 679 */

.......................................................................................
<A NAME="7.28"><b>7.28 getmaxy</b></A>
        Esta função obtém o valor máximo da coordenada absoluta do eixo y.
        <b style="color:green">
        far int getmaxy(void);
        nYmax = getmaxy();</b>

        Ex.:    int nYmax;
                nYmax = getmaxy();
                printf("nYmax: %d\n",nYmax);
                /* Resulta em nYmax: 479 */

.......................................................................................
<A NAME="7.29"><b>7.29 getmodename</b></A>
        Esta função obtém o nome do modo gráfico corrente.
        <b style="color:green">
        char *far getmodename(int mode_number);
        sName = getmodename(nMode);</b>

        Ex.:    int nMode;
                char *sName;
                nMode = getgraphmode();
                sName = getmodename(nMode);
                printf("%s\n",sName);
                /* Resulta em 640 x 480 VGA */

.......................................................................................
<A NAME="7.30"><b>7.30 getmoderange</b></A>
        Esta função obtém o valor do modo de vídeo de baixa e alta resolução
        do driver gráfico corrente.
        <b style="color:green">
        void far getmoderange(int graphdriver, int far *lomode, int far *himode);
        getmoderange(nMode, &nLowMode, &nHighMode);</b>

        Ex.:    int nMode=2,nLowMode, nHighMode;
                getmoderange(nMode, &nLowMode, &nHighMode);
                printf("nLowMode: %d\n",nLowMode);
                printf("nHighMode: %d\n",nHighMode);
                /* Resulta em
                                        nLowMode: 0
                                        nHighMode: 2    */

.......................................................................................
<A NAME="7.31"><b>7.31 getpalette</b></A>
        Esta função obtém os valores da palheta de cores para cada registro
        de cor. O registro de cor é o número que você usa para aplicar a
        cor na tela, o valor deste registro é o conjunto de bits que define
        a pigmentação colorida obtida por tal registro.
        <b style="color:green">
        void far getpalette(struct palettetype far *palette);
        getpalette(&xPal);</b>

        Elementos de xPal:
        ------------------------------------
        unsigned char size ..............Número de registro de cores da palheta
        signed char colors[size+1].......Valor que forma a matiz da cor

        Ex.:    int cx;
                struct palettetype xPal;
                getpalette(&xPal);
                for (cx=0;cx &lt; xPal.size; cx++) {
                printf("Registro[%2d]: %2d\n",cx,xPal.colors[cx]);

                /* Resulta em
                        Registro[ 0]:  0
                        Registro[ 1]:  1
                        Registro[ 2]:  2
                        Registro[ 3]:  3
                        Registro[ 4]:  4
                        Registro[ 5]:  5
                        Registro[ 6]: 20
                        Registro[ 7]:  7
                        Registro[ 8]: 56
                        Registro[ 9]: 57
                        Registro[10]: 58
                        Registro[11]: 59
                        Registro[12]: 60
                        Registro[13]: 61
                        Registro[14]: 62
                        Registro[15]: 63        */

.......................................................................................
<A NAME="7.32"><b>7.32 getpalettesize</b></A>
        Esta função obtém o tamanho da palheta de cores.
        <b style="color:green">
        int far getpalettesize(void);
        nPalSize = getpalettesize();</b>

        Ex.:    int nPal;
                nPal = getpalettesize();
                printf("nPalSize: %d\n",nPal);
                /* Resulta em nPalSize: 16 */

        No exemplo acima foi obtido o tamanho da palheta da resolução 640x480,
        VGA que apresenta 16 referências numéricas para aplicação de cor.

.......................................................................................
<A NAME="7.33"><b>7.33 getpixel</b></A>
        Esta função obtém a cor do pixel da coordenada fornecida.
        <b style="color:green">
        unsigned far getpixel(int x, int y);
        nCor = getpixel(xCol,yLin);</b>

        Ex.:    unsigned int nCor;
                nCor = getpixel(320,240);

.......................................................................................
<A NAME="7.34"><b>7.34 gettextsettings</b></A>
        Esta função obtém a atual configuração de saída de texto em modo
        gráfico.
        <b style="color:green">
        void far gettextsettings(struct textsettingstype far *texttypeinfo);
        gettextsettings(&xText);</b>

        Elementos de xText:
        ---------------------------------------------------------
        int xText.font........Fonte usada
        int xText.direction...Direção da impressão
        int xText.charsize....Tamanho da fonte
        int xText.horiz.......Alinhamento horizontal
        int xText.vert........Alinhamento vertical

        Verifique as funções settextstyle() e settextjustify() para visualizar
        os valores constantes que estes elementos recebem.

        Ex.:    struct textsettingstype xText;
                gettextsettings(&xText);
                printf("xText.font: %d",xText.font);

.......................................................................................
<A NAME="7.35"><b>7.35 getviewsettings</b></A>
        Esta função obtém a configuração da janela gráfica atual.
        <b style="color:green">
        void far getviewsettings(struct viewporttype far *viewport);
        getviewsettings(&xWindow);</b>

        Elementos de xWindow:
        -----------------------------------------------------
        int xWindow.left .............Coordenada x do início da janela
        int xWindow.top ..............Coordenada y do início da janela
        int xWindow.right ............Coordenada x do final da janela
        int xWindow.bottom ...........Coordenada y do final da janela
        int xWindow.clip .............Flag de clipping

        Ex:     struct viewporttype xWindow;
                rectangle(150,110,490,370);
                setviewport(160,120,480,360);
                outtext("Testando setviewport().");
                circle(60,60,100);
                getviewsettings(&xWindow);
                printf("xWindow.clip: %d\n",xWindow.clip);

        Para maior domínio desta função veja setviewport().

.......................................................................................
<A NAME="7.36"><b>7.36 getx</b></A>
        Esta função obtém o valor da posição corrente do cursor gráfico no eixo x.
        <b style="color:green">
        int far getx(void);
        xCol = getx();</b>

        Ex.:    int xCol;
                xCol = getx();

        O valor de retorno é relativo a viewport estabelecida.

.......................................................................................
<A NAME="7.37"><b>7.37 gety</b></A>
        Esta função obtém o valor da posição corrente do cursor gráfico no eixo y.
        <b style="color:green">
        int far gety(void);
        yLin = gety();</b>

        Ex.:    int yLin;
                yLin = gety();

        O valor de retorno é relativo a viewport estabelecida.

.......................................................................................
<A NAME="7.38"><b>7.38 graphdefaults</b></A>
        Esta função resseta a configuração gráfica, restaurando os valores
        originais de configuração.
        <b style="color:green">
        void far graphdefaults(void);
        graphdefaults();</b>

        Ex.:    setlinestyle(DASHED_LINE,0,NORM_THICK);
                rectangle(100,100,200,160);
                getch();
                graphdefaults();
                rectangle(100,100,200,160);

.......................................................................................
<A NAME="7.39"><b>7.39 grapherrormsg</b></A>
        Esta função retorna um ponteiro para uma mensagem de erro correspondente
        ao valor do erro ocorrido retornado por graphresult().
        <b style="color:green">
        char *far grapherrormsg(int errorcode);
        sMsg = grapherrormsg(nError);</b>

        Ex.:    int x = -1;
                printf("%s\n",grapherrormsg(x));
                /* Resulta em (BGI) graphics not installed */

.......................................................................................
<A NAME="7.40"><b>7.40 _graphfreemem</b></A>
        Esta função libera a memória requisitada pelas funções gráficas
        desta biblioteca que a usam internamente e de maneira frequente.
        Esta função não existe para uso direto do usuário. Ela está
        relatada aqui para quando o usuário quiser fazer diretamente
        o gerenciamento de memória nos processos gráficos. O protótipo
        desta função é dado a conhecer para que o usuário saiba exatamente
        como declarar essa função para uso fora dos limites usuais.
        Esta função usa farfree(), portanto o arquivo alloc.h deve ser
        incluso no seu programa.
        <b style="color:green">
        void far _graphfreemem(void far *ptr, unsigned size);
        O protótipo acima é tal como você deve usar para recriar esta função.</b>

        Esta função trabalha em conjunto com a função _getgraphmem(),
        cuja explanação abaixo traz um programa exemplo no qual estas
        duas funções são redeclaradas.

.......................................................................................
<A NAME="7.41"><b>7.41 _graphgetmem</b></A>
        Esta função requisita memória para uso das funções gráficas
        desta biblioteca que a usam internamente e de maneira frequente.
        Esta função não existe para uso direto do usuário. Ela está
        relatada aqui para quando o usuário quiser fazer diretamente
        o gerenciamento de memória nos processos gráficos. O protótipo
        desta função é dado a conhecer para que o usuário saiba exatamente
        como declarar essa função para uso fora dos limites usuais.
        Esta função usa malloc(), portanto o arquivo alloc.h deve ser
        incluso no seu programa.
        <b style="color:green">
        void far *far _graphgetmem(unsigned size);
        O protótipo acima é tal como você deve usar para recriar esta função</b>

        Esta função trabalha em conjunto com a função _graphfreemem().

        Veja programa exemplo, com estas funções redeclaradas:<font color="darkblue">

        #include "graphics.h"
        #include "stdlib.h"
        #include "stdio.h"
        #include "conio.h"
        #include "alloc.h"

        int main(void) {
        int gdriver = DETECT, gmode, errorcode;
        int midx, midy;

        clrscr();

        initgraph(&gdriver, &gmode, "c:\tc");

        errorcode = graphresult();

        if (errorcode != grOk){
        printf("Error: %s\n", grapherrormsg(errorcode));
        printf("Pressiona qualquer tecla para encerrar.");
        getch();
        exit(1);}

        midx = getmaxx() / 2;
        midy = getmaxy() / 2;

        settextjustify(CENTER_TEXT, CENTER_TEXT);
        outtextxy(midx, midy, "Pressione qualquer tecla para sair do modo gráfico");

        getch();
        closegraph();
        return 0;}

        void far * far _graphgetmem(unsigned size) {
        printf("_graphgetmem chamada para alocar %d bytes.\n", size);
        printf("Pressione qualquer tecla para continuar");
        getch();
        printf("\n");

        /* aloca memoria da far heap */
        return farmalloc(size);}

        void far _graphfreemem(void far *ptr, unsigned size) {
        printf("_graphfreemem chamada para liberar %d bytes.\n", size);
        printf("Pressione qualquer tecla para continuar");
        getch();
        printf("\n");

        /* Libera a memória da far heap */
        farfree(ptr); }</font>


.......................................................................................
<A NAME="7.42"><b>7.42 graphresult</b></A>
        Esta função retorna o valor do erro que ocorreu na última operação
        gráfica mal sucedida. Depois da chamada desta função, este valor de
        erro é ressetado para grOK.
        <b style="color:green">
        int far graphresult(void);
        nError = graphresult();</b>

        Ex.:    int nError;
                nError = graphresult();

.......................................................................................
<A NAME="7.43"><b>7.43 imagesize</b></A>
        Esta função calcula o tamanho de bytes necessários para estocar
        uma imagem que pode ser capturada com getimage().
        <b style="color:green">
        unsigned far imagesize(int left, int top, int right, int bottom);
        nTam = imagesize(nLeft, nTop, nRight, nBottom);</b>

        Ex.:    unsigned int nTam;
                nTam = imagesize(50,50,100,100);
                printf("nTam: %u\n",nTam);
                /* Resulta em nTam: 1434 */

.......................................................................................
<A NAME="7.44"><b>7.44 initgraph</b></A>
        Esta função inicializa o modo gráfico para uso.
        <b style="color:green">
        void far initgraph(int far *graphdriver,
                                 int far *graphmode, int far *graphmode);

        initgraph(&nDriver, &nMode, &sDrivePath);</b>

        nDriver..........Driver gráfico que será usado
        nMode............Modo de vídeo
        sDrivePath.......Caminho no qual se encontra os drivers BGI

        Para nDrive você pode usar estas constantes:
        ---------------------------------------------------
        CGA.........1 .....Gráficos Cga
        EGA.........3 .....Gráficos Ega
        EGAMONO.....5 .....EGA monocromático
        HERCMONO....7 .....Hércules Monocromático
        VGA.........9 .....Gráficos Vga
        MCGA........2 .....Gráficos Mcga
        EGA64.......4 .....Gráficos Ega 64 cores
        IBM8514.....6 .....Gráficos Ibm8514
        ATT400......8 .....Gráficos Att400
        PC3270......3 .....Gráficos Pc3270
        DETECT......0 .....Autodetecção do melhor driver

        Para nMode você pode usar estas constantes:
        ---------------------------------------------------
        CGAC0.........0.....Cga      320x200 palette 0
        CGAC1.........1.....Cga      320x200 palette 1
        CGAC2.........2.....Cga      320x200 palette 2
        CGAC3.........3.....Cga      320x200 palette 3
        CGAHI.........4.....Cga      640x200

        MCGAC0........0.....Mcga     320x200 palette 0
        MCGAC1........1.....Mcga     320x200 palette 1
        MCGAC2........2.....Mcga     320x200 palette 2
        MCGAC3........3.....Mcga     320x200 palette 3
        MCGAMED.......4.....Mcga     640x200
        MCGAHI........5.....Mcga     640x480

        EGALO.........0.....Ega      640x200 16 color
        EGAHI.........1.....Ega      640x350 16 color
        EGA64LO.......0.....Ega      640x200 16 color
        EGA64HI.......1.....Ega      640x350 4  color
        EGAMONOHI.....0.....Ega      640x350
        HERCMONOHI....0.....Hércules 720x348

        ATT400C0......0.....Att400   320x200 palette 0
        ATT400C1......1.....Att400   320x200 palette 1
        ATT400C2......2.....Att400   320x200 palette 2
        ATT400C3......3.....Att400   320x200 palette 3
        ATT400MED.....4.....Att400   640x200
        ATT400HI......5.....Att400   640x400

        VGALO.........0.....Vga      640x200
        VGAMED........1.....Vga      640x350
        VGAHI.........2.....Vga      640x480
        PC3270HI......0.....Pc3270   720x350
        IBM8514LO.....0....Ibm8514   640x480  256 colors
        IBM8514HI.....1....Ibm8514   1024x768 256 colors

        Ex.:    initgraph(VGA,VGAHI,"C:\TC");

        Veja este programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "stdlib.h"
        #include "conio.h"
        #include "graphics.h"

        int main(int nCmd, char **sCmd) {
        int nError;
        int nDriver = DETECT;
        int nMode;
        char *sDrivePath = "c:\tc";

        initgraph(&nDriver, &nMode, &sDrivePath);

        nError = graphresult();
        if (nError != grOk) {
        printf("Erro : %s\n", grapherrormsg(nError));
        getch();
        exit(1);}

        circle(320,240,50);
        puts("End of Program\n");
        getch();}</font>

.......................................................................................
<A NAME="7.45"><b>7.45 installuserdriver</b></A>
        Esta função instala um driver gráfico de terceiros.
        <b style="color:green">
        int far installuserdriver(char far *name, int huge (*detect)(void));
        nDriver = installuserdriver(sFileName, pDetect);</b>

        nDriver............Valor que será usado por initgraph()
        sFileName..........Nome do arquivo BGI
        pDetect............Ponteiro para uma função que será chamada por initgraph()

        Ex.:    gdriver = installuserdriver("SVGA256", detectVGA);

        Veja o programa exemplo da Borland:<font color="darkblue">
        #include "graphics.h"
        #include "stdlib.h"
        #include "stdio.h"
        #include "conio.h"

        /* Veja como declarar a função pDetect */
        int huge detectVGA(void);
        void checkerrors(void);

        int main(void) {  int gdriver, gmode;

        /* Perceba a sintaxe da função installuserdriver() */
        gdriver = installuserdriver("SVGA256", detectVGA);

        /* Vamos forçar o uso da rotina de detecção */
        gdriver = DETECT;

        /* Verificação de erros na instalação */
        checkerrors();

        /* Inicializa os gráficos e as variáveis locais */
        initgraph(&gdriver, &gmode, "c:\tc");

        /* Verificação de erros de inicialização */
        checkerrors();

        getch();
        closegraph();
        return 0; }

        /* Detecta placa de vídeo VGA */
        int huge detectVGA(void) {
        int driver, mode, sugmode = 0;

        detectgraph(&driver, &mode);
        if ((driver == EGA) || (driver == VGA))
        /* Retorna o modo de vídeo sugerido */
        return sugmode;
        else
        return grError; }

        /* Verifica e reporta erros nas operações gráficas */
        void checkerrors(void) {
        int errorcode;

        /* Lê o resultado das últimas operações gráficas */
        errorcode = graphresult();
        if (errorcode != grOk) {
        printf("Graphics error: %s\n", grapherrormsg(errorcode));
        printf("Press any key to halt:");
        getch();
        exit(1);}}</font>

.......................................................................................
<A NAME="7.46"><b>7.46 installuserfont</b></A>
        Esta função instala uma fonte de terceiros.
        <b style="color:green">
        int far installuserfont(char far *name);
        nFont = installuserfont(sFileName);</b>

        sFileName...Nome do arquivo de fonte do tipo *.CHR
        nFont.......Passe este número para settextstyle(), para usar a fonte.

        Ex.:    int nFont;
                nFont = installuserfont("TSCR.CHR");
                settextstyle(nFont,HORIZ_DIR,2);
                outtextxy(250,240,"Testando installuserfont().");

.......................................................................................
<A NAME="7.47"><b>7.47 line</b></A>
        Esta função desenha uma linha através da conexão de duas coordenadas.
        <b style="color:green">
        void far line(int x1, int y1, int x2, int y2);
        line(x,y,cx,cy);</b>

        Ex.:    line(0,240,679,240);

        Esta função desenha uma linha usando a configuração definida pela função
        setlinestyle() que configura estilo e espessura da linha.

.......................................................................................
<A NAME="7.48"><b>7.48 linerel</b></A>
        Esta função desenha através de deslocamentos relativos.
        <b style="color:green">
        void far linerel(int x, int y);
        linerel(xRel,yRel);</b>

        Ex.:    moveto(250,250);
                lineto(50,0);
                lineto(0,50);
                lineto(-50,0);
                lineto(0,-50);

        Desenhamos aqui um quadrado usando a plotagem de linha sempre referente
        ao último ponto.

.......................................................................................
<A NAME="7.49"><b>7.49 lineto</b></A>
        Desenha uma linha a partir do última coordenada do cursor até a coordenada
        fornecida.
        <b style="color:green">
        void far lineto(int x, int y);
        lineto(xCol,yLin);</b>

        Ex.:    moveto(250,250);
                lineto(300,300);

.......................................................................................
<A NAME="7.50"><b>7.50 moverel</b></A>
        Esta função reposiciona o curso gráfico de modo relativo ao último
        ponto plotado na tela.
        <b style="color:green">
        void far moverel(int dx, int dy);
        moverel(xRel,yRel);</b>

        Ex.:    char sMsg[]="Seja metódico!";
                moveto(250,250);
                outtext(sMsg);
                moverel(50,50);
                outtext(sMsg);

.......................................................................................
<A NAME="7.51"><b>7.51 moveto</b></A>
        Posiciona o cursor gráfico na coordenada especificada.
        <b style="color:green">
        void far moveto(int x, int y);
        moveto(xCol,yLin);</b>

        Ex.:    moveto(320,240);
.......................................................................................
<A NAME="7.52"><b>7.52 outtext</b></A>
        Esta opção imprime strings em modo gráfico.
        <b style="color:green">
        void far outtext(char far *textstring);
        outtext(sMsg);</b>

        Ex.:    char sMsg[]="Seja perseverante!";
                moveto(320,240);
                outtext(sMsg);

.......................................................................................
<A NAME="7.53"><b>7.53 outtextxy</b></A>
        Esta função imprime strings em modo gráfico na coordenada especificada.
        <b style="color:green">
        void far outtextxy(int x, int y, char far *textstring);
        outtext(xCol, yLin, sMsg);</b>

        Ex.:    char sMsg[]="Seja Perseverante!";
                outtextxy(250,250,sMsg);

.......................................................................................
<A NAME="7.54"><b>7.54 pieslice</b></A>
        Esta função desenha gráfico tipo pizza (ou torta) na tela,
        aplicando o preenchimento definido por setfillstyle().
        <b style="color:green">
        void far pieslice(int x, int y, int stangle, int endangle, int radius);
        pieslice(xCol,yLin, nStartAngle,nEndAngle, nRaio);</b>

        nRaio......................Raio do arco.
        xCol,yLin..................Coordenadas (x,y) do centro
        nStartAngle,nEndAngle......São respectivamente ângulo inicial e
        ãngulo final, dados em graus.

        Ex.:    setlinestyle(SOLID_LINE,0,NORM_WIDTH);
                setfillstyle(XHATCH_FILL,12);
                setcolor(14);
                pieslice(320,240,90,180,100);

.......................................................................................
<A NAME="7.55"><b>7.55 putimage</b></A>
        Esta função coloca uma imagem na tela que foi previamente capturada
        com a função getimage().
        <b style="color:green">
        void far putimage(int left, int top, void far *bitmap);
        putimage(nLeft,nTop, sBitMap, nPut);</b>

        nPut...indica o tipo de combinação da imagem com o conteúdo da tela

        Para nPut você pode usar estas constantes:
        -------------------------------------------
        COPY_PUT..........A imagem sobreescreve o conteúdo da tela
        XOR_PUT...........Combina imagem e tela usando lógica XOR
        OR_PUT............Combina imagem e tela usando lógica OR
        AND_PUT...........Combina imagem e tela usando lógica AND
        NOT_PUT...........Inverte os bits de cor da imagem

        Ex.:    char sBitMap[6000];
                setlinestyle(SOLID_LINE,0,NORM_WIDTH);
                setfillstyle(XHATCH_FILL,12);
                bar(50,50,100,100);
                setcolor(14);
                rectangle(50,50,100,100);
                getimage(50,50,100,100,sBitMap);
                putimage(90,90,sBitMap,COPY_PUT);

.......................................................................................
<A NAME="7.56"><b>7.56 putpixel</b></A>
        Esta função acende um pixel na tela na cor e na coordenada especificada.
        <b style="color:green">
        void far putpixel(int x, int y, int pixelcolor);
        putpixel(xCol,yLin,nCor);</b>

        Ex.:    putpixel(320,240,14);

.......................................................................................
<A NAME="7.57"><b>7.57 rectangle</b></A>
        Esta opção desenha um retângulo usando a configuração atual de linha
        e cor.
        <b style="color:green">
        void far rectangle(int left, int top, int right, int bottom);
        rectangle(nLeft, nTop, nRight, nBottom);</b>

        Ex.:    rectangle(240,160,400,320);

        Para obter retângulos diferentes use a função setlinestyle() para
        alterar estilo e espessura da linha.
.......................................................................................
<A NAME="7.58"><b>7.58 registerbgidriver</b></A>
        Esta função registra um driver gráfico que foi linkado ao executável
        com o utilitário BGIOBJ.EXE
        <b style="color:green">
        int far registerbgidriver((*driver) (void));
        nSts = registerbgidriver(pDriver);</b>

        Ex.:    nErrorCode = registerbgidrive(EGAVGA_driver);

        Esta função não foi devidamente testada devido a informações insuficientes
        do arquivo de ajuda original. Portanto, para uma informação acurada o
        usuário deve recorrer a outras fontes.

.......................................................................................
<A NAME="7.59"><b>7.59 registerbgifont</b></A>
        Esta função registra um arquivo de fonte que foi linkado ao programa
        executável com o utilitário BGIOBJ.EXE.
        <b style="color:green">
        int registerbgifont((*font)(void));
        nSts = registerbgifont(pFonte);</b>

        Ex.: nErroCode = registerbgifont(triplex_font);

        Este exemplo foi tirado do programa exemplo da Borland, que infelizmente
        não rodou. Portanto, esta função não foi devidamente testada, obrigando
        o usuário recorrer a outras fontes para uma informação acurada.

.......................................................................................
<A NAME="7.60"><b>7.60 restorecrtmode</b></A>
        Esta função restaura os valores de video originais que estavam antes
        da chamada de initgraph().
        <b style="color:green">
        void far restorecrtmode(void);
        restorecrtmode();</b>

        Ex.:    restorecrtmode()

        Em nossos testes, esta função encerrou o modo gráfico e retornou com
        o modo texto que estava operante antes da chamada de initgraph()
.......................................................................................
<A NAME="7.61"><b>7.61 sector</b></A>
        Esta função desenha um gráfico pizza usando o contorno de ellipse,
        aplicando o preenchimento definido por setfillstyle();
        <b style="color:green">
        void far sector(int x, int y, int stangle, int endangle,
                                        int xradius, int yradius);

        sector(int xCol,yLin,nStartAngle, nEndAngle, xRaio, yRaio);</b>

        Ex.:    sector(320,240,90,360,110,130);

        xCol,yLine.............Definem o centro (x,y) da elipse.
        nStartAngle,nEndAngle..São respectivamente ângulo inicial e
                               ângulo final que são dados em graus.
        xRaio,yRaio............São respectivamente o raio horizontal e vertical da
                               elipse.Você definindo o mesmo valor para estes raios
                               você desenha um circulo.

.......................................................................................
<A NAME="7.62"><b>7.62 setactivepage</b></A>
        Esta função determina qual página de vídeo recebe a saída gráfica
        das funções. Ela é de uso para com as placas que possuem mais de
        uma página de vídeo. Esta função é útil para operações gráficas
        off-screen, nos bastidores da memória, depois que o gráfico está
        completo, nós podemos mostrá-lo na tela de uma vez; isto evita que
        o usuário acompanhe a formação do gráfico.
        <b style="color:green">
        void far setactivepage(int page);
        setactivepage(nPage);</b>

        Ex.:    setactivepage(1);
                circle(320,240,50);
                setvisualpage(1);

        Esta função é usada em conjunto com setvisualpage().

.......................................................................................
<A NAME="7.63"><b>7.63 setallpalette</b></A>
        Esta função reconfigura toda a palheta de cores.
        <b style="color:green">
        void far setallpalette(struct palettetype far *palette);
        setallpalette(&xPal);</b>

        Elementos de xPal:
        ------------------------------------
        unsigned char size ..............Número de registro de cores da palheta
        signed char colors[size+1].......Valor que forma a matiz da cor

        Ex.:    int cx; int nNumber;
                struct palettetype xPal;
                for (cx=0; cx < 16; cx++) {
                nNumber = random(128);
                xPal.colors[cx]=nNumber; }
                setallpalette(&xPal);

        Veja programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "ctype.h"
        #include "graphics.h"
        #include "stdlib.h"
        #include "time.h"

        int main (int nCmd, char **sCmd) {
        int nDriver, nMode;
        int cx=50,cy=50;
        char nNumber;
        int nCor;

        struct palettetype xPal;
        nDriver=DETECT;
        initgraph(&nDriver,&nMode,"c:\tc");
        randomize();

        for (cx=0; cx<16; cx++) {
        nNumber = random(128);
        xPal.colors[cx]=nNumber;}
        setallpalette(&xPal);

        do {
        cx=50; cy=50;
        for (nCor=0; nCor < 16; nCor++) {
        cx=cx+50;
        if (cx>500) {
        cx = 50; cy+=50; }
        setcolor(14);
        setfillstyle(SOLID_FILL,nCor);
        rectangle(cx,cy,cx+50,cy+50);
        floodfill(cx+1,cy+1,14); }

        for (cx=0; cx<16; cx++) {
        nNumber = random(128);
        xPal.colors[cx]=nNumber;}
        setallpalette(&xPal);

        sleep(1);
        } while (!kbhit());

        puts("Closing graphics...");
        getch();
        restorecrtmode();

        puts("\nEnd of Program");
        getch(); }</font>


.......................................................................................
<A NAME="7.64"><b>7.64 setaspectratio</b></A>
        Esta função estabelece uma nova razão de aspecto.
        <b style="color:green">
        void far setaspectratio(int far *xasp, int far *yasp);
        setaspectratio(xAspect,yAspect);</b>

        Ex.:    setaspectratio(7000, 5000);
                circle(320,240,100);

        Outras fontes informam que a razão do aspecto é uma relação existente
        entre o eixo x e y da tela, que descreve a resolução da tela; por
        exemplo, na resolução VGA 640x480 tal número é obtido pela divisão
        do total de colunas pelo total de linhas com a aplicação de uma outra
        variável que não é de meu conhecimento agora.

        A partir do momento que o total de linhas é diferente do total de colunas
        e que o espaçamento horizontal e vertical entre um pixel e outro é desigual
        isto dá origem a gráficos imperfeitos tal como um círculo oval, um quadrado
        retangular. Como forma de corrigir isso, outras funções obtém a razão do
        aspecto para compensar sua influência sobre as saídas gráficas.

        A Borland recomenda que na resolução VGA xAspect deve ser igual a 10000,
        quando o pixel for quadrado e xAspect menor que 10000 quando o pixel for
        retangular.


.......................................................................................
<A NAME="7.65"><b>7.65 setbkcolor</b></A>
        Esta função estabelece a cor de fundo, em outras palavras ela troca
        a cor do background.
        <b style="color:green">
        void far setbkcolor(int color);
        setbkcolor(nCor);</b>

        Ex.:    setbkcolor(1);

.......................................................................................
<A NAME="7.66"><b>7.66 setcolor</b></A>
        Esta função estabelece a cor de frente.
        <b style="color:green">
        void far setcolor(int color);
        setcor(nCor);</b>

        Ex.:    setcolor(14);
                circle(320,240,80);

.......................................................................................
<A NAME="7.67"><b>7.67 setfillpattern</b></A>
        Esta função configura o estilo para preenchimento de áreas.
        <b style="color:green">
        void far setfillpattern(char *far upattern,int color);
        setfillpattern(sUserStyle, nCor);</b>

        sUserStyle.......User style é uma string de 8 bytes, formando uma matrix de
                         bits 8x8. Esta configuração dos bits forma um desenho que será
                         usado no preenchimento de áreas.

        nCor.............Cor do preenchimento

        Ex.:    char sUserStyle[8]={0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88};
                setfillpattern(sUserStyle,10);
                fillellipse(320,240,0,360,110,130);

        O número 0x88 tem este padrão de bits 10001000, que agrupado forma
        um estilo que tem a forma de linhas separadas por três pixels de cor
        de fundo.

.......................................................................................
<A NAME="7.68"><b>7.68 setfillstyle</b></A>
        Esta função estabelece um estilo de preenchimento interno pré-definido
        que será usado principalmente pela função floodfill().
        <b style="color:green">
        void far setfillstyle(int pattern, int color);
        setfillstyle(nStyle, nCor);</b>

        Ex.:    setlinestyle(SOLID_LINE,0,NORM_WIDTH);
                setcolor(14);
                setfillstyle(LINE_FILL,10);
                rectangle(240,160,400,320);
                floodfill(241,161,14);

        Para nStyle você pode usar estas constantes dos estilos pré-definidos:
        -----------------------------------------------------------------------
        EMPY_FILL..........Mantém ou utiliza a cor do background
        SOLID_FILL.........Usa um preenchimento sólido com a cor atual
        LINE_FILL..........Linear
        LTSLASH_FILL.......Este estilo "////"
        SLASH_FILL.........Este estilo "<b>////</b>" com as barras mais espessas
        BKSLASH_FILL.......Este estilo "<b>\\\\</b>" com as barras mais espessas
        LTBKSLASH_FILL.....Este estilo "\\\\"

        HATCH_FILL.........Hachuramento leve, quadriculado
        XHATCH_FILL........Hachuramento cruzado, quadriculado com linhas diagonais
        INTERLEAVE_FILL....Hachuramento cheio, interfolheado com linhas diagonais
        WIDE_DOT_FILL......Pontilhamento espaçado
        CLOSE_DOT_FILL.....Pontilhamento apertado
        USER_FILL..........Estilo definido pelo usuário através da função setfillpattern()

.......................................................................................
<A NAME="7.69"><b>7.69 setgraphbufsize</b></A>
        Esta função redefine o tamanho do buffer gráfico.
        <b style="color:green">
        unsigned far setgraphbufsize(unsigned bufsize);
        nPrevious = setgraphbufsize(nTam);</b>

        nPrevious............A função retorna o tamanho anterior do buffer
        nTam.................O novo tamanho do buffer

        Ex.:    unsigned int nPrevious, nTam=35000;
                nPrevious = setgraphbufsize(nTam);

        Esta função deve ser chamada antes de initgraph().

.......................................................................................
<A NAME="7.70"><b>7.70 setgraphmode</b></A>
        Esta função estabelece um novo modo gráfico. A tela é limpa
        na troca de modo.
        <b style="color:green">
        void far setgraphmode(int mode);
        setgraphmode(nMode);</b>

        Ex.:    int nMode=0;
                setgraphmode(nMode);

        Esta função somente deve ser usada depois de initgraph().
.......................................................................................
<A NAME="7.71"><b>7.71 setlinestyle</b></A>
        Esta função configura o estilo e espessura da linha.
        <b style="color:green">
        void far setlinestyle(int linestyle,unsigned upattern,int thickness);
        setlinestyle(nEstilo, nUserStyle, nEspessura);</b>

        nEstilo......Define o estilo da linha, isto é, se ela tracejada ou pontilhada.
        nUserStyle...Estilo da linha definido pelo usuário quando nEstilo = USERBIT_LINE
        nEspessura...Espessura da linha

        Para nEstilo você pode usar estas constantes:
        ----------------------------------------------
        SOLID_LINE..........Linha sólida
        DOTTED_LINE.........Linha pontilhada
        CENTER_LINE.........Linha tracejada
        DASHED_LINE.........Linha tracejada
        USERBIT_LINE........Indica que o estilo será definido pelo usuário

        Para nEspessura você pode usar estas constantes:
        ------------------------------------------------
        NORM_WIDTH..........Espessura normal
        THICK_WIDTH.........Espessura grossa

        Para usar nUserStyle compreenda o seguinte:
        --------------------------------------------
        Para usar nUserStyle você deve configurar nEstilo para USERBIT_LINE.
        nUserStyle é do tipo unsigned, seu alcance é de zero a 65535. Neste
        número o bit que estiver setado será desenhado, o bit que estiver
        zerado não será desenhado. Por exemplo, o número 0xAAFF apresenta
        este padrão de bits 1010101011111111, então a linha será construída usando
        este padrão "....____" que se repetirá até o fim da linha.

        Ex.:    setlinestyle(DASHED_LINE,0,NORM_THICK);
                line(0,240,679,240);

        /* Este exemplo desenha uma linha pontilhada no meio da tela */


.......................................................................................
<A NAME="7.72"><b>7.72 setpalette</b></A>
        Esta função reconfigura a matiz de uma cor.
        <b style="color:green">
        void far setpalette(int colornum, int color);
        setpalette(nRegistro, nMatiz);</b>

        Ex.:    setpalette(0,0xF0F);

.......................................................................................
<A NAME="7.73"><b>7.73 setrgbpalette</b></A>
        Esta função redefine a matiz de uma cor usando valores RGB.
        <b style="color:green">
        void far setrgbpalette(int colornum, int red, int green, int blue);
        setrgbpalette(nRegistro, nRed, nGreen, nBlue</b>

        Ex.:    setrgbpalette(0,0,0,255);

.......................................................................................
<A NAME="7.74"><b>7.74 settextjustify</b></A>
        Esta função configura o alinhamento de texto em modo gráfico.
        <b style="color:green">
        void far settextjustify(int horiz, int vert);
        settextjustify(nHorizontal,nVertical);</b>

        Para nHorizontal e nVertical você pode usar estas constantes:
        --------------------------------------------------------------
        LEFT_TEXT........Alinhamento à esquerda
        CENTER_TEXT......Alinhamento ao centro
        RIGHT_TEXT.......Alinhamento à direita
        BOTTOM_TEXT......Alinhamento ao fundo
        TOP_TEXT.........Alinhamento ao topo

        Ex.:    char sMsg[]="Programming is cool!";
                settextjustify(CENTER_TEXT,TOP_TEXT);
                outtext(sMsg);

.......................................................................................
<A NAME="7.75"><b>7.75 settextstyle</b></A>
        Esta função estabelece e configura a fonte para o modo gráfico.
        <b style="color:green">
        void far settextstyle(int font, int direction, int char size);
        settextstyle(nFont, nDirection, nSize);</b>

        Ex.:    char sMsg[]=" * SEJA PERSEVERANTE * ";
                moveto(50,250);
                settextstyle(TRIPLEX_FONT,HORIZ_DIR,5);
                outtext(sMsg);

        Para nFont você pode usar estas constantes:
        --------------------------------------------
        DEFAULT_FONT
        TRIPLEX_FONT
        SANS_SERIF_FONT
        GOTHIC_FONT

        Para nDirection você tem estas duas constantes:
        ------------------------------------------------
        HORIZ_DIR.........Exibe o texto da esquerda para a direita
        VERT_DIR..........Exibe o texto de baixo para cima

        Para nSize compreenda o seguinte:
        ----------------------------------
        1................Tamanho 8x8
        2................Tamanho 16x16
        (...) ...........Perceba que o tamanho da fonte é obtido multiplicando nSize por 8.
        10...............Tamanho 80x80
        USER_CHAR_SIZE...Para usar o tamanho configurado com a função setusercharsize().
        Somente válido também para a fonte TRIPLEX_FONT.


.......................................................................................
<A NAME="7.76"><b>7.76 setusercharsize</b></A>
        Esta função função estabelece o tamanho da fonte definido pelo usuário.
        <b style="color:green">
        void far setusercharsize(int multx, int divx, int multy, int divy);
        setusercharsize(nMultx, nDivx, nMulty, nDivy);</b>

        nMultx, nDivx.......Redefinem a largura da fonte na razão nMultx:nDivx
        nMulty, nDivy.......Redefinem a altura da fonte na razão nMultx:nDivy

        Ex.:    settextstyle(TRIPLEX_FONT,HORIZ_DIR,USER_CHAR_SIZE);
                setusercharsize(2,1,3,2);
                outtextxy(50,240,"Testando setusercharsize().");
                /* Aumenta largura em 2:1, altura 3:1 */

.......................................................................................
<A NAME="7.77"><b>7.77 setviewport</b></A>
        Esta função reconfigura a janela gráfica, em outras palavras, esta função
        estabelece o inicio e o final da tela para saída das funções gráficas.
        <b style="color:green">
        void far setviewport(int left, int top, int right, int bottom, int clip);
        setviewport(nLeft, nTop, nRight, nBottom, nClip);</b>

        Ex:     rectangle(150,110,490,370);
                setviewport(160,120,480,360);
                outtext("Testando setviewport().");
                circle(60,60,100);

        nClip define se vai haver corte ou não na saída gráfica quando esta
        ultrapassar os limites da janela; 1 habilita, 0 desabilita clipping.

.......................................................................................
<A NAME="7.78"><b>7.78 setvisualpage</b></A>
        Esta função joga na tela de uma só vez o conteúdo da página de vídeo fornecida.
        Ela é de uso para com as placas que possuem mais de uma página de vídeo.
        Esta função é útil para operações gráficas off-screen, nos bastidores da memória,
        depois que o gráfico está completo, nós podemos mostrá-lo na tela de uma vez;
        isto evita que o usuário acompanhe a formação do gráfico.
        <b style="color:green">
        void far setvisualpage(int page);
        setvisualpage(nPage);</b>

        Ex.:    setactivepage(1);
                circle(320,240,50);
                setvisualpage(1);

        Esta função é usada em conjunto com setactivepage().

.......................................................................................
<A NAME="7.79"><b>7.79 setwritemode</b></A>
        Esta função define o modo de escrita de linha, que diz respeito
        como a linha se combina com o conteúdo da tela.
        <b style="color:green">
        void far setwritemode(int mode);
        setwritemode(nPut);</b>

        Se nPut=0, então as linhas desenhadas sobreescrevem o conteúdo.
        Se nPut=1, então as linhas se combinam com o conteúdo numa operação
        lógica XOR.

        Ex.:    setlinestyle(SOLID_LINE,0,THICK_WIDTH);
                setcolor(10);
                setwritemode(1);
                line(0,240,679,240);
                setcolor(12);
                line(320,0,320,479);
                setcolor(14);
                rectangle(300,200,340,280);
.......................................................................................
<A NAME="7.80"><b>7.80 textheight</b></A>
        Esta função retorna a altura da string em pixels.
        <b style="color:green">
        int far textheight(char far *textstring);
        nHeight = textheight(sMsg);</b>

        Ex.:    int nHeight;
                char sMsg[]="AAAAA";
                nHeight = textheight(sMsg);
                printf("%d\n",nHeight);
                /* Resulta em 8 */

        Na prática esta função acaba retornando a altura da fonte configurada
        no sistema.

.......................................................................................
<A NAME="7.81"><b>7.81 textwidth</b></A>
        Esta função retorna a largura da string em pixels.
        <b style="color:green">
        int far textwidth(char far *textstring);
        nWidth = textwidth(sMsg);</b>

        Ex.:    int nWidth;
                char sMsg[]="AAAAA";
                nWidth = textwidth(sMsg);
                printf("%d\n",nWidth);
                /* Resulta em 40 */

        Para obter nWidth esta função multiplica o comprimento da string (strlen())
        pela largura da fonte.


<table align=bottom border=0 cellspacing=0 cellpadding=0 width=20%><tr><td><a href=cbiblioteca.html style='color:blue'> index </a></td><td><a href='track06.html'style='color:blue'>&lt;&lt;</a></td><td><a href='track08.html'style='color:blue'>&gt;&gt;</a></td></tr></table><hr><div style='background-color:lightyellow;color:blue'>
<center>Produzido por Gameprog: Jair Pereira - Fev/2006 - Junho/2013 ©
gameprog.br@gmail.com
<a href='http://www.gameprog.com.br'>http://www.gameprog.com.br</a></center><hr></div></body></html>
