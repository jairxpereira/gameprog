<html><head>
<title>cbiblioteca_track04_string</title>
<style type="text/css">

span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc2 {
	color: #008000;
}
.sc4 {
	color: #ff8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #FF0000;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #400080;
}

.prg {
	color: #0000FF;
}
</style></head>
<body><font color="black"><pre>
<hr>
<center><b>GAMEPROG - Escola de programação de jogos digitais</b><br><b>Contato: Jair Pereira - gameprog.br@gmail.com</b><br><b>Guia completo de referência da biblioteca padrão da Linguagem C [Borland Turbo C/++ ver 3.1]</b><br><b>track04.html</b><br></center><table align=bottom border=0 cellspacing=0 cellpadding=0 width=20%><tr><td><a href=cbiblioteca.html style='color:blue'> index </a></td><td><a href='track03.html'style='color:blue'>&lt;&lt;</a></td><td><a href='track05.html'style='color:blue'>&gt;&gt;</a></td></tr></table>
<hr>
<A NAME="4.00"></A>
<center><h2>4.00 string.h</h2></center>
<A HREF="#4.01">4.01</a> memccpy...........Copia um bloco de memória de tamanho determinado para outro bloco
<A HREF="#4.02">4.02</a> memchr............Pesquisa por um byte numa array
<A HREF="#4.03">4.03</a> memcmp............Compara os primeiros bytes de duas strings
<A HREF="#4.04">4.04</a> memcpy............Copia um número de bytes do bloco fonte para o bloco destino
<A HREF="#4.05">4.05</a> memicmp...........Compara os primeiros bytes de duas strings ignorando case
<A HREF="#4.06">4.06</a> memmove...........Copia um número determinado de bytes para o bloco destino
<A HREF="#4.07">4.07</a> memset............Insere num bloco de memória um char em determinado número
<A HREF="#4.08">4.08</a> movedata..........Copia uma região de memória fonte para região de destino
<A HREF="#4.09">4.09</a> movmem............Move um número de bytes do bloco fonte para o bloco destino
<A HREF="#4.10">4.10</a> setmem............Insere um mesmo valor dentro de uma região determinada de memória
<A HREF="#4.11">4.11</a> stpcpy............Copia uma string para outra string
<A HREF="#4.12">4.12</a> strcat............Concatena duas strings

<A HREF="#4.13">4.13</a> strchr............Pesquisa um carácter numa string
<A HREF="#4.14">4.14</a> strcmp............Compara duas strings
<A HREF="#4.15">4.15</a> strcmpi...........Esta função compara duas string ignorando caixa (macro)
<A HREF="#4.16">4.16</a> strcpy............Copia string fonte para string destino
<A HREF="#4.17">4.17</a> strcspn...........Encontra a posição de divergência entre duas strings
<A HREF="#4.18">4.18</a> strdup............Duplica uma string na memória
<A HREF="#4.19">4.19</a> _strerror.........Agrega uma string à string gerada pelo último erro ocorrido no programa
<A HREF="#4.20">4.20</a> strerror..........Retorna a mensagem de erro correspondente ao número fornecido
<A HREF="#4.21">4.21</a> stricmp...........Esta função compara duas string ignorando caixa
<A HREF="#4.22">4.22</a> strlen............Retorna o tamanho da string apresentada
<A HREF="#4.23">4.23</a> strlwr............Converte toda uma string para caixa baixa
<A HREF="#4.24">4.24</a> strncat...........Insere uma string no final de outra string

<A HREF="#4.25">4.25</a> strncmp...........Compara um número determinado de bytes de duas strings.
<A HREF="#4.26">4.26</a> strncmpi..........Compara um número de bytes de duas strings, ignorando case. (macro)
<A HREF="#4.27">4.27</a> strncpy...........Copia uma número de bytes de uma string para outra
<A HREF="#4.28">4.28</a> strnicmp..........Compara um número de bytes de duas strings, ignorando case.
<A HREF="#4.29">4.29</a> strnset...........Substitui os primeiros caracteres de uma string pelo char especificado
<A HREF="#4.30">4.30</a> strpbrk...........Pesquisa caracteres numa string
<A HREF="#4.31">4.31</a> strrchr...........Pesquisa a última ocorrência de um char na string

<A HREF="#4.32">4.32</a> strrev............Inverte os caracteres de uma string uma string
<A HREF="#4.33">4.33</a> strset............Substitui todos os caracteres de uma string pelo caracter especificado
<A HREF="#4.34">4.34</a> strspn............Pesquisa posicão inicial de divergência de duas strings
<A HREF="#4.35">4.35</a> strstr............Procura uma substring numa string
<A HREF="#4.36">4.36</a> strtok............Pesquisa um delimitador na string
<A HREF="#4.37">4.37</a> strupr............Converte toda uma string para caixa alta

.......................................................................................
<A NAME="4.01"><b>4.01 memccpy</b></A>
        Esta função copia um número determinado de bytes de um bloco de memória
        fonte para um bloco de memória destino ou copia o bloco fonte até encontrar
        o delimitador que indica o final da fonte.
        <b style="color:green">
        void *memccpy(void *dest, const void *src, int c, size_t n);
        sResult = memccpy(sDest, sFonte, cChar, nBytes);</b>

        sResult...o retorno da função, explicado depois do programa exemplo
        sDest.....o bloco destino
        sFonte....o bloco fonte
        cChar.....o delimitador que indica até onde a string fonte será copiada
        nBytes....o número de bytes para copiar da fonte para destino

        Ex.:    char sMemoria[]="ABCDEFGHIJKLMNOPQRSTUVWXYZ\x0";
                char sDestino[80];
                char *sPtr;
                char cDelimiter='.';
                sPtr = memccpy(sDestino,sMemoria,cDelimiter,27);
                printf("%s %s\n",sDestino,sPtr);
                /* Resulta em ABCDEFGHIJKLMNOPQRSTUVWXYZ (null)*/

        Veja este programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "string.h"

        /* memccpy() */

        char sFonte[]="Memory.Tests";
        char  sDest[]="????????????";
        char cChar='.';
        char *sResult;
        int nTam;

        int main (int nCmd, char **sCmd) {

        clrscr();
        printf("Antes de memccpy():\n");
        printf("sFonte: %s\n",sFonte);
        printf(" sDest: %s\n\n",sDest);

        nTam = strlen(sFonte);
        sResult =memccpy(sDest,sFonte,cChar,nTam);

        printf("Depois de memccpy():\n");
        printf("sFonte: %s\n",sFonte);
        printf(" sDest: %s\n",sDest);
        printf("sResult: %s\n",sResult);

        puts("\nEnd of Program");
        getch();
        }</font>

        Saída:
        Antes de memccpy():
        sFonte: Memory.Tests
         sDest: ????????????

        Depois de memccpy():
        sFonte: Memory.Tests
         sDest: Memory.?????
        sResult: ?????

        End of Program

        Detalhes:
        Como você pode observar na saída do programa, esta função
        quando encontra o delimitador retorna o restante da string
        que está depois do delimitador. Caso o delimitador não seja
        encontrado e o número de bytes determinado seja exatamente
        copiado a função retorna NULL.

.......................................................................................
<A NAME="4.02"><b>4.02 memchr</b></A>
        Esta função pesquisa os primeiros bytes de uma array procurando um
        valor determinado.
        <b style="color:green">
        void *memchr(const void *s, int c, size_t n);
        sPtr = memchr(sMemoria, cChar, nBytes);</b>

        Ex.:    char sMemoria[]="ABCDEFGHIJK";
                char cChar='F';
                int nBytes = 7;
                char *sPtr;
                sPtr= memchr(sMemoria,cChar,nBytes);
                printf("%s\n",sPtr);
                /* Resulta em FGHIJK */

        Detalhes:
        Neste pequeno exemplo, a função memchr() pesquisa os primeiros
        nBytes da string sMemoria procurando por cChar. Caso o valor
        seja encontrado, a função retorna um ponteiro que aponta para
        ele. A função retorna NULL se o valor procurado não ocorrer
        na string.

.......................................................................................
<A NAME="4.03"><b>4.03 memcmp</b></A>
        Esta função compara os primeiros bytes de duas strings. Essa
        função é case sensitive ('A' != 'a').
        <b style="color:green">
        int memcmp(const void *s1, const void *s2, size_t n);
        nResult = memcmp(sName, sOtherName, nBytes);</b>

        nBytes.....Determina o número de bytes que serão comparados.

        Ex.:    char sName[]="ordem";
                char sOtherName[]="ordem";
                int nResult,nBytes=5;
                nResult = memcmp(sName,sOtherName,nBytes);
                if (!nResult) printf("Estas strings são iguais!\n");
                /* Resulta em Estas strings são iguais! */

        Veja mais este programa:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include "string.h"

        /* memcmp() */

        int main (int nCmd, char **sCmd) {

        char sStr_x[]="ordem";
        char sStr_y[]="ORDEM";
        char sStr_z[]="ordem";
        char sStr_u[]="Rigor";
        int nBytes = 5;
        int nResult;

        clrscr();

        nResult = memcmp(sStr_x,sStr_y,nBytes);
        printf("%s %d %s\n",sStr_x,nResult, sStr_y);

        nResult = memcmp(sStr_x,sStr_z,nBytes);
        printf("%s %d %s\n",sStr_x,nResult, sStr_z);

        nResult = memcmp(sStr_x,sStr_u,nBytes);
        printf("%s %d %s\n",sStr_x,nResult, sStr_u);

        puts("\nEnd of Program");
        getch(); }</font>

        Saída:
        ordem 32 ORDEM
        ordem 0 ordem
        ordem 29 Rigor
        End of Program

.......................................................................................
<A NAME="4.04"><b>4.04 memcpy</b></A>
        Esta função copia um número determinado de bytes do bloco fonte para
        o bloco destino.
        <b style="color:green">
        void *memcpy(void *dest, const void *src, size_t n);
        sDest = memcpy(sDestino,sFonte,nBytes);</b>

        Ex.:    char sFonte[]="Programar é legal!";
                char sDestino[48];
                int nBytes;
                nBytes = strlen(sFonte) + 1;
                memcpy(sDestino,sFonte,nBytes);
                printf("%s\n",sDestino);
                /* Resulta em Programar é legal! */

        Detalhes: A função retorna um ponteiro para sDestino.

.......................................................................................
<A NAME="4.05"><b>4.05 memicmp</b></A>
        Esta função compara os primeiros bytes de duas strings. Essa
        função ignora caixa ('A' = 'a').
        <b style="color:green">
        int memicmp(const void *s1, const void *s2, size_t n);
        nResult = memicmp(sName, sOtherName, nBytes);</b>

        nBytes.....Determina o número de bytes que serão comparados.

        Ex.:    char sName[]="ordem";
                char sOtherName[]="Ordem";
                int nResult,nBytes=5;
                nResult = memicmp(sName,sOtherName,nBytes);
                if (!nResult) printf("Estas strings são iguais!\n");
                /* Resulta em Estas strings são iguais! */

        Veja mais este programa:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "string.h"

        /* memicmp() */

        int main (int nCmd, char **sCmd) {

        char sStr_x[]="ordem";
        char sStr_y[]="ORDEM";
        char sStr_z[]="ordem";
        char sStr_u[]="Rigor";
        int nBytes = 5;
        int nResult;

        clrscr();

        nResult = memicmp(sStr_x,sStr_y,nBytes);
        printf("%s %d %s\n",sStr_x,nResult, sStr_y);

        nResult = memicmp(sStr_x,sStr_z,nBytes);
        printf("%s %d %s\n",sStr_x,nResult, sStr_z);

        nResult = memicmp(sStr_x,sStr_u,nBytes);
        printf("%s %d %s\n",sStr_x,nResult, sStr_u);

        puts("\nEnd of Program");
        getch(); }</font>

        Saída:
        ordem 0 ORDEM
        ordem 0 ordem
        ordem -3 Rigor
        End of Program

.......................................................................................
<A NAME="4.06"><b>4.06 memmove</b></A>
        Esta função copia um número determinado de bytes de um bloco fonte
        para um bloco destino.
        <b style="color:green">
        void *memmove(void *dest, const void *src, size_t n);
        sPtr = memmove(sDestino,sFonte, nBytes);</b>

        sPtr......A função retorna um ponteiro para sDestino
        nBytes....O número de bytes que será copiado
        sDestino..O bloco receptor
        sFonte....O bloco fonte

        Ex.:    char sFonte[]="Seja sempre metódico";
                char sDestino[40];
                char *sPtr;
                size_t nBytes=0;
                nBytes = strlen(sFonte)+1;
                sPtr = memmove(sDestino,sFonte,nBytes);
                printf("%s\n%s\n",sDestino,sPtr);
                /* Resulta em
                        Seja sempre metódico
                        Seja sempre metódico */

........................................................................................
<A NAME="4.07"><b>4.07 memset</b></A>
        Esta função insere num bloco de memória um caracter repetido um número
        de vezes.
        <b style="color:green">
        void *memset(void *s, int c, size_t n);
        sMemoria = memset(sMemoria,cChar, nBytes);</b>

        Ex.:    char sMemoria[16]="00000000";
                char cChar='?';
                size_t nBytes=4;
                memset(sMemoria,cChar,nBytes);
                printf("%s\n",sMemoria);
                /* Resulta em ????0000 */

        Detalhes:       A função retorna um ponteiro para sMemoria.

.......................................................................................
<A NAME="4.08"><b>4.08 movedata</b></A>
        Esta função copia um número determinado de bytes de uma região de memória fonte
        para uma região de memória destino. As regiões de memória fonte e destino
        são dadas em termos de segmento e deslocamento.

        Bem, Só o estudo do Assembly em profundidade possilita um maior domínio
        e uma melhor compreensão dos computadores. Aos mais ousados eu deixo a
        recomendação de estudar assembly 8086. Neste momento eu vou adiantar
        apenas o suficiente que vai possibilitar o uso desta função sem embaraços.

        Em MsDos, a memória é dividida em blocos de 64K. Estes blocos são
        chamados de segmentos. Dentro do segmento cada byte tem sua posição,
        sendo que esta pode ser de 0 a 65535, esta posição do byte é
        chamada deslocamento, offset em inglês.

        A localização de um byte na memória é dada assim segmento:deslocamento,
        então é comum vermos isto 0000:4800 em MsDos. O deslocamento do byte
        é na verdade um deslocamento do byte em relação ao segmento, por
        exemplo, 0000:4800 quer dizer que o byte se afastou 4800 bytes do
        segmento que assinala sua origem. Esta localização é relativa.
        A localização real do byte na placa de memória é dada pela multiplicação
        do segmento pelo deslocamento.

        Há vários segmentos especiais de memória, dois deles é o segmento de
        video em modo texto 0xB800 e o segmento de vídeo em modo gráfico em
        alta resolução Dos que é 0xA000.

        Em video modo 13, 320x100x256 cores, você pode acender os pixels
        colocando bytes no endereço de vídeo. Colocando um byte de valor
        quatorze no endereço A000:0000 você acende a coordenada (0,0) na
        cor amarela. O acendimento dos outros pixels é realizado colocando
        valores nos deslocamentos consecutivos. A manipulação da tela por esta
        via é muito mais rápida do que usando funções para isso. As operações
        de memória geram efeitos mais rápidos.

        A região de memória de texto, começa em 0xB800, sendo que o deslocamento
        par recebe o código ascii do carácter, o deslocamento impar recebe o
        byte de atributo que determina a cor de frente e de fundo do carácter.
        Assim, para colocar um A na linha 1, coluna 1, na cor de fundo azul
        e frente branca, você só faz isto:

        pokeb(0xB800,0,65);
        pokeb(0xB800,1,0x1F);

        Os processadores da série x86 (8086,80286,80386...)possuem variáveis
        internas básicas para trabalhar com segmentos que são:

        CS....aponta para uma região da memória aonde tem instruções para execução.
        DS....aponta para região de dados fonte
        ES....aponta para região de dados destino
        SS....aponta para a região de memória que é usada como pilha.

        Bem, isto é tudo no momento sobre memória, segmento e deslocamento.
        <b style="color:green">
        void movedata(unsigned srcseg, unsigned srcoff,
                                 unsigned destseg, unsigned destoff, size_t n);

        movedata (nSegmentoFonte,nDeslocamentoFonte,
                        nSegmentoDestino, nDeslocamentoDestino, nBytes);</b>

        nSegmentoFonte..........Segmento fonte (0 a 65335)
        nDeslocamentoFonte......Deslocamento fonte (0 a 65535)
        nSegmentoDestino........Segmento fonte (0 a 65335)
        nDeslocamentoDestino....Deslocamento fonte (0 a 65535)
        nBytes..................Número de bytes a ser copiado

        Veja o programa exemplo:<font color="darkblue">

        #include "stdio.h"
        #include "conio.h"
        #include "string.h"

        void main (void) {
        char text[]="d.a.d.o.s. .d.a.d.o.s. .d.a.d.o.s.";
        int nBytes;

        clrscr();

        nBytes = strlen(text);

        movedata(_DS, (unsigned) text, 0xB800, 0,nBytes);

        puts("\nEnd of Program");
        getch();

        }</font>

        Saída:
        <b style="color:yellow;background-color=green">dados dados dados</b>
        End of Program

        Detalhes:
        0123456789      Conforme foi dito, o deslocamento par recebe o carácter
        d.a.d.o.s.      O deslocamento impar, recebe o atributo. O valor do
                        ponto final é 46, que gera fundo verde e frente amarela.

        <u style="color:blue">movedata(_DS, (unsigned) text, 0xB800, 0,nBytes);</u>
        _DS...............Aponta para DS, o segmento de dados aonde ficam as strins
        (unsigned)text....Toda variável string é um ponteiro. O ponteiro sempre aponta
                          para uma região de memória. Neste caso, text representa o
                          deslocamento inicial dos dados.
        0xB800............Segmento de destino que recebe os dados
        0.................Deslocamento inicial do segmento
        nBytes............O número de bytes a serem copiados, configuramos para
                          ter o tamanho da string text.

.......................................................................................
<A NAME="4.09"><b>4.09 movmem</b></A>
        Esta função copia um número determinado de bytes do bloco de memória
        fonte para o bloco de memória destino.
        <b style="color:green">
        void movmem(void *src, void *dest, unsigned length);
        movmem(sFonte,sDestino,nBytes);</b>

        nBytes....Número de bytes a ser copiado, podendo ser até 64K (65535)

        Ex.:    char sFonte[]="Estude sempre para ser perito!";
                char sDestino[80];
                unsigned int nBytes;
                nBytes = strlen(sFonte)+1;
                movmem(sFonte,sDestino,nBytes);
                printf("%s\n",sDestino);
                /* Resulta em Estude sempre para ser perito! */

.......................................................................................
<A NAME="4.10"><b>4.10 setmem</b></A>
        Esta função insere um mesmo valor dentro de uma região determinada
        de memória em bytes. Na prática, ela funciona de maneira semelhante
        a memset().
        <b style="color:green">
        void setmem(void *dest, int len, char value);
        setmem(sMemoria, nBytes, cValue);</b>

        Ex.:    char sMemoria[16]="0000000";
                char cValor=65;
                int nBytes=4;
                setmem(sMemoria,nBytes,cValor);
                printf("%s\n",sMemoria);
                /* Resulta em AAAA0000 */

.......................................................................................
<A NAME="4.11"><b>4.11 stpcpy</b></A>
        Esta função copia uma string para outra string, noutras palavras,
        o contéudo de string fonte é copiado para a string destino,
        sobreescrevendo esta última.
        <b style="color:green">
        char *stpcpy(char *dest, const char *src);
        stpcpy(sDest,sFonte);</b>

        Ex.:    char sDest[]="Ordem é ";
                char sFonte[]="progresso!";
                stpcpy(sDest,sFonte);
                printf("%s\n",sDest);
                /* Resulta em progresso! */

.......................................................................................
<A NAME="4.12"><b>4.12 strcat</b></A>
        Esta função concatena duas strings, noutras palavras ela adiciona
        a string fonte na string destino.
        <b style="color:green">
        char *strcat(char *dest, const char *src);
        sDest = strcat(sDest,sFonte);</b>

        Ex.:    char sDest[]="Ordem é ";
                char sFonte[]="Progresso!";
                strcat(sDest,sFonte);
                printf("%s\n",sDest);
                /* Resulta em Ordem é progresso!"
.......................................................................................
<A NAME="4.13"><b>4.13 strchr</b></A>
        Esta função pesquisa um char numa string. Ela busca a primeira ocorrência
        do carácter na string fornecida. Caso o char seja localizado, é retornado
        um ponteiro para a string reduzida até a posição do char localizado.
        <b style="color:green">
        char *strchr(const char *str, int c);
        sSubStr = strchr(sName, cChar);</b>

        Ex.:    char *sName="Honestidade";
                char *sTest;
                unsigned char cLookingFor='i';
                sTest = strchr(sName,cLookingFor);
                printf("%s",sTest);
                /* Resulta em idade */

        Detalhes:
        Caso o carácter não esteja na string na string, o valor
        de retorno é um ponteiro nulo. A pesquisa é feita da esquerda
        para a direita na string.

.......................................................................................
<A NAME="4.14"><b>4.14 strcmp</b></A>
 Esta função compara duas strings, retornando zero se elas são iguais.
        <b style="color:green">
        int strcmp(const char *s1, const char *s2)
        nSts = strcmp(sStr_x, sStr_y);</b>

        Ex.:    char sStr_x[]="rato";
                char sStr_y[]="pato";
                if (!strcmp(sStr_x,sStr_y)) printf("Estas strings são iguais.");

        Veja este programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "string.h"

        int main (int nCmd, char **sCmd) {
        char sStr_x[]="mouse";
        char sStr_y[]="rato";
        char sStr_z[]="mouse";
        char sStr_u[]="MOUSE";

        int nSts;

        clrscr();

        nSts = strcmp(sStr_x, sStr_y);

        printf("%s \t%d \t%s \n",sStr_x,nSts, sStr_y);

        nSts = strcmp(sStr_x, sStr_z);
        printf("%s \t%d \t%s \n",sStr_x,nSts, sStr_z);

        nSts = strcmp(sStr_x, sStr_u);
        printf("%s \t%d \t%s \n",sStr_x,nSts, sStr_u);

        puts("\nEnd of Program");
        getch(); }</font>

        Este programa produz esta saída:
        mouse   -5      rato
        mouse   0       mouse
        mouse   32      MOUSE
        End of Program

.......................................................................................
<A NAME="4.15"><b>4.15 strcmpi</b></A>
        Esta função compara duas strings, ignorando caixa( A=a).
        Zero é o retorno em caso de igualdade, non-zero para diferente.
        <b style="color:green">
        int strcmpi(const char *s1, const char *s2)
        nSts = strcmpi(sStr_x, sStr_y);</b>

        Ex.:    char sStr_x[]="PATO";
                char sStr_y[]="pato";
                if (!strcmpi(sStr_x,sStr_y)) printf("Estas strings são iguais.");

        Detalhes:
        Esta função é uma macro que se desdobra na função stricmp().
        Ela existe para manter a compatibilidade entre compiladores.

        Veja este programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "string.h"

        int main (int nCmd, char **sCmd) {

        char sStr_x[]="mouse";
        char sStr_y[]="rato";
        char sStr_z[]="mouse";
        char sStr_u[]="MOUSE";

        int nSts;

        clrscr();

        nSts = strcmpi(sStr_x, sStr_y);

        printf("%s \t%d \t%s \n",sStr_x,nSts, sStr_y);

        nSts = strcmpi(sStr_x, sStr_z);
        printf("%s \t%d \t%s \n",sStr_x,nSts, sStr_z);

        nSts = stricmpi(sStr_x, sStr_u);
        printf("%s \t%d \t%s \n",sStr_x,nSts, sStr_u);

        puts("\nEnd of Program");
        getch(); }</font>

        Este programa produz esta saída:
        mouse   -5     rato
        mouse   0      mouse
        mouse   0      MOUSE
        End of Program

.......................................................................................
<A NAME="4.16"><b>4.16 strcpy</b></A>
        Esta função copia a string destino para a string fonte.
        <b style="color:green">
        char *strcpy(char *dest, const char *src);
        strcpy(sDestino, sFonte);</b>

        Ex.:    char sFonte[]="Seja perseverante!";
                char sDestino[40];
                strcpy (sDestino,sFonte);
                printf("sDestino: %s\n",sDestino);

        Detalhes: Esta função retorna sDestino.
.......................................................................................
<A NAME="4.17"><b>4.17 strcspn</b></A>
        Esta função encontra a posição de divergência entre duas strings.
        A finalidade e utilidade desta função não foram bem compreendidos,
        a tradução literal do texto da Borland é esta:
        "Esta função encontra o segmento inicial da primeira string que
        consiste completamente de caracteres não-presentes na segunda string."
        <b style="color:green">
        size_t strcspn(const char *s1, const char *s2);
        nIntersect = strcspn(sPrimeira,sSegunda);</b>

        Ex.:    char sPrimeira[]="ordem";
                char sSegunda[]="m";
                int nIntersect;
                nIntersect = strcspn(sPrimeira,sSegunda);
                printf("%d \n",nIntersect);
                /* Resulta em 4 */

        Veja este teste e sua saída para uma tentativa de compreensão:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int main (int nCmd, char **sCmd) {
        char sFirst[]="ordem";
        char sSnd[] = "m";
        size_t nIntersect;

        clrscr();
        nIntersect = strcspn(sFirst,sSnd);
        printf("01234    <-- Posições\n");
        printf("%s    <-- Primeira string\n",sFirst);
        printf("....%s    <-- Segunda string\n",sSnd);
        printf("%d        <--intersecão da segunda string na primeira string",nIntersect);

        puts("\nEnd of Program");
        getch(); }</font>

        Saída:
        01234    <-- Posições
        ordem    <-- Primeira string
        ....m    <-- Segunda string
        4        <--intersecção da segunda string na primeira string
        End of Program

.......................................................................................
<A NAME="4.18"><b>4.18 strdup</b></A>
        Esta função duplica uma string na memória.
        <b style="color:green">
        char *strdup(const char *s);
        sPtr = strdup(sName);</b>

        Ex.:    char sName[]="Programando em C";
                char *sPtr;
                sPtr = strdup(sName);
                printf("%s",sPtr);
                free(sPtr);
                /* Resulta em Programando em C */

        Detalhes:
        O valor de retorno é uma duplicata da string sName que vai
        no argumento. Caso a função não consiga memória para
        duplicar a string, o valor de retorno é NULL.
        Esta função deixa para o usuário o encargo de liberar a
        memória depois do uso da duplicata free(sPtr).

.......................................................................................
<A NAME="4.19"><b>4.19 _strerror</b></A>
        Esta função agrega uma string de usuário a uma string gerada pelo
        último erro ocorrido no programa.
        <b style="color:green">
        char *_strerror(const char *s);
        sUserMsgErrorMsg = _strerror(sUserMsg);</b>

        Ex.:    char    *sMsg="Erro ocorrido: ";
                /* Suponha aqui um processo que chama um arquivo inexistente */
                printf(_strerror(sMsg));
                /* Resulta em Erro ocorrido: No such file or directory */

.......................................................................................
<A NAME="4.20"><b>4.20 strerror</b></A>
        Esta função retorna a mensagem de erro correspondente ao número
        fornecido.
        <b style="color:green">
        char *strerror(int errnum);
        sErroMsg = strerror(nNumber);</b>

        Ex.: printf(strerror(2));       /* Resulta em No such file or directory */

.......................................................................................
<A NAME="4.21"><b>4.21 stricmp</b></A>
        Esta função compara duas strings, ignorando caixa( A=a).
        Zero é o retorno em caso de igualdade, non-zero para diferente.
        <b style="color:green">
        int stricmp(const char *s1, const char *s2)
        nSts = stricmp(sStr_x, sStr_y);</b>

        Ex.:    char sStr_x[]="PATO";
                char sStr_y[]="pato";
                if (!stricmp(sStr_x,sStr_y)) printf("Estas strings são iguais.");

        Detalhes: a função strcmpi() é uma macro que se desdobra nesta função.

        Veja este programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "string.h"

        int main (int nCmd, char **sCmd) {

        char sStr_x[]="mouse";
        char sStr_y[]="rato";
        char sStr_z[]="mouse";
        char sStr_u[]="MOUSE";

        int nSts;

        clrscr();

        nSts = stricmp(sStr_x, sStr_y);

        printf("%s \t%d \t%s \n",sStr_x,nSts, sStr_y);

        nSts = stricmp(sStr_x, sStr_z);
        printf("%s \t%d \t%s \n",sStr_x,nSts, sStr_z);

        nSts = stricmp(sStr_x, sStr_u);
        printf("%s \t%d \t%s \n",sStr_x,nSts, sStr_u);

        puts("\nEnd of Program");
        getch(); }</font>

        Este programa produz esta saída:
        mouse   -5     rato
        mouse   0      mouse
        mouse   0      MOUSE

        End of Program

.......................................................................................
<A NAME="4.22"><b>4.22 strlen</b></A>
        Esta função retorna o tamanho da string apresentada, o carácter nulo não
        é contado.
        <b style="color:green">
        size_t strlen(const char *s);
        nTam = strlen(sName);</b>

        Ex.:    char sName[]="Ordem";
                printf("Tamanho do nome: %d",strlen(sName));
                /* Resulta em Tamanho do nome: 5 */

.......................................................................................
<A NAME="4.23"><b>4.23 strlwr</b></A>
        Esta função converte toda uma string para caixa baixa (letras minúsculas),
        retornando um ponteiro para esta string.
        <b style="color:green">
        char *strlwr(const char *s);
        sLowerCase = strlwr(sName);</b>

        Ex.:    char sName[]="CHARLES WEBSTER LEADBEATER";
                strlwr(sName);
                printf("%s \n",sName);
                /* Resulta em charles webster leadbeater */

.......................................................................................
<A NAME="4.24"><b>4.24 strncat</b></A>
        Esta função insere um número determinado de caracteres da string fonte
        no final da string destino, retornando a string destino acrescida dos
        novos caracteres.
        <b style="color:green">
        char *strncat(const char *dest, const char *src, size_t maxlen);
        sDestino = strncat(sDestino,sFonte,nBytes);</b>

        sDestino........String destino que recebe bytes da string fonte
        sFonte..........String fonte que cede n bytes para string destino
        nBytes..........Quantidade de letras da string fonte que vai ser inserido na
                        string destino.

        Ex.:    char sDest[40]="Seja ";
                char sFonte[]="perseverante!";
                int nBytes;
                nBytes = strlen(sFonte);
                strncat(sDest,sFonte,nBytes);
                printf("%s\n",sDest);
                /* Resulta em Seja perseverante!");

.......................................................................................
<A NAME="4.25"><b>4.25 strncmp</b></A>
        Esta função compara um número determinado de bytes de duas strings.
        <b style="color:green">
        int strncmp(const char *s1, const char *s2, size_t maxlen);
        nResult = strncmp(sNamex,sNamey,nBytes);</b>

        Ex.:    char sNamex[]="Programador";
                char sNamey[]="Profissional";
                int nBytes=3;
                int nResult;
                nResult=strncmp(sNamex,sNamey,nBytes);
                if (!nResult) printf("Estas string têm os inícios iguais!");
                /* Resulta em Estas strings têm os inícios iguais! */

        Detalhes: Em caso de igualdade o valor de retorno é zero, sendo
                  non-zero para diferente. A função é case sensitive.

        Veja este programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "string.h"

        /* strncmp() */

        int main (int nCmd, char **sCmd) {

        char sStr_x[]="mouse";
        char sStr_y[]="MOUTH";
        char sStr_z[]="rato ";
        char sStr_u[]="mouth";

        int nBytes = 3;
        int nResult;

        clrscr();

        nResult = strncmp(sStr_x,sStr_y,nBytes);
        printf("%s %d %s\n",sStr_x,nResult,sStr_y);

        nResult = strncmp(sStr_x,sStr_z,nBytes);
        printf("%s %d %s\n",sStr_x,nResult,sStr_z);

        nResult = strncmp(sStr_x,sStr_u,nBytes);
        printf("%s %d %s\n",sStr_x,nResult,sStr_u);

        puts("\nEnd of Program.");
        getch(); }</font>

        Saída:
        mouse 32 MOUTH
        mouse -5 rato
        mouse 0 mouth

        End of Program.

        * Cuidado para não se enrolar com esta função, esse resultado 'mouse 0 mouth'
        se deu apenas porque comparamos os três primeiros bytes das duas
        strings que são realmente iguais, embora no todo as strings não são iguais.

.......................................................................................
<A NAME="4.26"><b>4.26 strncmpi</b></A>
        Esta função compara um número determinado de bytes de duas strings,
        ignorando case, isto é, (A = 'A') nesta comparação.
        <b style="color:green">
        int strncmpi(const char *s1, const char *s2, size_t maxlen);
        nResult = strncmpi(sNamex,sNamey,nBytes);</b>

        Ex.:    char sNamex[]="Programador";
                char sNamey[]="profissional";
                int nBytes=3;
                int nResult;
                nResult=strncmpi(sNamex,sNamey,nBytes);
                if (!nResult) printf("Estas string têm os inícios iguais!");
                /* Resulta em Estas strings têm os inícios iguais! */

        Detalhes: Em caso de igualdade o valor de retorno é zero, sendo
                  non-zero para diferente. Esta macro simula a função
                  strnicmp().

        Veja este programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "string.h"

        /* strncmpi() */

        int main (int nCmd, char **sCmd) {

        char sStr_x[]="mouse";
        char sStr_y[]="MOUTH";
        char sStr_z[]="rato ";
        char sStr_u[]="mouth";

        int nBytes = 3;
        int nResult;

        clrscr();

        nResult = strncmpi(sStr_x,sStr_y,nBytes);
        printf("%s %d %s\n",sStr_x,nResult,sStr_y);

        nResult = strncmpi(sStr_x,sStr_z,nBytes);
        printf("%s %d %s\n",sStr_x,nResult,sStr_z);

        nResult = strncmpi(sStr_x,sStr_u,nBytes);
        printf("%s %d %s\n",sStr_x,nResult,sStr_u);

        puts("\nEnd of Program.");
        getch(); }</font>

        Saída:
        mouse 0 MOUTH
        mouse -5 rato
        mouse 0 mouth

        End of Program.

        * Cuidado para não se enrolar com esta função, esse resultado 'mouse 0 mouth'
        se deu apenas porque comparamos os três primeiros bytes das duas
        strings que são realmente iguais, embora no todo as strings não são iguais.

.......................................................................................
<A NAME="4.27"><b>4.27 strncpy</b></A>
        Esta função copia um número determinado de bytes da string fonte
        para a string destino, sobreescrevendo o conteúdo desta última.
        Essa função não agrega o byte de fim de string '\0' na string destino.
        <b style="color:green">
        char *strncpy(char *dest, const char *src, size_t maxlen);
        sDest = strncpy(sDest,sFonte,nBytes);</b>

        Ex.:    char sDest[]="Felicidade";
                char sFonte[]="?????????";
                strncpy(sDest,sFonte,4);
                printf("%s\n",sDest);
                /* Resulta em ????cidade */

.......................................................................................
<A NAME="4.28"><b>4.28 strnicmp</b></A>
        Esta função compara um número determinado de bytes de duas strings,
        ignorando case, isto é, (A = 'A') nesta comparação.
        <b style="color:green">
        int strnicmp(const char *s1, const char *s2, size_t maxlen);
        nResult = strnicmp(sNamex,sNamey,nBytes);</b>

        Ex.:    char sNamex[]="Programador";
                char sNamey[]="profissional";
                int nBytes=3;
                int nResult;
                nResult=strnicmp(sNamex,sNamey,nBytes);
                if (!nResult) printf("Estas string têm os inícios iguais!");
                /* Resulta em Estas strings têm os inícios iguais! */

        Detalhes:
        Em caso de igualdade o valor de retorno é zero, sendo
        non-zero para diferente. Há a macro strncmpi() que simula
        esta função.

        Veja este programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "string.h"

        /* strnicmp() */

        int main (int nCmd, char **sCmd) {

        char sStr_x[]="mouse";
        char sStr_y[]="MOUTH";
        char sStr_z[]="rato ";
        char sStr_u[]="mouth";

        int nBytes = 3;
        int nResult;

        clrscr();

        nResult = strnicmp(sStr_x,sStr_y,nBytes);
        printf("%s %d %s\n",sStr_x,nResult,sStr_y);

        nResult = strnicmp(sStr_x,sStr_z,nBytes);
        printf("%s %d %s\n",sStr_x,nResult,sStr_z);

        nResult = strnicmp(sStr_x,sStr_u,nBytes);
        printf("%s %d %s\n",sStr_x,nResult,sStr_u);

        puts("\nEnd of Program.");
        getch(); }</font>

        Saída:
        mouse 0 MOUTH
        mouse -5 rato
        mouse 0 mouth

        End of Program.

        * Cuidado para não se enrolar com esta função, esse resultado 'mouse 0 mouth'
        se deu apenas porque comparamos os três primeiros bytes das duas
        strings que são realmente iguais, embora no todo as strings não são iguais.

.......................................................................................
<A NAME="4.29"><b>4.29 strnset</b></A>
        Esta função substitui um número determinado de caracteres iniciais de
        uma string pelo caracter especificado.
        <b style="color:green">
        char *strnset(char *s, int c, size_t n);
        sName = strnset(sName,cChar, nBytes);</b>

        Ex.:    char sName[]="Programador";
                char cSinal='.';
                strnset(sName,cSinal,3);
                printf("%s\n",sName);
                /* Resulta em ...gramador */

.......................................................................................
<A NAME="4.30"><b>4.30 strpbrk</b></A>
        Esta função pesquisa caracteres numa string. Dados duas strings,
        string sFonte e sPesquisa, se qualquer um dos caracteres de sPesquisa
        for localizado em sFonte, é retornado um ponteiro que aponta para a
        a substring de sFonte que contém uma primeira ocorrência de algum
        caracter de sPesquisa
        <b style="color:green">
        char *strpbrk(const char *s1, const char *s2)
        sSptr = strpbrk(sFonte,sPesquisa);</b>

        Ex.:    char sFonte[]="Programador!";
                char sPesquisa[]="xygr";
                char *sResult;
                sResult = strpbrk(sFonte,sPesquisa);
                printf(sResult);
                /* Resulta em rogramador! */

        Veja este programa exemplo: <font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "string.h"

        /* strpbrk() */
        char sName[]="Programador!\n";
        char cLookingFor[]="ad";
        char *sResult;

        int main (int nCmd, char **sCmd) {
        clrscr();
        sResult = strpbrk(sName,cLookingFor);

        printf("sName: %s \n",sName);
        printf("sResult: %s\n",sResult);

        puts("\nEnd of Program");
        getch();
        }</font>

        Saída:
        sName: Programador!
        sResult: amador!
        End of Program
.......................................................................................
<A NAME="4.31"><b>4.31 strrchr</b></A>
        Esta função pesquisa a última ocorrência do caracter fornecido na
        string. A pesquisa é realizada da direita para a esquerda.
        <b style="color:green">
        char *strrchr(const char *s, int c);
        sPtr = strrchr(sName,cChar);</b>

        Ex.:    char sName[]="Programador!";
                char cLookingFor='a';
                char *sResult;
                sResult = strrchr(sName,cLookingFor);
                printf(sResult);
                /* Resulta em ador! */

        Detalhes:
        A função retorna um ponteiro apontando para a posição na qual
        o char está localizado. Caso, não exista o char, a funcão
        retorna NULL.

.......................................................................................
<A NAME="4.32"><b>4.32 strrev</b></A>
        Esta função inverte todos caracteres de uma string, o último byte
        passa a ser o primeiro e assim por diante.
        <b style="color:green">
        char *strrev(char *s);
        sName = strrev(sName);</b>

        Ex.:    char sName[]="Roma";
                strrev(sName);
                printf(sName);
                /* Resulta em amoR */

.......................................................................................
<A NAME="4.33"><b>4.33 strset</b></A>
        Esta função substitui todos os caracteres de uma string para o
        caracter especificado.
        <b style="color:green">
        char *strset(char *s, int c);
        sName = strset(sName,cChar);</b>

        Ex.:    char sName[]="Programador";
                char cSinal='.';
                strset(sName,cSinal);
                printf("%s\n",sName);
                /* Resulta em ............ */

.......................................................................................
<A NAME="4.34"><b>4.34 strspn</b></A>
        Esta função pesquisa a posição inicial da divergência entre duas
        strings. O texto da Borland descreve assim sua funcionalidade:
        "encontra o comprimento do segmento inicial de s1 que consiste
        completamente de caracteres de s2"
        <b style="color:green">
        size_t strspn(const char *s1, const char *s2);
        nDivPos = strspn(sName,sOtherName);</b>

        Ex.:    char sName[]="abcdefg";
                char sSub[]="abcxyz";
                int nResult;
                nResult= strspn(sName,sSub);
                printf("nResult: %d",nResult);
                /* Resulta em nResult: 3";

        Veja mais este programinha:<font color="darkblue">
        #include "stdio.h"
        include "conio.h"
        #include "stdlib.h"
        #include "string.h"

        /* strspn() */

        int main (int nCmd, char **sCmd) {

        char sName[]="abcdefg";
        char sSub[]="abcxyz";
        int nResult;

        clrscr();
        nResult = strspn(sName,sSub);

        printf("0123456 <-- Posições\n");
        printf("%s <-- String fonte\n",sName);
        printf("%s <-- SubString\n",sSub);
        printf("%d <-- Início da divergência\n",nResult);

        puts("\nEnd of Program");
        getch(); }</font>

        Saída:
        0123456 <-- Posições
        abcdefg <-- String fonte
        abcxyz <-- SubString
        3 <-- Início da divergência
        End of Program

.......................................................................................
<A NAME="4.35"><b>4.35 strstr</b></A>
        Esta função procura uma substring numa string.
        <b style="color:green">
        char *strstr(const char *s1, const char *s2);
        sResult = strstr(sName,sSubsString);</b>

        Ex.:    char sName[]="Programador!";
                char sSubStr[]="grama";
                char *sResult;
                sResult = strstr(sName,sSubStr);
                printf(sResult);
                /* Resulta em gramador! */

        Detalhes:
        Caso a substring seja localizada, a função retorna um ponteiro
        que aponta para o restante da string que contém a substring. Caso
        não haja a substring, o ponteiro retornado é NULL.


.......................................................................................
<A NAME="4.36"><b>4.36 strtok</b></A>
        Esta função pesquisa por um delimitador numa string, substituindo
        este delimitador pelo indicador de fim de string '\0'. Na segunda chamada,
        colocando NULL no argumento da string, a função retorna o conteúdo que
        estava depois do delimitador.
        <b style="color:green">
        char *strtok(char *s1, const char *s2);
        sPtr = strtok(sName,sDelimitador);</b>

        Ex.:    char sName[]="abc-xyz";
                char sDelimiter[]="-";
                char *sResult;
                sResult = strtok(sName,sDelimiter);
                printf("sResult: %s \t sName: %s \n",sResult,sName);

                sResult = strtok(NULL,sDelimiter);
                printf("sResult: %s \t sName: %s \n",sResult,sName);

                /* Resulta em
                sResult: abc            sName: abc
                sResult: xyz            sName: abc      */

        Veja mais este programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "string.h"

        int main (int nCmd, char **sCmd) {

        char sLinha[]="video = vga";
        char *sPropriedade;
        char *sValor;
        char sDelimiter[]="=";

        clrscr();

        sPropriedade = strtok(sLinha,sDelimiter);
        sValor = strtok(NULL,sDelimiter);

        printf("Propriedade: %s \n",sLinha);
        printf("Valor: %s \n",sValor);

        puts("\nEnd of Program");
        getch(); }</font>

        Saída:
        Propriedade: video
        Valor:  vga
        End of Program

.......................................................................................
<A NAME="4.37"><b>4.37 strupr</b></A>
        Esta função converte toda uma string para caixa alta (letras maiúsculas),
        retornando um ponteiro para esta string.
        <b style="color:green">
        char *strupr(const char *s);
        sUpperCase = strupr(sName);</b>

        Ex.:    char sName="charles webster leadbeater";
                strupr(sName);
                printf("%s \n",sName);
                /* Resulta em CHARLES WEBSTER LEADBEATER */


<table align=bottom border=0 cellspacing=0 cellpadding=0 width=20%><tr><td><a href=cbiblioteca.html style='color:blue'> index </a></td><td><a href='track03.html'style='color:blue'>&lt;&lt;</a></td><td><a href='track05.html'style='color:blue'>&gt;&gt;</a></td></tr></table><hr><div style='background-color:lightyellow;color:blue'>
<center>Produzido por Gameprog: Jair Pereira - Fev/2006 - Junho/2013 ©
gameprog.br@gmail.com
<a href='http://www.gameprog.com.br'>http://www.gameprog.com.br</a></center><hr></div></body></html>
