<html><head>
<title>cbiblioteca_stdio</title>
<style type="text/css">

span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc2 {
	color: #008000;
}
.sc4 {
	color: #ff8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #FF0000;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #400080;
}

.prg {
	color: #0000FF;
}
</style></head>
<body><font color="black"><pre>
<hr>
<center><b>GAMEPROG - Escola de programação de jogos digitais</b><br><b>Contato: Jair Pereira - gameprog.br@gmail.com</b><br><b>Guia completo de referência da biblioteca padrão da Linguagem C [Borland Turbo C/++ ver 3.1]</b><br><b>track01.html</b><br></center><table align=bottom border=0 cellspacing=0 cellpadding=0 width=20%><tr><td><a href=cbiblioteca.html style='color:blue'> index </a></td><td><a href='cbiblioteca.html'style='color:blue'>&lt;&lt;</a></td><td><a href='track02.html'style='color:blue'>&gt;&gt;</a></td></tr></table>
<hr>
<A NAME="1.00"></A>
<center><h2>1.00 stdio.h</h2></center>
<A HREF="#1.01">1.01</a> clearerr..........Limpa indicação de erro e de EOF do arquivo.
<A HREF="#1.02">1.02</a> fclose... ........Fecha um arquivo aberto.
<A HREF="#1.03">1.03</a> fcloseall.........Fecha todos os arquivos abertos
<A HREF="#1.04">1.04</a> fdopen............Associa uma estrutura de arquivo com um handle de arquivo
<A HREF="#1.05">1.05</a> feof..............Verifica se ocorrreu final de arquivo.
<A HREF="#1.06">1.06</a> ferror............Retorna o número de erro de processo de arquivo.
<A HREF="#1.07">1.07</a> fflush............Efetiva a gravação de dados pendentes nos buffers de saída
<A HREF="#1.08">1.08</a> fgetc.............Esta função lê um char de um arquivo
<A HREF="#1.09">1.09</a> fgetchar..........Esta função captura um char do teclado (stdin)
<A HREF="#1.10">1.10</a> fgetpos...........Esta função lê a posição corrente do ponteiro de arquivo
<A HREF="#1.11">1.11</a> fgets.............Esta função lê uma string de um arquivo aberto.
<A HREF="#1.12">1.13</a> fileno............Retorna o número do handle do arquivo aberto

<A HREF="#1.13">1.13</a> flushall..........Esvazia os buffers de entrada e grava os buffers de saída
<A HREF="#1.14">1.14</a> fopen.............Abre um arquivo no modo especificado.
<A HREF="#1.15">1.15</a> fprintf...........Grava dados formatados em um arquivo.
<A HREF="#1.16">1.16</a> fputc.............Grava um byte no arquivo aberto.
<A HREF="#1.17">1.17</a> fputchar..........Imprime um char na tela (stdout)
<A HREF="#1.18">1.18</a> fputs.............Grava uma string no arquivo aberto
<A HREF="#1.19">1.19</a> fread.............Lê uma sequência de registros de um arquivo aberto.
<A HREF="#1.20">1.20</a> freopen...........Abre um novo arquivo usando uma estrutura de arquivo já aberta
<A HREF="#1.21">1.21</a> fscanf............Lê dados formatados de um arquivo.
<A HREF="#1.22">1.22</a> fseek.............Reposiciona o ponteiro de arquivo de maneira relativa
<A HREF="#1.23">1.23</a> fsetpos...........Determina uma nova posição para o ponteiro de arquivo

<A HREF="#2.11">2.11</a> gettext...........Copia uma região da tela de texto para a memória
<A HREF="#1.24">1.24</a> ftell.............Retorna a posição corrente do ponteiro do arquivo aberto
<A HREF="#1.25">1.25</a> fwrite............Grava uma sequência de registros no arquivo aberto.
<A HREF="#1.26">1.26</a> getc..............Lê um char do arquivo aberto.
<A HREF="#1.27">1.27</a> getchar...........Captura um char do teclado.
<A HREF="#1.28">1.28</a> gets..............Captura uma string do teclado.
<A HREF="#1.29">1.29</a> getw..............Lê um integer de um arquivo.
<A HREF="#1.30">1.30</a> perror............Imprime uma string com a string gerada pelo último erro.
<A HREF="#1.31">1.31</a> printf............Imprime dados formatados na tela.
<A HREF="#1.32">1.32</a> putc..............Grava um char em um arquivo aberto.
<A HREF="#1.33">1.33</a> putchar...........Imprime um caracter na tela.
<A HREF="#1.34">1.34</a> puts..............Imprime string na tela.

<A HREF="#1.35">1.35</a> putw..............Esta função grava um integer no arquivo
<A HREF="#1.36">1.36</a> remov.............Deleta um arquivo do disco
<A HREF="#1.37">1.37</a> rename............Troca nome de arquivo
<A HREF="#1.38">1.38</a> rewind............Rebobina o arquivo para o início
<A HREF="#1.39">1.39</a> scanf.............Captura dados formatados do teclado.
<A HREF="#1.40">1.40</a> setbuf............Assinala ao arquivo um buffer definido pelo usuário
<A HREF="#1.41">1.41</a> setvbuf...........Assinala ao arquivo um buffer definido pelo usuário
<A HREF="#1.42">1.42</a> sprintf...........Imprime dados formatados numa string
<A HREF="#1.43">1.43</a> sscanf............Captura dados formatados de uma string
<A HREF="#1.44">1.44</a> _strerror.........Agrega uma string à string gerada pelo último erro ocorrido no programa
<A HREF="#1.45">1.45</a> strerror..........Retorna a mensagem de erro correspondente ao número fornecido

<A HREF="#1.46">1.46</a> tmpfile...........Cria um arquivo temporário para rascunho
<A HREF="#1.47">1.47</a> tmpnam............Cria um nome geral único para uso em arquivos
<A HREF="#1.48">1.48</a> ungetc............Empurra um char para dentro do buffer de leitura
<A HREF="#1.49">1.49</a> unlink............Deleta um arquivo do disco
<A HREF="#1.50">1.50</a> vfprintf..........Imprime dados num arquivo usando uma lista de argumentos
<A HREF="#1.51">1.51</a> vfscanf...........Captura dados de um arquivo usando uma lista de argumentos
<A HREF="#1.52">1.52</a> vprintf...........Imprime informações na tela usando uma lista de argumentos
<A HREF="#1.53">1.53</a> vscanf............Captura dados formatados usando uma lista de argumentos
<A HREF="#1.54">1.54</a> vsprintf..........Imprime informações numa string usando uma lista de argumentos
<A HREF="#1.55">1.55</a> vsscanf...........Captura dados formatados de uma string usando uma lista de argumentos
<A HREF="#1.56">1.56</a> tell..............Retorna a posição corrente do ponteiro de arquivo

<hr>

<A NAME="1.01"><b>1.01 clearerr</b></A>
        Esta função limpa a indicação do último erro ocorrido
        do arquivo especificado e também resseta indicação de
        EOF.
        <b style="color:green">
        void clearerr(FILE *fp);
        clearerr(hFile);</b>

        Ex.:    clearerr(hFile);

.......................................................................................
<A NAME="1.02"><b>1.02 fclose</b></A>
        Esta função fecha o arquivo identificado pelo handle fornecido.
        <b style="color:green">
        int fclose (FILE *fp);
        int fclose(filename);</b>

        Ex.:    fclose(myfile);

        Detalhes: Esta função retorna 0 quando bem sucedida. Em caso
        de falha o valor de retorno é EOF.
.......................................................................................
<A NAME="1.03"><b>1.03 fcloseall</b></A>
        Fecha todos os arquivos, retornando o número de arquivos
        que estavam abertos.
        <b style="color:green">
        int fcloseall(void);
        nAbertos = fcloseall();</b>

        Ex.: fcloseall();

        Detalhe: Esta função retorna EOF em caso de erro.

.......................................................................................
<A NAME="1.04"><b>1.04 fdopen</b></A>
        Esta função associa uma estrutura de arquivo, declarada previamente
        com FILE, com um handle retornado por funções que criam arquivos em
        tempo de execução.
        <b style="color:green">
        FILE *fdopen(int handle, *type);
        hFile = fdopen(nHandle,sOpenMode);</b>

        Ex.: hFile = fdopen(nHandle,"wt");

        Programa exemplo: <font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"
        #include &lt;sys/stat.h&gt;

        int main (int nCmd, char **sCmd) {

        FILE *hFile;
        char sFileName[]="file.tst";
        char sOpenMode[]="wt";
        int cx,nHandle;

        clrscr();

        nHandle = creat(sFileName,S_IWRITE);

        hFile = fdopen(nHandle,"wt");

        fprintf(hFile,"Testando entrada em arquivo!");

        fclose(hFile);
        getch();
        puts("End of Program.");}</font>

.......................................................................................
<A NAME="1.05"><b>1.05 feof</b></A>
        Esta função verifica se ocorreu fim de arquivo (EOF).
        <b style="color:green">
        int feof(FILE *fp);
        int feof(myfile);</b>

        Ex.:    while (!feof(myfile);

        Detalhe: Em caso de fim arquivo o valor de retorno é diferente
        de zero.
.......................................................................................
<A NAME="1.06"><b>1.06 ferror</b></A>
        Esta função retorna o número de erro dos processos de
        manipulação de arquivos.
        <b style="color:green">
        int ferror (FILE *fp);
        nErro = ferror(hFile);</b>

        Ex.: printf("%d",ferror(hFile));

.......................................................................................
<A NAME="1.07"><b>1.07 fflush</b></A>
        Esta função função efetiva a gravação de dados pendentes nos
        buffers de saída.
        <b style="color:green">
        int fflush(FILE *fp);
        int fflush(hFile);</b>

        Detalhes: Em caso de erro, o valor de retorno é EOF.
.......................................................................................
<A NAME="1.08"><b>1.08 fgetc</b></A>
        Esta função lê um char de um arquivo aberto.
        <b style="color:green">
        int fgetc (FILE *fp);
        cMyChar = fgetc(hFile);</b>

        Ex.: printf("%c",fgetc(hFile));

.......................................................................................
<A NAME="1.09"><b>1.09 fgetchar</b></A>
        Esta função captura um char do teclado.
        <b style="color:green">
        int fgetchar(void);
        cMyChar=fgetchar();</b>

        Ex.: cMyLetter = fgetchar();

        Detalhes: Esta função produziu um efeito lamentável. Ela aceitou
        a entrada de uma string cujo primeiro char foi o efetivado. A
        função ainda espera o pressionamento do ENTER

.......................................................................................
<A NAME="1.10"><b>1.10 fgetpos</b></A>
        Esta função lê a posição corrente do ponteiro de arquivo.
        <b style="color:green">
        ìnt fgetpos(FILE *fp, fpos_t *pos);
        nSts = fgetpos(hFile,&nFilePosPtr);</b>

        Ex.:    fpos_t nFilePosPtr;
                fgetpos(hFile,&nFilePosPtr);
                printf("Pos: %li",nFilePosPtr);

        Detalhes:
        Esta função retorna zero para sucesso e non-zero para falhas.

.......................................................................................
<A NAME="1.11"><b>1.11 fgets</b></A>
        Esta função lê uma string de um arquivo aberto apontado pelo
        devido handle, estoca a string na variável apresentada. Em caso
        de sucesso, o valor retornado é a string que foi requerida. Em caso
        de falha o retorno é NULL ou EOF.
        <b style="color:green">
        char *fgets(char *s, int n, FILE *fp);
        fgets(sBuffer,nBytes,hMyfile);</b>

        Ex.:    fgets(sMyName, 80, hMyFile);

        sBuffer................Variável string usada como buffer
        nBytes................Número de bytes a ser lido
        hMyFile...............O handle do arquivo aberto

        Detalhes:
        O byte newline é devidamento respeitado, acusando
        o final da string.
.......................................................................................
<A NAME="1.12"><b>1.12 fileno</b></A>
        Esta função retorna o número que representa o handle
        do arquivo aberto.
        <b style="color:green">
        int fileno(FILE *fp);
        nHandleFile = fileno(hFile);</b>

        Ex.: printf("Handle do arquivo: ",fileno(hFile));

        Detalhes:
        Handle em português quer dizer alça. O handle é um valor numérico.
        Tecnicamente podemos afirmar que este handle é um índice que aponta
        para uma estrutura ou uma matriz de dados. Isto porque, a abertura
        de um arquivo implica na criação de várias váriaveis para controlar
        sua manipulação. O sistema precisa controlar a localização deste
        arquivo no disco, o atributo de leitura/gravação, posicionamento de
        registro e etc.

.......................................................................................
<A NAME="1.13"><b>1.13 flushall</b></A>
        Esta função esvazia os buffers de entrada de dados, e efetiva a gravação
        dos dados que estão nos buffers de saída.
        <b style="color:green">
        int flushall(void);
        nOpenedFiles = flushall();</b>

        Detalhes:
        O valor de retorno é o número total de arquivos abertos
        para entrada e saída de dados, ou seja, leitura ou gravação.

.......................................................................................
<A NAME="1.14"><b>1.14 fopen</b></A>
        Esta função abre um arquivo dentro do modo especificado,
        retornando um handle para a manipulação deste arquivo
        por outras funções. Este handle constitue-se de um ponteiro
        para uma estrutura FILE *hMyFile.
        <b style="color:green">
        FILE *fopen(const char *filename, const char *mode);
        myfile = fopen(filename,openmode);</b>

        Ex.:
        FILE *myfile;
        char filename[]="teste.txt";
        char openmode[]="aw";

        myfile = fopen(filename,openmode);
.......................................................................................

<A NAME="1.15"><b>1.15 fprintf</b></A>
        Esta função grava dados formatados em um arquivo.
        Seu funcionamento é idêntico ao da função printf() exceto
        pelo fato de que a primeira envia os dados formatados para
        os arquivos em disco. Contudo o código de formatação é o
        mesmo.
        <b style="color:green">
        int fprintf( FILE *pf, const char *format, ...);
        int fprintf(hMyFile, "%Formatos",variáveis);</b>

        Ex.: fprintf(hMyFile,"%s %d",sNome,nIdade);

        Detalhes:
        Esta função retorna o número de bytes enviados para
        o arquivo. Em caso de falha, o valor de retorno é EOF.

        Convém lembrar que a recuperação dos dados gravados, quando feita
        com fscanf() que os espaços,chr(32), delimita os dados; ocasionando
        o desmembramento de uma string que os contém em várias strings,
        quando na verdade se queria ler uma só.

.......................................................................................
<A NAME="1.16"><b>1.16 fputc</b></A>
        Esta função grava um byte no arquivo aberto.
        <b style="color:green">
        int fputc( int c, FILE *fp);
        int fputc (nByte, hMyFile);</b>

        Ex.:    fputc(ascii,hMyFile);
                fputc('\n',hMyfile);

        Detalhes:
        Após a gravação do byte o ponteiro do arquivo é movido uma posição,
        evitando assim sobreescrever os bytes seguintes.
.......................................................................................
<A NAME="1.17"><b>1.17 fputchar</b></A>
        Esta função imprime um char na tela (stdout).
        <b style="color:green">
        int fputchar( int c);
        int fputchar(cMyChar);</b>

        Ex.:    fputchar(cMychar);
                fputchar(65);

        Detalhes: Esta função faz o mesmo que putchar()

.......................................................................................
<A NAME="1.18"><b>1.18 fputs</b></A>
        Esta função grava uma string em um arquivo aberto. O valor retornado
        é o último byte escrito no arquivo. Em caso de erro, o valor de
        retorno é EOF.
        <b style="color:green">
        int fputs(char *s, FILE *fp);
        cLastByte = fputs(sString,hFile);</b>

        Ex.: fputs(sName,hFile);

.......................................................................................
<A NAME="1.19"><b>1.19 fread</b></A>
        Esta função lê uma sequência de registros de um arquivo aberto.
        <b style="color:green">
        size_t fread(const void *ptr, size_t size, size_t n, FILE *fp);
        nRecords= fread (&xMyStruc, nStrucSize, nRecords, hMyFile);</b>

        &xMyStruc............Endereço da estrutura que representa registros
        nStrucSize...........Tamanho da estrutura obtido com sizeof()
        nRecords.............Número de registros a serem lidos.
        hMyFile..............Handle do arquivo de leitura.

        Detalhes: Esta função retorna o número de registros lidos,
        este número não representa tamanho em bytes.
        Veja programa exemplo em <A HREF= "#1.25">fwrite()</A>
.......................................................................................
<A NAME="1.20"><b>1.20 freopen</b></A>
        Esta função abre um novo arquivo reutilizando uma estrutura de
        arquivo já aberta.
        <b style="color:green">
        FILE *freopen(const char *filename, const char *mode, FILE *fp);
        hNewFile = freopen(sFileName, sOpenMode, hFile);</b>

        Ex.:    freopen(sFileName,sOpenMode, hFile);

        Detalhes:
        Na sintaxe acima, o arquivo associado a estrutura hFile
        é fechado, e este hFile é usado para operações em
        sFileName que é aberto tendo este hFile.

        hNewFile é a estrutura de arquivo retornada para operações
        posteriores. Em caso de falha, seu valor é NULL.

        Esta função reopen() é muito útil para redirecionar os dados
        do teclado (stdin) e do vídeo (stdout) para o disco.

        Fecha este programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdlib.h"

        int main(void) {
        /* Redireciona a saída em vídeo para um arquivo */
        if (freopen("file.tst", "w", stdout)== NULL)
        fprintf(stderr, "Erro de Redirecionamento\n");

        /* Esta saída vai para o arquivo em disco file.tst */
        printf("Esse printf() terá seu efeito num aquivo.");

        /* Feche normalmente o primeiro hFile */
        fclose(stdout);
        getch();
        return 0; }</font>

.......................................................................................
<A NAME="1.21"><b>1.21 fscanf</b></A>
        Esta função lê uma sequência de dados formatados de um
        arquivo aberto. Seu modo de funcionamento é o mesmo que
        da função scanf(), exceto pelo fato que os dados são lidos do
        arquivo enquanto que a segunda lê do teclado. Contudo o
        código de formatação é o mesmo.
        <b style="color:green">
        int fscanf(FILE *fp, const char *formats,...);
        int fscanf(hMyFile,"%formatos",variáveis);</b>

        Ex.: fscanf(hMyFile,sNome,&nIdade);

        Detalhes:
        Esta função retorna o número de campos lidos,
        convertidos e guardados com sucesso. Em caso de falha, o valor
        de retorno é EOF. O valor de retorno não inclui os campos que
        não foram processados com sucesso.

        Convém lembrar que a recuperação dos dados gravados, quando feita
        com fscanf() que os espaços,chr(32), delimita os dados; ocasionando
        o desmembramento de uma string que os contém em várias strings,
        quando na verdade se queria ler uma só.

.......................................................................................
<A NAME="1.22"><b>1.22 fseek</b></A>
        Esta função reposiciona o ponteiro de arquivo, podendo realizar este
        posicionamento relativo ao final do arquivo, ao início do arquivo ou
        a posição corrente do ponteiro.
        <b style="color:green">
        long fseek(FILE *fp, long offset, int whence);
        nPos = fseek(hFile, nPosicionamentoRelativo, nOrigem);</b>

        hFile.............Estrutura de arquivo criada com FILE
        nPosicionamento...Um inteiro longo que representa um deslocamento relativo
                          nOrigem.
        nOrigem...........Um número inteiro que representa daonde será feito o
                          posicionamento do arquivo.

        Para nOrigem você pode usar estas constantes definidas em stdio.h:
        ---------------------------------------------------------------------
        SEEK_SET.....Desde o início do arquivo
        SEEK_CUR.....Desde a posição corrente do ponteiro de arquivo
        SEEK_END.....Desde o final do arquivo.

        Ex.:    fseek(hFile,9,SEEK_SET);

.......................................................................................
<A NAME="1.23"><b>1.23 fsetpos</b></A>
        Esta função determina uma nova posição absoluta para o ponteiro
        de arquivo.
        <b style="color:green">
        int fsetpos(FILE *fp, const fpos_t *pos);
        nSts = fsetpos(hFile, &nFilePosPtr);</b>

        Ex.:    fpos_t nFilePosPtr;
                nFilePtr = 20;
                fsetpos(hFile,&nFilePosPtr);

        Detalhe:
        Em caso de sucesso o valor de retorno é zero, non-zero
        para operações fracassadas.

.......................................................................................
<A NAME="1.24"><b>1.24 ftell</b></A>
        Esta função retorna a posição corrente do ponteiro de arquivo, que indica
        aonde vai ocorrer a próxima gravação ou a próxima leitura.
        <b style="color:green">
        long ftell(FILE *fp);
        nPos = ftell(hFile);</b>

        Ex.:    long nRegistro;
                nRegistro = ftell(hFile);
                printf("%li",nRegistro);

.......................................................................................
<A NAME="1.25"><b>1.25 fwrite</b></A>
        Esta função grava uma sequência de registros em um arquivo aberto.
        <b style="color:green">
        size_t fwrite( const void *ptr, size_t size, size_t n, FILE *fp);
        nRecords = fwrite (&xMyStruc, nStrucSize, nRecords, hMyFile);</b>

        &xMyStruc..........Endereço da estrutura que representa registros.
        nStrucSize.........Tamanho da estrutura obtido com sizeof()
        nRecords...........Número de registros a ser gravado
        hMyFile............Handle do arquivo para gravação

        Detalhes: O valor de retorno desta função é o número de
        campos gravados. Este número não representa o número
        de bytes gravados.

        Programa exemplo, ilustrando fwrite()/fread():<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "string.h"
        #include "stdlib.h"

        struct registro {
        int nIdade;
        char cClasse; };

        void main(void) {
        struct registro xClientes[2];
        int nStrucSize;
        int nRecords;
        int cx=0;

        FILE *hMyFile;
        char sFileName[]="teste.txt";
        char sOpenMode[]="w";

        xClientes[0].nIdade = 33;
        xClientes[1].nIdade = 36;
        xClientes[0].cClasse = 'A';
        xClientes[1].cClasse = 'C';

        clrscr();

        hMyFile = fopen(sFileName,sOpenMode);

        if (hMyFile==NULL) {
        printf("\nErro na abertura de arquivo. Programa abortado!\n");
        exit(0); }

        nStrucSize = sizeof(struct registro);
        nRecords=2;

        fwrite (&xClientes, nStrucSize, nRecords, hMyFile);

        fclose(hMyFile);
        xClientes[0].nIdade = 0;
        xClientes[1].nIdade = 0;
        xClientes[0].cClasse = 'X';
        xClientes[1].cClasse = 'X';

        printf("\tClasse \tIdade\n");
        for (cx=0; cx<2;cx++)
        printf("\t %c \t %d\n",xClientes[cx].cClasse, xClientes[cx].nIdade);

        printf("\nPressione qualquer tecla para continuar.\n");
        getch();
        clrscr();

        /* ....................... Segunda Parte/ Lendo Strutura ........ */

        strcpy (sOpenMode,"r");
        hMyFile = fopen(sFileName,sOpenMode);

        if (hMyFile==NULL) {
        printf("\nErro na abertura de arquivo. Programa abortado!\n");
        exit (0); }

        fread(&xClientes, nStrucSize, nRecords, hMyFile);

        printf("\tClasse \tIdade\n");
        for (cx=0; cx<2;cx++)
        printf("\t %c \t %d\n",xClientes[cx].cClasse, xClientes[cx].nIdade);

        fclose(hMyFile);
        puts("\nEnd Of Program. Teste 15");
        getch(); }</font>
.......................................................................................
<A NAME="1.26"><b>1.26 getc</b></A>
        Esta função lê um char do arquivo aberto.
        <b style="color:green">
        int getc(FILE *fp);
        cMyChar = getc(hMyFile);</b>

        Ex.:    cAscii = getc(hMyFile);

        Detalhes:
        Esta função, em caso de fim arquivo ou erro retorna EOF.
.......................................................................................
<A NAME="1.27"><b>1.27 getchar</b></A>
        Esta função captura um caracter do teclado.
        <b style="color:green">
        int getchar(void)
        cChar = getchar();</b>

        Ex.: mychar=getchar();

        Detalhes:
        Em caso de falha a função retorna EOF. Getchar() aguarda o
        pressionamento da tecla enter.
.......................................................................................
<A NAME="1.28"><b>1.28 gets</b></A>
        Esta função captura uma string do teclado, retornando esta
        string na variável char apresentada.
        <b style="color:green">
        char *gets(char *string)
        gets(sBuffer);</b>

        Ex.: gets(sNome);
.......................................................................................

<A NAME="1.29"><b>1.29 getw</b></A>
        Esta função lê um número inteiro de um arquivo, que deve ser
        aberto em modo binário.
        <b style="color:green">
        int getw(FILE *fp);
        nNumber = getw(hFile);</b>

        Ex.:    nIdade = getw(hMyFile);

        Detalhes:
        Em caso de sucesso, o inteiro gravado é retornada. Se erro
        o valor de retorno é EOF.
.......................................................................................
<A NAME="1.30"><b>1.30 perror</b></A>
        Esta função imprime uma string de usuário junto com a string gerada pelo
        último erro ocorrido no programa.
        <b style="color:green">
        void *perror(const char *s);
        perror(sUserMsg);</b>

        Ex.:    char    *sMsg="Erro ocorrido: ";
                /* Suponha aqui um processo que chama um arquivo inexistente */
                perror(sMsg);
                /* Resulta em Erro ocorrido: No such file or directory */

.......................................................................................

<A NAME="1.31"><b>1.31 printf</b></A>
        Esta função exibe qualquer tipo de dado na tela dentro da
        formatação determinada e retorna o número de caracteres
        impressos.
        <b style="color:green">
        int printf("%Formatos",variáveis);
        int printf(const *format,...);</b>

        Ex.:
        char myname[]="Jair Pereira";
        int myage=33;
        float pi=3.1415;
        printf("%s %d %f \n",myname,myage,pi);

.......................................................................................

<A NAME="1.32"><b>1.32 putc</b></A>
        Esta função grava um char em um arquivo aberto.
        <b style="color:green">
        int putc(char ch, FILE *fp);
        cChar = putc(cChar,hFile);</b>

        Ex.: putc(cMyChar,hFile);

        Detalhes:
        O valor de retorno é o char que foi gravado, em caso de erro
        o valor de retorno é EOF.

.......................................................................................
<A NAME="1.33"><b>1.33 putchar</b></A>
        Esta função imprime um caracter na tela e retorna o
        carácter impresso. Em caso de falha o valor de retorno
        é EOF
        <b style="color:green">
        int putchar(int ch);
        cMyChar putchar(cMyChar);</b>

        Ex.: x = putchar(mychar);
.......................................................................................
<A NAME="1.34"><b>1.34 puts</b></A>
        Esta função imprime uma string na tela e retorna o último
        carácter impresso.
        <b style="color:green">
        int puts("String");
        int puts(const char *s);</b>

        Ex.: puts("Seja paciente e persistente");

        Detalhes:
        A função adiciona automaticamente \n no final da string.
        Em caso de falha a função retorna EOF.

.......................................................................................
<A NAME="1.35"><b>1.35 putw</b></A>
        Esta função grava um integer no arquivo aberto em formato
        binário.
        <b style="color:green">
        int putw( int w, FILE *fp);
        nNumber = putw(nNumber,hFile);</b>

        nNumber...número inteiro a ser gravado, retornado pela função em caso de suceso.
        hFile.....Estrura de arquivo criada com FILE

        Ex.:    int nMeuNro = 2004;
                putw(nMeuNro,hArquivoStru);

.......................................................................................
<A NAME="1.36"><b>1.36 remove</b></A>
        Esta função remove um arquivo do disco.
        <b style="color:green">
        remove(filename);</b>

        Ex.:    char sNomeArquivo[]="chato.dat";
                remove(sNomeArquivo);

        Detalhes:
        Esta função é uma macro que é traduzida para a função
        que realmente deleta o arquivo.

.......................................................................................
<A NAME="1.37"><b>1.37 rename</b></A>
        Esta função troca o nome de um arquivo para o nome especificado.
        <b style="color:green">
        int rename(char *OldName, char *NewName);
        nStatus = rename(sNomeArquivo, sNovoNome);</b>

        nStatus....Retorna zero em caso de sucesso, EOF para erro.

        Ex.:    char sNomeArquivo = "info.txt";
                char sNomeNovo = "texto.txt";
                rename(sNomeArquivo,sNomeNovo);

.......................................................................................
<A NAME="1.38"><b>1.38 rewind</b></A>
        Esta função reestabelece o ponteiro de arquivo para o início.
        <b style="color:green">
        void rewind (FILE *fp);
        rewind(hFile);</b>

        Ex.:    rewind (hFile);

.......................................................................................
<A NAME="1.39"><b>1.39 scanf</b></A>
        Esta função captura dados formatados do teclado e estoca-os
        nas devidas variáveis. Ela retorna o número de campos preenchidos,
        isto é, o número de inputs solicitados.
        <b style="color:green">
        int scanf(const char *format,...);
        int scanf("%formatos",variáveis);</b>

        Ex.:    scanf("%s",myname);
                scanf("%d",&myage);
                scanf("%s %d",myname,&myage);

        Detalhes:
        O espaço, chr(32), atua como delimitador entre
        os dados. As variáveis numéricas devem ser
        precedidas pelo provedor de endereço &.

.......................................................................................
<A NAME="1.40"><b>1.40 setbuf</b></A>
        Esta função assinala ao arquivo um buffer especificado. Lembrando
        que buffer é uma região de memória para dados em trânsito, por exemplo,
        que vêm do disco ou vão para o disco.
        <b style ="color:green">
        void setbuf (FILE *fp, char *buffer);
        setbuf(hFile,sBuffer);</b>

        Ex.:    char sTemp[512];
                setbuf(hFile,sTemp);

        Programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "string.h"

        /* int setbuf(FILE *fp, const char *filename) */

        int main (int nCmd, char **sCmd) {
        int cx;
        char outbuf[BUFSIZ];

        setbuf(stdout,outbuf);
        clrscr();

        puts("Este texto não é ‚ exibido assim que puts() é executada.");
        puts("Geralmente, os dados só são gravados efetivamente nos");
        puts("arquivos quando o buffer está lotado, aí sim a gravação");
        puts("ou ainda a leitura‚ é efetivada de fato.");
        puts("Por exemplo, este texto só será exibido assim que o buffer");
        puts("de tela receber mais que 512 bytes ou se for executada uma");
        puts("função fflush() ou fflushall().");

        getch();
        fflush(stdout);
        printf("\nBUFFER SIZE: %d \n",BUFSIZ);
        getch();
        puts("\nEnd of Program\n");
        getch();
        }</font>

        Detalhes:
        O buffer torna mais rápido os processos de entrada
        e saída informações de/para os periféricos. O lado negativo
        do buffer é que se ocorrer algum problema os dados que
        estiverem nele serão perdidos.

        O próprio sistema buferiza os processos de arquivos.

        O tamanho de buffer comum é 512 bytes, representado pela
        constante BUFSIZE, e múltiplos deste número.

        Se o buffer NULL for passado para esta função os processos
        de arquivos não serão buferizados, e assim os dados irão
        direto para o disco ou outro periférico.

        Um detalhe interessante é que o teclado e o vídeo são tratados
        como se fossem arquivos tal como os de discos. O hFile do
        teclado é stdin e do vídeo é stdout e stderr.

.......................................................................................
<A NAME="1.41"><b>1.41 setvbuf</b></A>
        Esta função assinala ao arquivo um buffer definido pelo usuário.
        Ela permite buffers maiores de 512 bytes e faz indiretamente
        uma chamada a malloc() para requisitar o espaço de buffer pedido.
        <b style="color:green">
        int setvbuf (FILE *fp, char *buffer, type, size_t size);
        nSts = setvbuf(hFile, sBuffer, nBufferType, nTamanhoBuffer);</b>

        hFile...........Estrutura de arquivo criada com FILE
        sBuffer.........Buffer para o processo de arquivo, na verdade uma string
        nBufferType.....Tipo de bufferização que pode ser _IOFBF, IOLBF, _IONBF
        nTamanhoBuffer..Tamanho da memória a requisitar para sBuffer declarada
                        literalmente.
        sSts............Se bem sucedido, o retorno é zero. Non-zero para erro.

        Ex.: nSts = (hFile, sBuffer, _IOFBF, 1024);

        Veja o programa exemplo 01:<font color="darkblue">

        #include &lt;stdio.h&gt;
        int main(void) {
        FILE *input, *output;
        char bufr[512];

        input = fopen("file.in", "rb");
        output = fopen("file.out", "w");

        /* Vamos configurar o arquivo de leitura a fim de obter o mínimo de
        acessos ao disco, usando nosso próprio buffer de caracteres: */

        if (setvbuf(input, bufr, _IOFBF, 512) != 0)
         printf("Falha na configuração de buffer para leitura de arquivo.\n");
        else
        printf("Buffer configurado para leitura de arquivo\n");

        /* Vamos configurar o buffer do tipo _IOLBF para gravação de arquivo,
        usando espaço que será obtido através de uma chamada indireta de malloc() */

        if (setvbuf(output, NULL, _IOLBF, 132) != 0)
        printf("Falha na configuração de buffer de gravação de arquivo\n");
        else
        printf("Buffer de saída/gravação configurado\n");

        ...Processos de gravação e leitura... */

        /* Fechando os arquivos */
        fclose(input);
        fclose(output);
        return 0; }</font>

        Veja o segundo exemplo de setvbuf():<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"

        int main ( int nCmd, char **sCmd) {

        char sMemory[30512];
        FILE *hFile;
        char sFileName[]="teste.dat";
        char sOpenMode[]="wt";
        int nSts;
        long int cx;

        clrscr();

        hFile = fopen(sFileName,sOpenMode);
        nSts = setvbuf (hFile, sMemory, _IOFBF, 30512);

        if (nSts==0) printf("Mem¢ria alocada com sucesso...");

        for (cx=0;cx<30512;cx++) {
        putc(65,hFile);
        gotoxy(13,20);
        printf("%li",cx);}

        fclose(hFile);

        puts("\nEnd of Program!\n");
        getch(); }</font>

        Detalhes:
                        <u>Tipo de bufferização</u>
        Constantes que definem o estilo de buferização que será usado com o arquivo:

        <b>  NOME</b>             <u>SIGNIFICADO</u>

        <b>_IOFBF</b>....<u>O arquivo é totalmente bufferizado</u>
            Quando o buffer estiver vazio,a próxima operação de leitura vai tentar
            completá-lo totalmente.
            Na gravação,o buffer vai ser completamente preenchido antes que os
            dados sejam gravados no disco.
        <b>_IOLBF</b>....<u>O arquivo é bufferizado por linha</u>
            Quando o buffer estiver vazio,a próxima operação de leitura vai ainda
            tentar preenchê-lo completamente.
            Na gravação,entretanto, o buffer vai ser gravado sempre que for
            encontrado um sinal de nova linha "\n" nos dados.
        <b>_IONBF</b>....<u>O arquivo não é buferizado.</u>
            Os parâmetros sBuffer e o nTamanho são ignorados. Cada operação de leitura
            será realizada diretamente do arquivo, e cada operação de gravação será
            imediatamente escrita no arquivo em disco.

        Para maior domínio desta função veja setbuf().

.......................................................................................
<A NAME="1.42"><b>1.42 sprintf</b></A>
        Esta função imprime dados formatados numa string, lembrando que os
        códigos de formataçao são os mesmos de printf()
        <b style="color:green">
        int sprintf( char *buffer, const char *format, ...);
        nBytes = sprintf(sBuffer,"%formatos",variáveis);</b>

        Ex.:    sprintf(sBuffer,"%s %d",sNome,nIdade);

        Detalhes: Esta função retorna o número de bytes impressos,
                em caso de erro, o valor de retorno é EOF.

.......................................................................................
<A NAME="1.43"><b>1.43 sscanf</b></A>
        Esta função captura dados formatados de uma string.
        <b style="color:green">
        int sscanf(const char *buffer, const char *format,...);
        nCampos = sscanf(sBuffer,"%Formatos",&variáveis);</b>

        Ex.:     char sBuffer[]="33 JairPereira";
                 sscanf(sBuffer,"%d %s",&nIdade,sNome);

        Detalhes: Esta função retorna o número de campos lidos,
        convertidos e gravados com sucesso. Em caso de erro
        o valor de retorno é EOF. O chr(32) delimita strings. Tome
        cuidado com os caracteres em branco.

.......................................................................................
<A NAME="1.44"><b>1.44 _strerror</b></A>
        Esta função agrega uma string de usuário a uma string gerada pelo
        último erro ocorrido no programa.
        <b style="color:green">
        char *_strerror(const char *s);
        sUserMsgErrorMsg = _strerror(sUserMsg);</b>

        Ex.:    char    *sMsg="Erro ocorrido: ";
                /* Suponha aqui um processo que chama um arquivo inexistente */
                printf(_strerror(sMsg));
                /* Resulta em Erro ocorrido: No such file or directory */

.......................................................................................
<A NAME="1.45"><b>1.45 strerror</b></A>
        Esta função retorna a mensagem de erro correspondente ao número
        fornecido.
        <b style="color:green">
        char *strerror(int errnum);
        sErroMsg = strerror(nNumber);</b>

        Ex.: printf(strerror(2));
        /* Resulta em No such file or directory */

.......................................................................................
<A NAME="1.46"><b>1.46 tmpfile</b></A>
        Esta função cria um arquivo temporário para rascunho. O modo
        de abertura é o "wb".
        <b style="color:green">
        FILE *tmpfile(void);
        hFile = tmpfile();</b>

        Ex.:    FILE *hTemp;
                hTemp = tmpfile();

        Detalhes:
        Em caso de falha na criação deste arquivo, o valor de
        retorno é NULL.

.......................................................................................
<A NAME="1.47"><b>1.47 tmpnam</b></A>
        Esta função cria um nome geral para ser usado em arquivos.
        <b style="color:green">
        char *tmpnam(char *sptr);
        tmpnam(sFileName);</b>

        Ex.:    char sFileName[12];
                tmpnam(sFileName);

        Detalhes:
        Esta função cria nomes gerais para arquivos neste formato: TMP06.$$$

.......................................................................................
<A NAME="1.48"><b>1.48 ungetc</b></A>
        Esta função empurra um char para o buffer de leitura de arquivos, de
        forma que ao usar uma função getc() ou outra similar, o char será
        retornado por estas funções.
        <b style="color:green">
        int ungetc( int c, FILE *fp);
        cMyChar = ungetc(cMyChar,hFile);</b>

        cMyChar....Esta função retorna o char empurrado e EOF em caso de erro.

        Ex.:    ungetc('A',hFile);
                printf("%c",getc(hFile);

        Programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "string.h"

        /* ungetc(int c, FILE *fp) */

        int main (int nCmd, char **sCmd) {

        char sName[]="Jair Pereira";
        int cx;
        char cMyByte;

        clrscr();

        for (cx=0;sName[cx]!=0;cx++){
        ungetc(sName[cx],stdin);
        cMyByte =getc(stdin);
        printf("%c\n",cMyByte); }

        puts("End of Program");
        getch(); }</font>

.......................................................................................
<A NAME="1.49"><b>1.49 unlink</b></A>
        Esta função deleta um arquivo disco.
        <b style="color:green">
        int unlink(const char *filename);
        nSts = unlink(sNomeArquivo);</b>

        nSts.....Esta função retorna 0 em caso de sucesso, -1 para erro.

        Ex.:    unlink("chato.dat");

.......................................................................................
<A NAME="1.50"><b>1.50 vfprintf</b></A>
        Esta função grava dados formatados num arquivo aberto usando uma
        lista de argumentos.
        <b style="color:green">
        int vfprintf(FILE *fp, const char *formats, va_list arglist);
        nBytes = vfprintf(hFile,info,ArgPtr);</b>

        hFile.......uma estrutura FILE retornada por fopen()
        info........formatos e argumentos padrão printf()
        ArgPtr......um ponteiro declarado com va_list de stdarg.h
        nBytes......Esta função retorna o número de bytes gravados

        Programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdarg.h"

        /* vfprintf(FILE *fp, const char *formats, va_list arglist); */

        void gravar(FILE *hFile, char *info,...);

        void gravar(FILE *hFile,char *info,...) {

        va_list(ArgPtr);
        va_start(ArgPtr,info);
        vfprintf(hFile,info,ArgPtr);}

        int main (int nCmd, char **sCmd) {

        FILE *hFile;
        char *sFileName="teste.dat";
        char *sOpenMode="wt";

        char sVirtude[]="Perseverança";
        int nAno=2004;

        hFile = fopen(sFileName,sOpenMode);
        gravar(hFile,"%s %d ",sVirtude,nAno);

        close(hFile);

        clrscr();

        puts("End of Program");
        getch(); }</font>

        Detalhes:
        Para assimilar completamente esta função siga esta sequência
        didática: printf(), fopen(), fprintf(), vprintf()

.......................................................................................
<A NAME="1.51"><b>1.51 vfscanf</b></A>
        Esta função captura dados formatados de um arquivo aberto, usando
        uma lista de argumentos.
        <b style="color:green">
        int vfscanf(FILE *fp, const char *formats, va_list arglist);
        nFields = (hFile,info,ArgPtr);</b>

        hFile.......uma estrutura FILE retornada por fopen()
        info........formatos e argumentos padrão printf()
        ArgPtr......um ponteiro declarado com va_list de stdarg.h
        nFields.....Esta função retorna o número de campos lidos com sucesso.

        Programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdarg.h"

        /* vfscanf(FILE *fp, const char *formats, va_list arglist); */

        void ler(FILE *hFile, char *info,...);

        void ler(FILE *hFile,char *info,...) {

        va_list(ArgPtr);
        va_start(ArgPtr,info);
        vfscanf(hFile,info,ArgPtr);}

        int main (int nCmd, char **sCmd) {

        FILE *hFile;
        char *sFileName="teste.dat";
        char *sOpenMode="rt";

        char sVirtude[30];
        int nAno=0;

        clrscr();

        hFile = fopen(sFileName,sOpenMode);
        ler(hFile,"%s %d ",sVirtude,&nAno);
        close(hFile);
        printf("%s %d\n",sVirtude,nAno);

        puts("End of Program");
        getch(); }</font>

        Detalhes:
        Para ter completo domínio desta função, consulte estas funções nesta
        ordem: prinf(), scanf(), fscanf(), vprintf(), vscanf()

.......................................................................................
<A NAME="1.52"><b>1.52 vprintf</b></A>
        Esta função imprime dados formatados na tela a partir de uma lista
        de argumentos.
        <b style="color:green">
        int vprintf(const char *formats, va_list arglist);
        nBytes = vprintf(info, ArgPtr);</b>

        info......formatos e argumentos de printf() oriundos de outra função.
        ArgPtr...um ponteiro criado com o tipo va_list contido em stdarg.h
        nBytes...Esta função retorna o número de bytes impressos.

        Programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdarg.h"

        teste (char *info,...);
        teste(char *info,...) {

        va_list ArgPtr;

        va_start(ArgPtr,info);
        vprintf(info,ArgPtr);
        va_end(ArgPtr);
        return 0; }

        int main(int nCmd, char **sCmd) {
        char sName[]="Jair Pereira";
        float fSalario=600.80;
        int nIdade=33;

        clrscr();
        teste("Nome: %s \tIdade:%d \tSalário:%2.2f\n",sName,nIdade,fSalario);
        teste("Jair\n");
        getch(); }</font>

        Detalhes:
        Como se vê, a função vprintf() não é simples de ser usada.
        Aqui vai o procedimento para usá-la:

        a) Inclua o arquivo stdarg.h

        b) Declare o protótipo de uma função com uma lista indefinida de
           argumentos. Ex.: teste (char *info,...);

        c) No corpo desta função declare um ponteiro do tipo va_list,
        use va_start(argptr,fmt)para acessar o topo da lista de argumentos,
        imprima com vprintf(fmt,argptr) e feche o acesso à lista de argumentos
        com va_end(argptr). Ex.:
        <font color="darkblue">
        teste(char *info,...) {
        va_list ArgPtr;
        va_start(ArgPtr,info);
        vprintf(info,ArgPtr);
        va_end(ArgPtr);
        return 0; }</font>

        d) No corpo de main() faça a chamada normal:<font color="darkblue">
        char sName[]="Jair Pereira";
        float fSalario=600.80;
        int nIdade=33;

        clrscr();

        teste("Nome: %s \tIdade:%d \tSal rio:%2.2f\n",sName,nIdade,fSalario);
        teste("Jair\n");</font>

.......................................................................................
<A NAME="1.53"><b>1.53 vscanf</b></A>
        Esta função captura dados formatados do teclado usando uma lista
        de argumentos.
        <b style="color:green">
        int vscanf(const char *format, va_list arglist);
        nFields = vscanf(info,ArgPtr);</b>

        Programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdarg.h"

        int input(char *info,...);

        int input(char *info,...) {

        va_list ArgPtr;
        va_start(ArgPtr,info);
        vscanf(info,ArgPtr);
        va_end(ArgPtr);
        return 0; }

        int main (int nCmd, char **sCmd) {

        char sName[10];

        /* vscanf() */

        clrscr();
        input ("%s",sName);
        printf("\nYour name is %s",sName);
        getch(); }</font>

        Detalhes:
        Esta função retorna o número de campos lidos, convertidos
        e gravados com sucesso. Para maiores detalhes consulte as funções
        scanf() e especialmente vprintf().

.......................................................................................
<A NAME="1.54"><b>1.54 vsprintf</b></A>
        Esta função envia dados formatados para uma string usando uma
        lista de argumentos.
        <b style="color:green">
        int vsprintf(char *buffer, const char *format, va_list arglist);
        nBytes = vsprintf(sBuffer,info,ArgPtr);</b>

        sBuffer....String que vai receber a saída de dados
        info.......formatos e argumentos de printf() oriundos de outra função.
        ArgPtr.....um ponteiro criado com o tipo va_list contido em stdarg.h
        nBytes.....Esta função retorna o número de bytes impressos.

        Programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdarg.h"

        /* vsprintf (char *buffer, const char *format, va_list arglist)  */

        char sBuffer[80];
        char *print (char *sBuffer,char *info,...);
        char *print (char *sBuffer,char *info,...) {

        va_list ArgPtr;
        va_start(ArgPtr,info);
        vsprintf(sBuffer,info,ArgPtr);

        printf("Módulo print()\n");
        printf("%s",sBuffer);
        return(sBuffer);}

        int main (int nCmd, char **sCmd) {
        char sMyString[80];
        char sNome[80]="Charles Webster LeadBeater";
        char *sOtherBuffer;
        int nIdade=45;

        clrscr();
        sOtherBuffer = print(sMyString,"Nome: %s \t Idade: %d",sNome,nIdade);

        gotoxy(1,5);
        printf("Módulo Main()\n");
        printf("%s\n",sMyString);
        printf("sOtherBuffer: %s",sOtherBuffer);

        getch(); }</font>

        Detalhes:
        O uso desta função não é simples. Veja devagar os procedimentos
        para usá-la.

        a) Inclua o arquivo stdarg.h
        b) Declare uma função de argumentos indefinidos assim:
                teste(char *StringAlvo, char *info,...);

        c) no corpo desta função declare um Ponteiro com va_list, va_list(Ponteiro);
         Use va_start(Ponteiro,info);
         Depois imprima na string alvo assim: vsprintf(sStringAlvo,info,Ponteiro);
         Feche o acesso aos argumentos: va_end(Ponteiro)

        d) No corpo de main() será necessário declarar a String Alvo e os dados
         que você quer imprimir nesta string:

        char sStringAlvo[80];
        char sMeuDado="teste";
        int nMeuNro=12;

        e) Faça a chamada normalmente:
                teste(sStringAlvo,"Meu dado: %s Meu número: %d\n";sMeuDado,nMeuNro);

        Para maior domínio desta função veja na sequência printf(), sprintf()
        e vprintf().

.......................................................................................
<A NAME="1.55"><b>1.55 vsscanf</A></b>
        Esta função captura dados formatados de uma string usando uma
        lista de argumentos.
        <b style="color:green">
        int vsscanf(char *buffer, const char *formats, va_list arglist);
        nFields = vsscanf(sData,info,ArgPtr);</b>

        sData......String fonte dos dados a serem retirados
        info.......formatos e argumentos padrão printf() oriundos de outra função
        ArgPtr.....Um ponteiro declarado com va_list
        nFields....Esta retorna o nro de campos lidos, processados e estocados
                     com sucesso. Em caso de erro, o valor de retorno é EOF.

        Programa exemplo:<font color="darkblue">
        #include "stdio.h"
        #include "conio.h"
        #include "stdarg.h"

        /* vsscanf(const char *buffer, const char *formats, va_list arglist)*/

        void grabstr(char *sBuffer, char *info,...);

        void grabstr(char *sBuffer, char *info,...) {

        va_list ArgPtr;
        va_start(ArgPtr,info);
        vsscanf(sBuffer,info,ArgPtr);
        va_end(ArgPtr); }

        int main (int nCmd, char **sCmd) {

        char sData[]="JairPereira 33";
        char sMyName[30];
        int nMyAge;

        clrscr();

        grabstr(sData,"%s %d",sMyName,&nMyAge);

        printf("Meu nome: %s\n",sMyName);
        printf("Minha idade: %d\n",nMyAge);

        puts("End of Program");
        getch(); }</font>

        Detalhes:
        Para o maior domínio desta função veja nesta sequência
        didática as seguintes funções: scanf(),vprintf(), sscanf()

.......................................................................................
<A NAME="#1.56"><b>1.56 tell</b></A>
        Esta função retorna a posição corrente do ponteiro de arquivo.
        <b style="color:green">
        long tell(int handle);
        nPos = tell(nHandle);</b>

        Ex.:            int nHandle;
                        long nPos;
                        nHandle= fileno(hFile);
                        nPos = tell(nHandle);


<table align=bottom border=0 cellspacing=0 cellpadding=0 width=20%><tr><td><a href=cbiblioteca.html style='color:blue'> index </a></td><td><a href='cbiblioteca.html'style='color:blue'>&lt;&lt;</a></td><td><a href='track02.html'style='color:blue'>&gt;&gt;</a></td></tr></table><hr><div style='background-color:lightyellow;color:blue'>
<center>Produzido por Gameprog: Jair Pereira - Fev/2006 - Junho/2013 ©
gameprog.br@gmail.com
<a href='http://www.gameprog.com.br'>http://www.gameprog.com.br</a></center><hr></div></body></html>
