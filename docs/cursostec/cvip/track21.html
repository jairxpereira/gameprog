<html><head>
<title>CVip_track21</title>
<style type="text/css">

.dica {	width:500pt; background:aliceblue;color:#700080}
span {
font-family: 'Courier New';
font-size: 10pt;
color: #000000;
}
.sc0 {
}


.sc1 {
color: darkgreen;
font-weight: bold;
}

.sntx {
color: darkgreen;
}


.sc2 {
color: #008000;
}
.sc4 {
color: #ff8000;
}
.sc5 {
font-weight: bold;
color: #0000FF;
}
.sc6 {
color: #FF0000;
}
.sc9 {
color: #804000;
font-weight: bold;
}
.sc10 {
font-weight: bold;
color: #000080;
}
.sc11 {
}
.sc16 {
color: #400080;
}

.prg {
color: #0000FF;
}

.prg-saida {

margin-left:0px;
width:500pt;
background-color:lightblue;

}

.prg-code {
margin-left:0px;
width:500pt;
background-color:lightyellow;
padding:10px;
font-weight:bold;
}


.niceview {
margin-left:0px;
width:500pt;
background-color:white;
border-color:lightgray;
border-width:1px;
border-style:solid;
padding:10px;
}

td
{
padding:3px;
}

table.dados
{

margin-left:0px;
width:53.5em;
border-collapse:collapse;
border:1px solid red;
text-align:center;
}

th
{
background-color:darkgreen;
color:yellow;
font-weight:bold;
text-transform:uppercase;
}
body
{
margin-left:60px;
}
.pagebody
{
margin-left:50px;
border-width:1px;
border-style:solid;
border-color:white;
background-color:white;
width:90%;
-webkit-border-radius: 40px 40px 40px 40px;
-moz-border-radius: 40px 40px 40px 40px;
border-radius: 15px 15px 15px 15px;
}
.mybody
{
margin-top:20pt;
margin-bottom:20pt;
margin-left:20pt;
margin-right:20pt;
/* border-width:1px; */
/* border-style:solid; */
border-color:lightgray;
background-image:url('backdrop.jpg');
}
</style>
</head>
<body class=mybody><font color="black">
<div class=pagebody>
<hr>
<center><b style="font-size:1.5em;" >Curso completo de linguagem C</b><br>
Gameprog - Escola de programação de jogos digitais<br>
Contato: gameprog.br@gmail.com<br>
<b>track21.html</b></center>
<hr>
<table align=bottom border=0 cellspacing=0 cellpadding=0 width=20%><tr>
<td><a href=cvip.html style='color:blue'> index </a></td><td><a href='track20.html'style='color:blue'>&lt;&lt;</a></td>
<td><a href='track22.html'style='color:blue'>&gt;&gt;</a></td></tr></table>
<hr><pre>
<a name="track19"></a><h3 style="background-color:#80ff80">21. Bits, bytes e bases numéricas</h3>
<b style="background-color:lightgreen">21.1 Visão geral</b>
<u>O BIT</u>
O  bit  é  a  menor  unidade  de  informação  possível em computação,
seu valor pode ser apenas 0 ou 1.

Podemos  codificar  informação  em  termos de bits, usando os valores
0  e  1  para  significar respectivamente falso  ou  verdadeiro,  sim
ou  não,  ativo  ou  desabilitado. Mais  adiante  vamos  passar  como
fazer  isto.  Com  isso,  podemos ganhar na  economia  de  memória  e
em ganhos de velocidade de processamento.

<u>O BYTE</u>
O  byte  é  um  conjunto de 8 bits. Com um conjunto de 8 bits podemos
representar  valores  de  0  a 255; esta faixa de valores é usada  na
codificação  dos  caracteres  básicos  do teclado.  A  tabela  destes
caracteres recebe o nome de Tabela ASCII.

A   melhor  forma  de  visualizar  o  espaço  que  um  byte  ocupa  é
considerá-lo  como  uma  letra  do alfabeto,  assim se um arquivo tem
1.000 bytes, para ter uma noção  do que é este espaço basta pensarmos
num  texto cuja soma da quantidade de letras dá 1.000. É interessante
ter essa noção  concreta  de  espaço  para  avaliações  dos  tamanhos
dos arquivos.


Os    bits    em    um    byte   são   organizados   desta   maneira:

Posição: 76543210
Bits...: 00000000

O  bit  7,  que  é  o  bit da extrema esquerda, é denominado the Most
Significant Bit, ou seja, o bit mais significante.  Vamos nos referir
a este bit usando a abreviação inglesa MSB.  Para entender porque ele
é chamado de  o mais significante veja este número da  base  numérica
decimal: 555

Perceba  que  quanto  mais  o algarismo se  aproxima  da  extremidade
esquerda,  mais  ele  ganha  em significado. O 5 da extrema esquerda,
o  nosso  MSB  da  questão vale 500,  o  seguinte  vale  somente 50 e
o  último  apenas  5  unidades. Perceba que a  posição  ocupada  pelo
algarismo  é  o  que  determina se ele é mais  ou  menos significante
no contexto.

O  bit  0,  de  posição 0, é conhecido como o bit menos significante,
the    Less    Significant    Bit,    cuja    abreviação    é    LSB.

Esta relação de mais ou menos significante  naturalmente  ocorre  com
os  tipos  de  dados que têm 2, 4, 8 bytes de tamanho, sendo os bytes
mais  à  esquerda  os  mais  significantes  e  os menos signicantes à
direita.

Por   exemplo,  o  tipo  inteiro  que  ocupa  2  bytes  ou  16  bits:

Bytes..: MSB......................LSB
Posição: 15 16 14 13 12 11 10 9 8 76543210
Bits...:  0  0  0  0  0  0  0 0 0 0000000

Vamos  ter  com  o  tipo  inteiro, o byte mais significativo e o byte
menos significativo. O byte  mais  significativo é  também  conhecido
como HIGH BYTE, o byte alto em português;  o byte menos significativo
é chamado de LOW BYTE, o byte baixo.

<b style="background-color:lightgreen">21.2 A base numérica hexadecimal</b>

Você   já  se  deparou  com  números  hexadecimais  quando  abordamos
ponteiros, que geralmente são usados para  representar  os  endereços
de  memória. Os números hexadecimais também  podem  ser  usados  para
atribuir os valores às variáveis ao invés de usarmos a base  numérica
decimal. Na linguagem c, os  números hexadecimais  são precedidos por
<b class=prg>0x</b> que os identifica.

Os  números  hexadecimais  são formados por 16 algarismos, que são os
números de 0 a 9  e  as letras de A até F.  A  numeração  hexadecimal
surgiu  da  necessidade  de  se  lidar   com  os bits de maneira mais
confortável e mais inteligível.

Cada  algarismo  alfanumérico  representa um conjunto de quatro bits.
Veja a tabela:

<table class=dados border=1 >
<tr><th>Decimal</th><th>Hexadecimal</th><th>Binário</th></tr>
<tr><td>0</td><td>0</td><td>0000</td></tr>
<tr><td>1</td><td>1</td><td>0001</td></tr>
<tr><td>2</td><td>2</td><td>0010</td></tr>
<tr><td>3</td><td>3</td><td>0011</td></tr>
<tr><td>4</td><td>4</td><td>0100</td></tr>
<tr><td>5</td><td>5</td><td>0101</td></tr>
<tr><td>6</td><td>6</td><td>0110</td></tr>
<tr><td>7</td><td>7</td><td>0111</td></tr>
<tr><td>8</td><td>8</td><td>1000</td></tr>
<tr><td>9</td><td>9</td><td>1001</td></tr>
<tr><td>10</td><td>A</td><td>1010</td></tr>
<tr><td>11</td><td>B</td><td>1011</td></tr>
<tr><td>12</td><td>C</td><td>1100</td></tr>
<tr><td>13</td><td>D</td><td>1101</td></tr>
<tr><td>14</td><td>E</td><td>1110</td></tr>
<tr><td>15</td><td>F</td><td>1111</td></tr></table>

É  muito  mais  fácil  e  mais  confortável  você  lidar  com  0xFABD
do  quê  1111  1010  1011  1101   que  é  o  correspondente  binário.
A  conversão  da  base  binária  para  a  base  hexadecimal  é  muito
simples  com  a  posse  da  tabela  acima,  basta  você  localizar  o
padrão  de  bits  que  corresponde    a  cada  algarismo  hexadecimal
e  vice-versa.  Por  exemplo,    o  número hexadecimal FA é 1111 1010
que    são    os    padrões  de  bits  correspondentes  do  algarismo
hexadecimal F e A.

Há também a base numérica octal, composta de  algarismos de  0  a  7.
Cada  algarismo  representa  um  pacote  de  3  bits,  enquando  cada
algarismo hexadecimal representa 4 bits.   Na linguagem c,  os número
octais  são  identificados  com um zero inicial. Assim 077 é um octal
equivalente ao binário 111 111.


<u>SHIFTS - ROLAGEM DE BITS</u>

<table class=dados border=1 width=15.0em>
<tr><th>Decimal</th><th>Hexadecimal</th><th>Binário</th></tr>
<tr><td>0</td><td>0</td><td>0000</td></tr>
<tr><td>1</td><td>1</td><td>0001</td></tr>
<tr><td>2</td><td>2</td><td>0010</td></tr>
<tr><td>4</td><td>4</td><td>0100</td></tr>
<tr><td>8</td><td>8</td><td>1000</td></tr></table>

Veja  na  tabela  que  8  em binário é 1000  e que  o número 4, que é
sua  metade  é  0100.  Veja  que a diferença  do  4 para o  8 é que o
bit  mais  significativo  rolou  para  a direita e que o lugar do MSB
foi  ocupada  pelo  zero.  Toda  vez que ocorre uma rolagem  de  bits
para    a    direita    ocorre   uma   divisão   por   2   no   byte.

E  se  você  rolar  os  bits para a esquerda, por exemplo 4=0100 vira
8=1000 pois ocorre a multiplicação do byte  por  2.  Na  linguagem  C,
há    funções  que  fazem  rolagem de bits e operadores especiais que
mexem com os  bits das variáveis.

A rolagem para  a   direita   é   conhecida  como  SHIFT  RIGHT (&gt;&gt;).
A rolagem para  a   esquerda   é   conhecida  como  SHIFT  LEFT (&lt;&lt;).

<b style="background-color:lightgreen">19.3 Operações com bits</b>

Em  um  byte  você  pode codificar 8 parâmetros de  configuração  que
assumem  valores  falso  ou  verdadeiro, sim ou não  e  outros  mais.
É  muito  comum  funções  da linguagem C, funções internas do sistema
realizar ou retornar configurações codificadas em binário em um byte.
Para alterar os bits de um byte você precisa dos operadores binários.
<b style="color:green">
vVar = vVarx e vVary</b>

Nas  operações  binárias,  você  vai  guardar em vVar o resultado que
surgirá do confronto dos bits das variáveis vVarx e vVary;  cada  bit
de  cada  posição  de  vVarx  será confrontado com o bit  da  posição
correspondente de vVary e  o  bit  correspondente  de  vVar  guardará
o resultado.

Veja a tabela de operadores binários:

<table class=dados border=1>
<tr><td>vVarx</td><td>Operador (Operação)</td><td>vVary</td><td>vVar</td><td>int x,y,z;</td></tr>
<tr><th>BIT</th><th>Operador Binário</th><th>BIT</th><th>BIT-Resultado</th><td>...</td></tr>
<tr><td>1</td><td>& (AND)</td><td>1</td><td>1</td><td>z = x & y;</td></tr>
<tr><td>1</td><td>& (AND)</td><td>0</td><td>0</td><td>...</td></tr>
<tr><td>0</td><td>& (AND)</td><td>1</td><td>0</td><td>...</td></tr>
<tr><td>0</td><td>& (AND)</td><td>0</td><td>0</td><td>...</td></tr>

<tr><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td></tr>
<tr><td>1</td><td>| (OR)</td><td>1</td><td>1</td><td> z = x | y;</td></tr>
<tr><td>1</td><td>| (OR)</td><td>0</td><td>1</td><td>...</td></tr>
<tr><td>0</td><td>| (OR)</td><td>1</td><td>1</td><td>...</td></tr>
<tr><td>0</td><td>| (OR)</td><td>0</td><td>0</td><td>...</td></tr>
<tr><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td></tr>
<tr><td>1</td><td>~ (NOT)</td><td>...</td><td>0</td><td> z = ~y;</td></tr>
<tr><td>0</td><td>~ (NOT)</td><td>...</td><td>1</td><td>...</td></tr>
<tr><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td></tr>
<tr><td>1000</td><td>&gt;&gt; (SHIFT RIGHT)</td><td>...</td><td>0100</td><td> z = y << 1;</td></tr>
<tr><td>0100</td><td>&lt;&lt; (SHIFT LEFT)</td><td>...</td><td>1000</td><td> z = y >> 1;</td></tr>
</table>

<u>ENCURTANDO EXPRESSÕES</u>
Há operadores unários de rolagem de bits  &gt;&gt=  e  &lt;&lt;=  que podem ser
usados      para      encurtar      as      expressões     numéricas:

x = x &gt;&gt; 1;  pode  ser  encurtado  para   x &gt;&gt;= 1;

x = x &lt;&lt; 1; pode  ser  encurtado  para  x &lt;&lt;= 1;


<u>MÁSCARA - CONFIGURANDO VIA BIT</u>

Para  alterar  um  bit  em um byte você vai precisar confrontá-lo com
outro bit de uma outra variável. Esta variável que  será  usada  para
fazer o confronto é chamada de máscara.</u>

Vamos  supor  que  você  tem uma variável unsigned  char nConfig,  na
qual  você  quer  alterar  o MSB para valor 1, indicando  que  o  seu
recurso  está  ativo.  Você  pode executar uma operação OR neste byte
sendo  que  a  máscara  deve ter o correspondente  MSB  ligado. O seu
programa ficará assim:
<font color="darkblue">
unsigned char nMascaraBit7 = 0x80; /* 1000 0000 */
nConfig = nConfig | nMascara;</font>

Esta operação liga apenas o bit 7 e deixa os outros bits inalterados.

Há várias funções em stdlib.h que perfazerm conversões entre as bases
numéricas. Veja por exemplo ultoa():

<b>_ultoa() de stdlib.h</b>
Esta   função   converte  um  número  inteiro  longo  não  sinalizado
para  uma  string.    A  conversão  pode ser feita para qualquer base
numérica.
<b style="color:green">
char* _ultoa (unsigned long value, const char *s, int radix);
sString = _ultoa (nLongNumber, sNumber, nBase);</b>

<b class=sc1>sString</b>...... A função retorna nLongNumber convertido numa string.
<b class=sc1>nLongNumber</b>.. Número inteiro longo que será convertido.
<b class=sc1>sNumber</b>...... Variável string que recebe o número convertido.
<b class=sc1>nBase</b>........ Base numérica para a conversão, pode ser 2,8,10 ou 16.

Ex.:<b class=prg>
char *sString;
char sNumber;
unsigned long int nLongNumber = 0xFFFFFFFF;
_ultoa(nLongNumber, sNumber, 2);</b>

Detalhes:
Esta  é  uma  função  muito  interessante,  porque  vc pode converter
rapidamente  números  de  uma  base para outra e ter esta string para
outros processos.

Veja      mais     este     programa     exemplificando     _ultoa(): <font color="darkblue">

<div class=prg-saida>
 <img src=images\bits.png>
<br></div>
<div class=prg-code>
<span class="sc1">/* Programa: bits.c - track 21        */</span><span class="sc0">
</span><span class="sc1">/* Conversão numérica                 */</span><span class="sc0">
</span><span class="sc9">#include "stdio.h"
#include "stdlib.h"
</span><span class="sc0">
</span><span class="sc1">/* Protótipos */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">initSys</span><span class="sc10">(</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">title</span><span class="sc10">);</span><span class="sc0">

</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">main</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">void</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">

</span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">sNumber</span><span class="sc10">[</span><span class="sc4">40</span><span class="sc10">];</span><span class="sc0">
</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">nLongNumber</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0xFFFFFFFF</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">sString</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc11">initSys</span><span class="sc10">(</span><span class="sc6">"title bits.c"</span><span class="sc10">);</span><span class="sc0">

</span><span class="sc1">/* Converte o número longo para binário */</span><span class="sc0">
</span><span class="sc11">sString</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">_ultoa</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">nLongNumber</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">sNumber</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">

</span><span class="sc11">printf</span><span class="sc10">(</span><span class="sc6">" %lu nLongNumber \n\n %s sNumber \n\n"</span><span class="sc10">,</span><span class="sc11">nLongNumber</span><span class="sc10">,</span><span class="sc11">sNumber</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc11">printf</span><span class="sc10">(</span><span class="sc6">" %s String retornada \n\n"</span><span class="sc10">,</span><span class="sc11">sString</span><span class="sc10">);</span><span class="sc0">

</span><span class="sc11">getch</span><span class="sc10">();</span><span class="sc0">
</span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ------------------ Função initSys()  -------------------- */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">initSys</span><span class="sc10">(</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">title</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
</span><span class="sc1">/* Configura a janela */</span><span class="sc0">
</span><span class="sc11">system</span><span class="sc10">(</span><span class="sc11">title</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc11">system</span><span class="sc10">(</span><span class="sc6">"color F1"</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc11">printf</span><span class="sc10">(</span><span class="sc6">"\n\n"</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span></div>
<hr>
<table align=bottom border=0 cellspacing=0 cellpadding=0 width=20%><tr><td><a href=cvip.html style='color:blue'> index </a></td><td><a href='track20.html'style='color:blue'>&lt;&lt;</a></td><td><a href='track22.html'style='color:blue'>&gt;&gt;</a></td></tr></table><hr><div style='background-color:lightyellow;color:blue'>
<center>Produzido por Gameprog: Jair Pereira - Fev/2006 - Junho/2013 ©
gameprog.br@gmail.com
<a href='http://www.gameprog.com.br'>http://www.gameprog.com.br</a></center><hr></div></div></body></html>
