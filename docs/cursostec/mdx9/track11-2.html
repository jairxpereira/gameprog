<html>
<head>
<title>mdx9_fase11-2</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}


.sc1 {
	color: darkgreen;
	font-weight: bold;
}

.sntx {
	color: darkgreen;
	}


.sc2 {
	color: #008000;
}
.sc4 {
	color: #ff8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #FF0000;
}
.sc9 {
	color: #804000;
	font-weight: bold;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #400080;
}

.prg {
	color: #0000FF;
}

.prg-saida {

	margin-left:0px;
	width:500pt;
	background-color:lightblue;	
}

.prg-code {
	margin-left:0px;
	width:515pt;
	background-color:lightyellow;
	padding:10px;
	font-weight:bold;
}


.niceview {
	margin-left:0px;
	width:500pt;
	background-color:white;
	border-color:lightgray;
	border-width:1px;
	border-style:solid;
	padding:10px;
}

td
{
padding:3px;
}

table.dados
{
margin-left:0px;
width:53.5em;
border-collapse:collapse;
border:1px solid red;
text-align:center;
}

th
{
background-color:darkgreen;
color:yellow;
font-weight:bold;
text-transform:uppercase;
}

.pagebody
{
padding:10px;
margin-left:50px;
border-width:1px;
border-style:solid;
border-color:white;
background-color:white;
width:90%;
}
.mybody
{
margin-top:20pt;
margin-bottom:20pt;
margin-left:20pt;
margin-right:20pt;
border-color:lightgray;
background-image:url('background.png');
}
</style>
</head>
<body class=mybody><font color='black'>
<div class=pagebody>
<hr>
<center><b style='font-size:1.5em;' >Curso completo de DirectX Gerenciado</b><br>
Gameprog - Escola de programação de jogos digitais<br>
Contato: gameprog.br@gmail.com<br>
<b>Fase 11-2</b></center>
<hr>
<table align='left' border='0' cellspacing='0' cellpadding='0' width='20%'>
<tr><td><a href='mdx9.html#start' style='color:blue'> index </a></td>
<td><a href='track11-1.html' style='color:blue'>&lt;&lt;</a></td>
<td><a href='track11-3.html' style='color:blue'>&gt;&gt;</a></td></tr></table><br><pre>
<hr><a name='topo'></a>
<h3 style='background-color:#80ff80'>11.2 Clonagem</h3><pre>
<b><u>1.1 Visão geral</b></u>
<div class=prg-code><img src=images\prj_Clonagem.png></div>
O método <b class=prg>Mesh.Clone()</b> permite realizar cópias de meshes com acréscimo
ou redução de características em relação ao mesh original. Geralmente
é  interessante clonar o mesh para a aplicação de outros processos ou
efeitos sobre o mesmo ou simplesmente para ter  cópias  independentes
dos mesmos objetos na cena.   Como  exemplo  de atributo que pode ser
acrescentado  ou  subtraído  no  objeto  clonado  citamos  as normais
que são usadas na iluminação dos objetos.

<b><u>1.2 Estrutura principal da aplicação</b></u>
<div class=prg-code>
<img src=images\esquema_prj_Clonagem.png></div>
A aplicação deste tópico mostra o cubo original  e  duas  cópias  que
foram feitas com duas abordagens levemente  diferentes  para  mostrar
variações úteis no código de clonagem. Esta aplicação também mostra o
o  uso  de  um  objeto da  classe  <b class=prg>GraphicsStream</b>  que foi usado como
recipiente de dados de vértices do cubo original.   O  código  básico
dessa  aplicação  foi baseado no  projeto <b>prj_Meshes01x</b> do tópico 4.3
que  foi adaptado  para  este  exemplo.   Durante  a  execução  desta 
aplicação  pressione a barra de espaços para inverter o estado da luz
(ligada\desligada).

<b><u>2.1 Variáveis da classe</u></b>
<div class=niceview><span class=prg>public </span><span class=prg>partial </span><span class=prg>class </span>Tela : <span class=sc5>Form</span>
<span class=sc16>{</span>
 <span class=sc2>// Para criação do dispositivo gráfico</span>
 <span class=prg>private </span><span class=sc5>Device </span>device = <span class=prg>null;</span>

 <span class=sc2>// Essa variável atualizada a cada ciclo ocasionará</span>
 <span class=sc2>// a animação do objeto</span>
 <span class=prg>private </span><span class=prg>float </span>angulo = <span class=sc4>0.0f;</span>

 <span class=sc2>// Controla iluminação</span>
 <span class=prg>bool </span>estadoLuz = <span class=prg>true;</span>

 <span class=sc2>// Vetores para a posição e rotação do objeto 3d</span>
 <span class=sc5>Vector3 </span>posicao, rotacao; 

 <span class=sc2>// Variável global para propriedade dos objetos</span>
 Propriedades3D g_props; 

 <span class=sc2>// Objeto Font do DirectX para mostrar texto</span>
 <span class=prg>private </span><span class=prg>Direct3D.Font </span>dxfMensagem = <span class=prg>null;</span>

 <span class=sc2>// Objeto Font tradicional do namespace System.Drawing</span>
 <span class=prg>private </span><span class=prg>System.Drawing.Font </span>g_font = <span class=prg>null;</span>
<b>
 <span class=sc2>// Variáveis para guardar as malhas tridimensionais</span>
 <span class=prg>private </span><span class=sc5>Mesh </span>cubo = <span class=prg>null;</span>
 <span class=prg>private </span><span class=sc5>Mesh </span>cuboClonado = <span class=prg>null;</span>
 <span class=prg>private </span><span class=sc5>Mesh </span>segundoClone = <span class=prg>null;</span>
</b>
 <span class=sc2>// (...)</span>

} <span class=sc2>// fim da classe</span>
</div><b>
<span class=sc2>// Controla iluminação</span>
<span class=prg>bool </span>estadoLuz = <span class=prg>true;</span></b>
Esta variável guarda o estado da luz que vai ser modificado na função
<b>Tela_KeyDown()</b> caso a barra de espaços seja pressionada.   A  luz  na
cena  é  necessária  para  visualizar  o  cubo com as normais que são
adicionadas no processo de clonagem do cubo original.

<b>
<span class=sc2>// Variáveis para guardar as malhas tridimensionais</span>
<span class=prg>private </span><span class=sc5>Mesh </span>cubo = <span class=prg>null;</span>
<span class=prg>private </span><span class=sc5>Mesh </span>cuboClonado = <span class=prg>null;</span>
<span class=prg>private </span><span class=sc5>Mesh </span>segundoClone = <span class=prg>null;</span></b>
Destacamos aqui as variáveis que vão ser usadas para acessar ao longo
do programa os objetos tridimensionais criados.

<b><u>2.2 Inicializando a aplicação</u></b>
<div class=niceview><span class=prg>public </span><span class=prg>void </span>initGfx() 
<span class=sc16>{</span>
 <span class=sc2>// Configuração dos parâmetros de apresentação</span>
 <span class=sc5>PresentParameters </span>pps = <span class=prg>new </span><span class=sc5>PresentParameters</span>();  
 <span class=prg>pps.Windowed </span>= <span class=prg>true;</span>
 <span class=prg>pps.SwapEffect </span>= <span class=prg>SwapEffect.Discard;</span>
 <span class=prg>pps.EnableAutoDepthStencil </span>= <span class=prg>true;</span>
 <span class=prg>pps.AutoDepthStencilFormat </span>= <span class=prg>DepthFormat.D16;</span>

 <span class=sc2>// Adaptador default, processamento no hardware, processamento de vértice</span>
 <span class=sc2>// no software, janela (this), parâmetros de apresentação (pps)</span>
 <span class=prg>int </span>adaptador = 0; 
 device = <span class=prg>new </span><span class=sc5>Device</span>(adaptador, <span class=prg>DeviceType.Hardware</span>, <span class=prg>this</span>, 
 <span class=prg>CreateFlags.SoftwareVertexProcessing</span>, pps);  

 <span class=sc2>// Configuração das fontes para mostrar mensagens</span>
 g_font = <span class=prg>new </span><span class=prg>System.Drawing.Font</span>(<span class=sc6>"Arial"</span>, <span class=sc4>16.0f</span>, <span class=prg>FontStyle.Bold</span>);  
 dxfMensagem = <span class=prg>new </span><span class=prg>Direct3D.Font</span>(device, g_font);  
<b>
 <span class=sc2>// Montamos o cubo e o clonamos duas vezes</span>
 montarCubo();  
 clonarCubo();  
 segundaClonagem();  </b>
 
<span class=sc16>} <span class=sc2>// initGfx().fim</span></span>
</div><b>
<span class=sc2>// Montamos o cubo e o clonamos duas vezes</span>
montarCubo();  </b>
Nesta função o cubo é montado  dinamicamente  durante  o  runtime  da
aplicação ao invés de ser carregado do disco ou criado  a  partir  da
função <span class=prg>Mesh.box()</span>.  Utilizamos  este jeito para exemplificar o uso da
classe  <b class=prg>GraphicStream</b>  que  representa  um recipiente com os dados de
criação do cubo.

<b>clonarCubo();  </b>
Esta função realiza a cópia do cubo original  estabelecendo  no  cubo
clonado um outro formato de vértice contendo posição, cor e normais.

<b>segundaClonagem();  </b>
Esta função realiza a cópia do cubo original  estabelecendo  no  cubo
clonado o formato de vértice original mais a adição de espaço para as
normais.

<b><u>2.3 Montando o cubo</u></b>
<div class=niceview><span class=prg>private </span><span class=prg>void </span>montarCubo() 
<span class=sc16>{</span>
 <span class=sc2>// Número de vértices do cubo</span>
 <span class=prg>int </span>nVerts = 8; 

 <span class=sc2>// Índices de ligação dos vértices</span>
 short[] indices = 
 <span class=sc16>{</span>
 <span class=sc4>0,1,2, <span class=sc2>// face frontal</span></span>
 <span class=sc4>1,3,2, <span class=sc2>// face frontal</span></span>
 <span class=sc4>4,5,6, <span class=sc2>// face traseira</span></span>
 <span class=sc4>6,5,7, <span class=sc2>// face traseira</span></span>
 <span class=sc4>0,5,4, <span class=sc2>// face de cima</span></span>
 <span class=sc4>0,2,5, <span class=sc2>// face de cima</span></span>
 <span class=sc4>1,6,7, <span class=sc2>// face do fundo</span></span>
 <span class=sc4>1,7,3, <span class=sc2>// face do fundo</span></span>
 <span class=sc4>0,6,1, <span class=sc2>// face esquerda</span></span>
 <span class=sc4>4,6,0, <span class=sc2>// face esquerda</span></span>
 <span class=sc4>2,3,7, <span class=sc2>// face direita</span></span>
 <span class=sc4>5,2,7  <span class=sc2>// face direita</span></span>
 <span class=sc16>};</span>

 <span class=sc2>// Vamos criar um mesh a partir do zero</span>
 cubo = <span class=prg>new </span><span class=sc5>Mesh</span>(nVerts * <span class=sc4>3</span>, nVerts, <span class=prg>MeshFlags.Managed</span>, 
 <span class=prg>CustomVertex.PositionColored.Format</span>, device);  

 <span class=sc2>// Vamos preencher o buffer de vértices</span>
 <span class=sc5>VertexBuffer </span>vb = <span class=prg>cubo.VertexBuffer;</span>

 <span class=sc2>// Produz um objeto GraphicsStream com os dados do buffer de vértices</span>
 <span class=sc5>GraphicsStream </span>data = <span class=prg>vb.Lock</span>(<span class=sc4>0</span>, <span class=sc4>0</span>, <span class=prg>LockFlags.None</span>);  

 <span class=sc2>// Configura a posição e cor dos vértices</span>
 const <span class=prg>int </span>vermelho = 0xFF0000; 
 const <span class=prg>int </span>verde = 0x00FF00; 
 const <span class=prg>int </span>azul = 0x0000FF; 
 const <span class=prg>int </span>amarelo = 0xFFFF00; 

 <span class=sc2>// Posicionamento dos vértices do cubo</span>
 <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>-1.0f</span>, <span class=sc4>1.0f</span>, <span class=sc4>1.0f</span>, vermelho ));  
 <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>-1.0f</span>, <span class=sc4>-1.0f</span>, <span class=sc4>1.0f</span>, verde ));  
 <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>1.0f</span>, <span class=sc4>1.0f</span>, <span class=sc4>1.0f</span>, vermelho ));  
 <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>1.0f</span>, <span class=sc4>-1.0f</span>, <span class=sc4>1.0f</span>, verde ));  
 <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>-1.0f</span>, <span class=sc4>1.0f</span>, <span class=sc4>-1.0f</span>, azul ));  
 <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>1.0f</span>, <span class=sc4>1.0f</span>, <span class=sc4>-1.0f</span>, azul ));  
 <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>-1.0f</span>, <span class=sc4>-1.0f</span>, <span class=sc4>-1.0f</span>, amarelo ));  
 <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>1.0f</span>, <span class=sc4>-1.0f</span>, <span class=sc4>-1.0f</span>, amarelo ));  

 <span class=sc2>// Libera o buffer de vértices para a placa de video</span>
 <span class=prg>vb.Unlock</span>();  

 <span class=sc2>// Inicializa o buffer de índices</span>
 <span class=sc5>IndexBuffer </span>ib = <span class=prg>cubo.IndexBuffer;</span>
 <span class=prg>ib.SetData</span>(indices, <span class=sc4>0</span>, <span class=prg>LockFlags.None</span>);  

 <span class=sc2>// Dispensa os objetos utilizados</span>
 <span class=prg>vb.Dispose</span>();  
 <span class=prg>ib.Dispose</span>();  

<span class=sc16>} <span class=sc2>// montarCubo().fim</span></span>
</div><b>
<span class=sc2>// Número de vértices do cubo</span>
<span class=prg>int </span>nVerts = 8; </b>
O cubo bem formado possui 8 vértices.

<div class=niceview style="border-style:dashed;">
<span class=sc2>// Índices de ligação dos vértices</span>
short[] indices = <span class=sc16>{</span>
<span class=sc4>0,1,2, 1,3,2, <span class=sc2>// face frontal</span></span>
<span class=sc4>4,5,6, 6,5,7, <span class=sc2>// face traseira</span></span>
<span class=sc4>0,5,4, 0,2,5, <span class=sc2>// face de cima</span></span>
<span class=sc4>1,6,7, 1,7,3, <span class=sc2>// face do fundo</span></span>
<span class=sc4>0,6,1, 4,6,0, <span class=sc2>// face esquerda</span></span>
<span class=sc4>2,3,7, 5,2,7  <span class=sc2>// face direita</span></span>
<span class=sc16>};</span></div>
Aqui está os dados para o buffer de índices que mapeia a  conexão das
faces.


<b><span class=sc2>// Vamos criar um mesh a partir do zero</span>
cubo = <span class=prg>new </span><span class=sc5>Mesh</span>(nVerts * <span class=sc4>3</span>, nVerts, <span class=prg>MeshFlags.Managed</span>, 
<span class=prg>CustomVertex.PositionColored.Format</span>, device); </b>
Aqui  é  criado um mesh genérico que posteriormente  vai receber  sua
configuração geométrica em forma de cubo. A função começa assinalando
que o cubo tem 24 faces, 8 vértices (<b>nVerts</b>),   ficará  hospedado  na
sessão  de  memória  gerenciada   (<span class=prg>MeshFlags.Managed</span>)   e  os  demais 
argumentos já são bem conhecidos.  Voltando para o número de faces, o 
cubo  tem  6  lados  e  cada lado tem duas faces, isso já dá 12 faces
e  contando  o  verso  de cada lado do cubo temos então mais 12 faces
totalizando as 24 faces do cubo.

<b><span class=sc2>// Vamos preencher o buffer de vértices</span>
<span class=sc5>VertexBuffer </span>vb = <span class=prg>cubo.VertexBuffer;</span></b>
Aqui é obtido a referência de acesso ao buffer de vértices do cubo.

<b><span class=sc2>// Produz um objeto GraphicsStream com os dados do buffer de vértices</span>
<span class=sc5>GraphicsStream </span>data = <span class=prg>vb.Lock</span>(<span class=sc4>0</span>, <span class=sc4>0</span>, <span class=prg>LockFlags.None</span>);  </b>
Aqui é obtido acesso ao espaço do buffer de vértices que é preenchido
na sequência com dados de cor e posição dos vértices.

<b><span class=sc2>// Configura a posição e cor dos vértices</span>
<span class=prg>const int </span>vermelho = 0xFF0000; 
<span class=prg>const int </span>verde = 0x00FF00; 
<span class=prg>const int </span>azul = 0x0000FF; 
<span class=prg>const int </span>amarelo = 0xFFFF00; </b>
Aqui definimos algumas cores como constantes para tornar mais leve  a
leitura do código logo abaixo.

<div class=niceview style="border-style:dashed;"><b><span class=sc2>// Posicionamento dos vértices do cubo</span>
<span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>-1.0f</span>, <span class=sc4>1.0f</span>, <span class=sc4>1.0f</span>, vermelho ));  
<span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>-1.0f</span>, <span class=sc4>-1.0f</span>, <span class=sc4>1.0f</span>, verde ));  
<span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>1.0f</span>, <span class=sc4>1.0f</span>, <span class=sc4>1.0f</span>, vermelho ));  
<span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>1.0f</span>, <span class=sc4>-1.0f</span>, <span class=sc4>1.0f</span>, verde ));  

<span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>-1.0f</span>, <span class=sc4>1.0f</span>, <span class=sc4>-1.0f</span>, azul ));  
<span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>1.0f</span>, <span class=sc4>1.0f</span>, <span class=sc4>-1.0f</span>, azul ));  
<span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>-1.0f</span>, <span class=sc4>-1.0f</span>, <span class=sc4>-1.0f</span>, amarelo ));  
<span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>1.0f</span>, <span class=sc4>-1.0f</span>, <span class=sc4>-1.0f</span>, amarelo ));  </b></div>
Aqui são configurados a posição e a cor dos vértices.


<b><span class=sc2>// Libera o buffer de vértices para a placa de video</span>
<span class=prg>vb.Unlock</span>();  </b>
Aqui  o  buffer de vértices é liberado para uso  pelo  DirectX  ou  a
placa de vídeo.


<b><span class=sc2>// Inicializa o buffer de índices</span>
<span class=sc5>IndexBuffer </span>ib = <span class=prg>cubo.IndexBuffer;</span>
<span class=prg>ib.SetData</span>(indices, <span class=sc4>0</span>, <span class=prg>LockFlags.None</span>);  </b>
O buffer de índices é configurado aqui nesse código.

<b><span class=sc2>// Dispensa os objetos utilizados</span>
<span class=prg>vb.Dispose</span>();  
<span class=prg>ib.Dispose</span>();  </b>
Sempre que não for mais usar os objetos, é importante usar  <span class=prg>Dispose()</span>
para liberar os recursos utilizados. Um dos problemas que a falta de
uso  do  método  <span class=prg>Dispose()</span>  pode causar é lentidão da aplicação e do
sistema operacional por  falta  de  memória que não foi devolvida ao
sistema operacional.

<b><u>2.4 Clonagem simples</u></b>
<div class=niceview><span class=prg>private </span><span class=prg>void </span>clonarCubo() 
<span class=sc16>{</span>
<span class=sc2>// Clona o cubo adicionando dados de normal</span>
cuboClonado = <span class=prg>cubo.Clone</span>( <span class=prg>MeshFlags.Managed</span>, 
<span class=prg>CustomVertex.PositionNormalColored.Format</span>, device );  

<span class=sc2>// Calcula as normais</span>
<span class=prg>cuboClonado.ComputeNormals</span>();  
<span class=sc16>} <span class=sc2>// clonarCubo().fim</span></span>
</div><b>
<span class=sc2>// Clona o cubo adicionando dados de normal</span>
cuboClonado = <span class=prg>cubo.Clone</span>( <span class=prg>MeshFlags.Managed</span>, 
<span class=prg>CustomVertex.PositionNormalColored.Format</span>, device );  </b>
Aqui o cubo que foi montado apenas com posição e cor foi clonado, com
o clone recebendo um formato de vértice diferente  e mais completo em
relação ao objeto original.

<b><span class=sc2>// Calcula as normais</span>
<span class=prg>cuboClonado.ComputeNormals</span>();  </b>
O método  <span class=prg>ComputerNormals()</span>  calcula e configura as normais que foram
adicionadas no clone no código acima.


<b><u>2.5 Clonagem refinada</u></b>
Nesta função o formato de vértice é preservado e recebe a  adição  de
espaço para o cálculo de normais.

<div class=niceview><span class=prg>private </span><span class=prg>void </span>segundaClonagem() 
<span class=sc16>{</span>
 <span class=sc2>// Verifica se o mesh possui informação de normal</span>
 <span class=sc2>// Se não possui, inclui esse dado</span>
 <span class=sc9>if </span>(( <span class=prg>cubo.VertexFormat </span>& <span class=prg>VertexFormats.Normal</span>) != <span class=prg>VertexFormats.Normal</span>) 
 <span class=sc16>{</span>
 <span class=sc2>// Acrescenta espaço para informação de normal</span>
 segundoClone = <span class=prg>cubo.Clone</span>(<span class=prg>cubo.Options.Value</span>, 
 <span class=prg>cubo.VertexFormat </span>| <span class=prg>VertexFormats.Normal</span>, device );  

 <span class=sc2>// Cálcula as normais do cubo clonado</span>
 <span class=prg>segundoClone.ComputeNormals</span>();  

 <span class=sc16>} <span class=sc2>// endif</span></span>
<span class=sc16>} <span class=sc2>// segundaClonagem().fim</span></span>
</div>
<b><span class=sc9>if </span>(( <span class=prg>cubo.VertexFormat </span>& <span class=prg>VertexFormats.Normal</span>) != <span class=prg>VertexFormats.Normal</span>) </b>
Com esse teste de bit feito pelo operador <b class=prg>and (&)</b>, é verificado se  o
objeto possui normais.  Se não possuir, como é o caso da aplicação, o
código abaixo é executado clonando o objeto e adicionando as normais.

<b>segundoClone = <span class=prg>cubo.Clone</span>(<span class=prg>cubo.Options.Value</span>, 
  <span class=prg>cubo.VertexFormat </span>| <span class=prg>VertexFormats.Normal</span>, device );  </b>
Esta linha clona o objeto 3d preservando os dados originais e fazendo
os acréscimos selecionados, neste caso, a adição das normais que são
calculadas na sequência dessa função.

<b><u>2.6 Renderizando a cena</u></b>
<div class=niceview><span class=prg>public </span><span class=prg>void </span>Renderizar() 
<span class=sc16>{</span>
 <span class=sc2>// Limpa os dispositivos e os buffers de apoio</span>
 <span class=prg>device.Clear</span>(<span class=prg>ClearFlags.Target </span>| <span class=prg>ClearFlags.ZBuffer</span>, <span class=prg>Color.White</span>, <span class=sc4>1.0f</span>, <span class=sc4>0</span>);  

 <span class=prg>device.BeginScene</span>();  
 <span class=sc2>// (...) Todo o código de desenhar vai aqui</span>

 <span class=sc2>// Atualiza a câmera</span>
 AtualizarCamera();  
 AtualizarLuz();  

 <span class=sc2>// Mostra primeiro cubo clonado</span>
 <span class=prg>device.VertexFormat </span>= <span class=prg>CustomVertex.PositionNormalColored.Format;</span>
 posicao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>-2.0f</span>, <span class=sc4>-2.0f</span>, <span class=sc4>-7.0f</span>);  
 rotacao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>-10</span>, 10, <span class=sc4>0</span>);  
 g_props = <span class=prg>new </span>Propriedades3D(posicao, rotacao);  
 desenharObjeto(cuboClonado, g_props);  

 <span class=sc2>// Mostra cubo original</span>
 <span class=prg>device.VertexFormat </span>= <span class=prg>CustomVertex.PositionColored.Format;</span>
 posicao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>0.0f</span>, <span class=sc4>2.0f</span>, <span class=sc4>-7.0f</span>);  
 g_props = <span class=prg>new </span>Propriedades3D(posicao, rotacao);  
 desenharObjeto(cubo, g_props);  

 <span class=sc2>// Mostra segundo cubo clonado</span>
 <span class=prg>device.VertexFormat </span>= <span class=prg>CustomVertex.PositionNormalColored.Format;</span>
 posicao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>2.0f</span>, <span class=sc4>-2.0f</span>, <span class=sc4>-7.0f</span>);  
 g_props = <span class=prg>new </span>Propriedades3D(posicao, rotacao);  
 desenharObjeto(segundoClone, g_props);  

 <span class=sc2>// Verifica se cubo tem informação de normal</span>
 <span class=sc9>if </span>((<span class=prg>cubo.VertexFormat </span>& <span class=prg>VertexFormats.Normal</span>)  != <span class=prg>VertexFormats.Normal</span>)  
 MostrarMensagem(20, 100, <span class=sc6>"Cubo não tem informação de normal"</span>);  
 else</span>
 MostrarMensagem(20, 100, <span class=sc6>"Cubo tem informação de normal"</span>);  

 <span class=sc2>// Verifica se cubo clonado tem informação de normal</span>
 <span class=sc9>if </span>((<span class=prg>cuboClonado.VertexFormat </span>& <span class=prg>VertexFormats.Normal</span>)  != <span class=prg>VertexFormats.Normal</span>)  
 MostrarMensagem(220, 240, <span class=sc6>"cuboClonado não tem informação de normal"</span>);  
 else</span>
 MostrarMensagem(200, 420, <span class=sc6>"cuboClonado tem informação de normal"</span>);  

 <span class=prg>device.EndScene</span>();  

 <span class=sc2>// Apresenta a cena renderizada na tela</span>
 <span class=prg>device.Present</span>();  

 <span class=sc2>// Libera a janela para processar outros eventos</span>
 <span class=prg>Application.DoEvents</span>();  
<span class=sc16>} <span class=sc2>// Renderizar().fim</span></span>
</div><b>
<span class=sc2>// Mostra primeiro cubo clonado</span>
<span class=prg>device.VertexFormat </span>= <span class=prg>CustomVertex.PositionNormalColored.Format;</span>
posicao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>-2.0f</span>, <span class=sc4>-2.0f</span>, <span class=sc4>-7.0f</span>);  
rotacao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>-10</span>, 10, <span class=sc4>0</span>);  
g_props = <span class=prg>new </span>Propriedades3D(posicao, rotacao);  
desenharObjeto(cuboClonado, g_props);  </b>
Aqui é renderizado o primeiro cubo clonado.

<b><span class=sc2>// Mostra cubo original</span>
<span class=prg>device.VertexFormat </span>= <span class=prg>CustomVertex.PositionColored.Format;</span>
posicao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>0.0f</span>, <span class=sc4>2.0f</span>, <span class=sc4>-7.0f</span>);  
g_props = <span class=prg>new </span>Propriedades3D(posicao, rotacao);  
desenharObjeto(cubo, g_props);  </b>
Esse primeiro cubo não apresenta dados de normais. Na presença de luz
ele será renderizado totalmente na cor preta.  Sem o uso de luz,  ele
será renderizado colorido como todos os outros.

<b><span class=sc2>// Mostra segundo cubo clonado</span>
<span class=prg>device.VertexFormat </span>= <span class=prg>CustomVertex.PositionNormalColored.Format;</span>
posicao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>2.0f</span>, <span class=sc4>-2.0f</span>, <span class=sc4>-7.0f</span>);  
g_props = <span class=prg>new </span>Propriedades3D(posicao, rotacao);  
desenharObjeto(segundoClone, g_props);  </b>
Aqui é renderizado o segundo clone.

<div class=niceview style="border-style:dashed;"><b>
<span class=sc2>// Verifica se cubo tem informação de normal</span>
<span class=sc9>if </span>((<span class=prg>cubo.VertexFormat </span>& <span class=prg>VertexFormats.Normal</span>)  != <span class=prg>VertexFormats.Normal</span>)  
MostrarMensagem(20, 100, <span class=sc6>"Cubo não tem informação de normal"</span>);  
else</span>
MostrarMensagem(20, 100, <span class=sc6>"Cubo tem informação de normal"</span>);  

<span class=sc2>// Verifica se cubo clonado tem informação de normal</span>
<span class=sc9>if </span>((<span class=prg>cuboClonado.VertexFormat </span>& <span class=prg>VertexFormats.Normal</span>)  != <span class=prg>VertexFormats.Normal</span>)  
MostrarMensagem(220, 240, <span class=sc6>"cuboClonado não tem informação de normal"</span>);  
else</span>
MostrarMensagem(200, 420, <span class=sc6>"cuboClonado tem informação de normal"</span>);  </b></div>
Esse código é para fixar como se faz a  verificação  da  presença  de
normais no objeto.


<b><u>3. Código fonte do projeto de exemplo:prj_Clonagem</u></b>
<div class=prg-code>
<img src=images\prj_Clonagem.png>

<span class=sc2>// prj_Clonagem - Arquivo: Tela.cs</span>
<span class=sc2>// Esse projeto mostra como clonar meshes</span>
<span class=sc2>// Produzido por www.gameprog.com.br</span>
<span class=sc2>// Versão Dx gerenciado: 1.0.2902.0(X/3D) 1.0.2911.0 (3DX)</span>
<span class=sc16>using </span><span class=sc16>System;</span>
<span class=sc16>using </span><span class=prg>System.Drawing;</span>
<span class=sc16>using </span><span class=prg>System.ComponentModel;</span>
<span class=sc16>using </span><span class=prg>System.Windows.Forms;</span>
<span class=sc16>using </span><span class=prg>Microsoft.DirectX;</span>
<span class=sc16>using </span><span class=prg>Microsoft.DirectX.Direct3D;</span>
<span class=sc16>using </span>Direct3D = <span class=prg>Microsoft.DirectX.Direct3D;</span>

<span class=sc16>namespace </span>prj_Clonagem 
<span class=sc16>{</span>

  <span class=sc2>// Estrutura para propriedades 3d do objeto</span>
  <span class=sc2>// posição e rotação</span>
  <span class=prg>struct </span>Propriedades3D 
  <span class=sc16>{</span>
    <span class=prg>public </span><span class=sc5>Vector3 </span>position; 
    <span class=prg>public </span><span class=sc5>Vector3 </span>rotation; 

    <span class=prg>public </span>Propriedades3D(<span class=sc5>Vector3 </span>pos, <span class=sc5>Vector3 </span>rot) 
    <span class=sc16>{</span>
      position = pos; 
      rotation = rot; 
    <span class=sc16>}</span>
  <span class=sc16>};</span>

  <span class=prg>public </span><span class=prg>partial </span><span class=prg>class </span>Tela : <span class=sc5>Form</span>
  <span class=sc16>{</span>

    <span class=sc2>// Para criação do dispositivo gráfico</span>
    <span class=prg>private </span><span class=sc5>Device </span>device = <span class=prg>null;</span>

    <span class=sc2>// Essa variável atualizada a cada ciclo ocasionará</span>
    <span class=sc2>// a animação do objeto</span>
    <span class=prg>private </span><span class=prg>float </span>angulo = <span class=sc4>0.0f;</span>

    <span class=sc2>// Controla iluminação</span>
    <span class=prg>bool </span>estadoLuz = <span class=prg>true;</span>

    <span class=sc2>// Vetores para a posição e rotação do objeto 3d</span>
    <span class=sc5>Vector3 </span>posicao, rotacao; 

    <span class=sc2>// Variável global para propriedade dos objetos</span>
    Propriedades3D g_props; 

    <span class=sc2>// Objeto Font do DirectX para mostrar texto </span>
    <span class=prg>private </span><span class=prg>Direct3D.Font </span>dxfMensagem = <span class=prg>null;</span>

    <span class=sc2>// Objeto Font tradicional do namespace System.Drawing</span>
    <span class=prg>private </span><span class=prg>System.Drawing.Font </span>g_font = <span class=prg>null;</span>

    <span class=sc2>// Variáveis para guardar as malhas tridimensionais</span>
    <span class=prg>private </span><span class=sc5>Mesh </span>cubo = <span class=prg>null;</span>
    <span class=prg>private </span><span class=sc5>Mesh </span>cuboClonado = <span class=prg>null;</span>
    <span class=prg>private </span><span class=sc5>Mesh </span>segundoClone = <span class=prg>null;</span>

    <span class=sc2>// (...)</span>

    <span class=prg>public </span>Tela() 
    <span class=sc16>{</span>
      <span class=sc2>// Inicialização dos componentes.</span>
      InitializeComponent();  
      <span class=prg>this.Size </span>= <span class=prg>new </span>Size(640, 480);  
      <span class=prg>this.SetStyle</span>(<span class=prg>ControlStyles.AllPaintingInWmPaint </span>| <span class=prg>ControlStyles.Opaque</span>, <span class=prg>true</span>);  
    <span class=sc16>} <span class=sc2>// construtor</span></span>

    <span class=prg>public </span><span class=prg>void </span>initGfx() 
    <span class=sc16>{</span>

      <span class=sc2>// Configuração dos parâmetros de apresentação</span>
      <span class=sc5>PresentParameters </span>pps = <span class=prg>new </span><span class=sc5>PresentParameters</span>();  
      <span class=prg>pps.Windowed </span>= <span class=prg>true;</span>
      <span class=prg>pps.SwapEffect </span>= <span class=prg>SwapEffect.Discard;</span>
      <span class=prg>pps.EnableAutoDepthStencil </span>= <span class=prg>true;</span>
      <span class=prg>pps.AutoDepthStencilFormat </span>= <span class=prg>DepthFormat.D16;</span>

      <span class=sc2>// Adaptador default, processamento no hardware, processamento de vértice</span>
      <span class=sc2>// no software, janela (this), parâmetros de apresentação (pps)</span>
      <span class=prg>int </span>adaptador = 0; 
      device = <span class=prg>new </span><span class=sc5>Device</span>(adaptador, <span class=prg>DeviceType.Hardware</span>, <span class=prg>this</span>, 
        <span class=prg>CreateFlags.SoftwareVertexProcessing</span>, pps);  

      <span class=sc2>// Configuração das fontes para mostrar mensagens</span>
      g_font = <span class=prg>new </span><span class=prg>System.Drawing.Font</span>(<span class=sc6>"Arial"</span>, <span class=sc4>16.0f</span>, <span class=prg>FontStyle.Bold</span>);  
      dxfMensagem = <span class=prg>new </span><span class=prg>Direct3D.Font</span>(device, g_font);  

      <span class=sc2>// Montamos o cubo e o clonamos duas vezes</span>
      montarCubo();  
      clonarCubo();  
      segundaClonagem();  
    <span class=sc16>} <span class=sc2>// initGfx().fim</span></span>


    <span class=prg>private </span><span class=prg>void </span>AtualizarCamera() 
    <span class=sc16>{</span>
      <span class=sc2>// Dados para a configuração da matriz de projeção</span>
      <span class=prg>int largura = this.Width; <span class=sc2>// largura da janela</span></span>
      <span class=prg>int altura = this.Height;  <span class=sc2>// altura da janela</span></span>
      <span class=prg>float aspecto = largura / altura; <span class=sc2>// aspecto dos gráficos</span></span>
      <span class=prg>float campo_visao = (float)Math.PI / 4; <span class=sc2>// Campo de visão</span></span>
      <span class=prg>float </span>corte_perto = <span class=sc4>1.0f;</span>
      <span class=prg>float </span>corte_longe = <span class=sc4>100.0f;</span>

      <span class=sc2>// Atualiza angulo para dar movivento</span>
      angulo += <span class=sc4>0.04f;</span>

      <span class=sc2>// Mostra a parte interna do polígono</span>
      <span class=sc2>// Experimente desativar essa linha com a instrução de comentário</span>
      <span class=prg>device.RenderState.CullMode </span>= <span class=prg>Cull.None;</span>

      <span class=sc2>// Configura a matriz de projeção</span>
      <span class=prg>device.Transform.Projection </span>= <span class=prg>Matrix.PerspectiveFovLH</span>(campo_visao, 
          aspecto, corte_perto, corte_longe);  

      <span class=sc2>// Dados para a configuração da matriz de visualização</span>
      <span class=sc5>Vector3 </span>cam_pos = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>0</span>, <span class=sc4>0</span>, <span class=sc4>5.0f</span>);  
      <span class=sc5>Vector3 </span>cam_alvo = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>0.0f</span>, <span class=sc4>0.0f</span>, <span class=sc4>0.0f</span>);  
      <span class=sc5>Vector3 </span>cam_orientacao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>0</span>, <span class=sc4>1.0f</span>, <span class=sc4>0</span>);  

      <span class=sc2>// Configura a matriz de visualização</span>
      <span class=prg>device.Transform.View </span>= <span class=prg>Matrix.LookAtLH</span>(cam_pos, cam_alvo, cam_orientacao);  
    <span class=sc16>}  <span class=sc2>// AtualizarCamera()</span></span>


    <span class=prg>public </span><span class=prg>void </span>Renderizar() 
    <span class=sc16>{</span>

      <span class=sc2>// Limpa os dispositivos e os buffers de apoio</span>
      <span class=prg>device.Clear</span>(<span class=prg>ClearFlags.Target </span>| <span class=prg>ClearFlags.ZBuffer</span>, <span class=prg>Color.White</span>, <span class=sc4>1.0f</span>, <span class=sc4>0</span>);  

      <span class=prg>device.BeginScene</span>();  
      <span class=sc2>// (...) Todo o código de desenhar vai aqui</span>

      <span class=sc2>// Atualiza a câmera</span>
      AtualizarCamera();  
      AtualizarLuz();  

      <span class=sc2>// Mostra primeiro cubo clonado</span>
      <span class=prg>device.VertexFormat </span>= <span class=prg>CustomVertex.PositionNormalColored.Format;</span>
      posicao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>-2.0f</span>, <span class=sc4>-2.0f</span>, <span class=sc4>-7.0f</span>);  
      rotacao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>-10</span>, 10, <span class=sc4>0</span>);  
      g_props = <span class=prg>new </span>Propriedades3D(posicao, rotacao);  
      desenharObjeto(cuboClonado, g_props);  

      <span class=sc2>// Mostra cubo original</span>
      <span class=prg>device.VertexFormat </span>= <span class=prg>CustomVertex.PositionColored.Format;</span>
      posicao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>0.0f</span>, <span class=sc4>2.0f</span>, <span class=sc4>-7.0f</span>);  
      g_props = <span class=prg>new </span>Propriedades3D(posicao, rotacao);  
      desenharObjeto(cubo, g_props);  

      <span class=sc2>// Mostra segundo cubo clonado</span>
      <span class=prg>device.VertexFormat </span>= <span class=prg>CustomVertex.PositionNormalColored.Format;</span>
      posicao = <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>2.0f</span>, <span class=sc4>-2.0f</span>, <span class=sc4>-7.0f</span>);  
      g_props = <span class=prg>new </span>Propriedades3D(posicao, rotacao);  
      desenharObjeto(segundoClone, g_props);  

      <span class=sc2>// Verifica se cubo tem informação de normal</span>
      <span class=sc9>if </span>((<span class=prg>cubo.VertexFormat </span>& <span class=prg>VertexFormats.Normal</span>)  != <span class=prg>VertexFormats.Normal</span>)  
        MostrarMensagem(20, 100, <span class=sc6>"Cubo não tem informação de normal"</span>);  
      else</span>
        MostrarMensagem(20, 100, <span class=sc6>"Cubo tem informação de normal"</span>);  

      <span class=sc2>// Verifica se cubo clonado tem informação de normal</span>
      <span class=sc9>if </span>((<span class=prg>cuboClonado.VertexFormat </span>& <span class=prg>VertexFormats.Normal</span>)  != <span class=prg>VertexFormats.Normal</span>)  
        MostrarMensagem(220, 240, <span class=sc6>"cuboClonado não tem informação de normal"</span>);  
      else</span>
        MostrarMensagem(200, 420, <span class=sc6>"cuboClonado tem informação de normal"</span>);  

      <span class=prg>device.EndScene</span>();  

      <span class=sc2>// Apresenta a cena renderizada na tela</span>
      <span class=prg>device.Present</span>();  

      <span class=sc2>// Libera a janela para processar outros eventos</span>
      <span class=prg>Application.DoEvents</span>();  
    <span class=sc16>} <span class=sc2>// Renderizar().fim</span></span>


    <span class=prg>private </span><span class=prg>void </span>desenharObjeto(<span class=sc5>Mesh </span>obj, Propriedades3D props) 
    <span class=sc16>{</span>
      <span class=sc2>// Ajusta rotação da caixa</span>
      <span class=sc5>Matrix </span>obj_rot = <span class=prg>Matrix.RotationX</span>(<span class=prg>props.rotation.X</span>)  * 
        <span class=prg>Matrix.RotationY</span>(<span class=prg>props.rotation.Y </span>+ angulo) * 
        <span class=prg>Matrix.RotationZ</span>(<span class=prg>props.rotation.Z</span>);  

      <span class=sc2>// Ajusta posição da caixa</span>
      <span class=sc5>Matrix </span>obj_pos = <span class=prg>Matrix.Translation</span>(<span class=prg>props.position</span>);  

      <span class=sc2>// Tranfere posição e rotação para o mundo</span>
      <span class=prg>device.Transform.World </span>= obj_rot * obj_pos; 

      <span class=sc2>// Renderiza o mesh</span>
      <span class=prg>obj.DrawSubset</span>(<span class=sc4>0</span>);  
    <span class=sc16>} <span class=sc2>// desenharObjeto().fim</span></span>

    <span class=sc2>// Configuração de luz</span>
    <span class=prg>private </span><span class=prg>void </span>AtualizarLuz() 
    <span class=sc16>{</span>
      <span class=prg>device.RenderState.Lighting </span>= estadoLuz; 
      <span class=prg>device.Lights</span>[<span class=sc4>0</span>]<span class=prg>.Type </span>= <span class=prg>LightType.Directional;</span>
      <span class=prg>device.Lights</span>[<span class=sc4>0</span>]<span class=prg>.Diffuse </span>= <span class=prg>Color.White;</span>
      <span class=prg>device.Lights</span>[<span class=sc4>0</span>]<span class=prg>.Direction </span>= <span class=prg>new </span><span class=sc5>Vector3</span>(<span class=sc4>0</span>, <span class=sc4>-1</span>, <span class=sc4>-1</span>);  
      <span class=prg>device.Lights</span>[<span class=sc4>0</span>]<span class=prg>.Enabled </span>= <span class=prg>true;</span>
    <span class=sc16>} <span class=sc2>// AtualizarLuz().fim</span></span>

    <span class=prg>protected </span><span class=prg>override </span><span class=prg>void </span>OnPaint(<span class=sc5>PaintEventArgs </span>e) 
    <span class=sc16>{</span>
      <span class=sc2>// Trate outros processos padrões</span>
      <span class=prg>base.OnPaint</span>(e);  

      <span class=sc2>// Renderize a cena</span>
      <span class=prg>this.Renderizar</span>();  

      <span class=sc2>// Invalide para chamar novamente onPaint()</span>
      <span class=prg>this.Invalidate</span>();  
    <span class=sc16>} <span class=sc2>// onPaint().fim</span></span>


    <span class=prg>private </span><span class=prg>void </span>montarCubo() 
    <span class=sc16>{</span>
      <span class=sc2>// Número de vértices do cubo</span>
      <span class=prg>int </span>nVerts = 8; 

      <span class=sc2>// Índices de ligação dos vértices</span>
      short[] indices = 
      <span class=sc16>{</span>
        <span class=sc4>0,1,2, <span class=sc2>// face frontal</span></span>
        <span class=sc4>1,3,2, <span class=sc2>// face frontal</span></span>
        <span class=sc4>4,5,6, <span class=sc2>// face traseira</span></span>
        <span class=sc4>6,5,7, <span class=sc2>// face traseira</span></span>
        <span class=sc4>0,5,4, <span class=sc2>// face de cima</span></span>
        <span class=sc4>0,2,5, <span class=sc2>// face de cima</span></span>
        <span class=sc4>1,6,7, <span class=sc2>// face do fundo</span></span>
        <span class=sc4>1,7,3, <span class=sc2>// face do fundo</span></span>
        <span class=sc4>0,6,1, <span class=sc2>// face esquerda</span></span>
        <span class=sc4>4,6,0, <span class=sc2>// face esquerda</span></span>
        <span class=sc4>2,3,7, <span class=sc2>// face direita</span></span>
        <span class=sc4>5,2,7  <span class=sc2>// face direita</span></span>
      <span class=sc16>};</span>

      <span class=sc2>// Vamos criar um mesh a partir do zero</span>
      cubo = <span class=prg>new </span><span class=sc5>Mesh</span>(nVerts * <span class=sc4>3</span>, nVerts, <span class=prg>MeshFlags.Managed</span>, 
        <span class=prg>CustomVertex.PositionColored.Format</span>, device);  

      <span class=sc2>// Vamos preencher o buffer de vértices</span>
      <span class=sc5>VertexBuffer </span>vb = <span class=prg>cubo.VertexBuffer;</span>

      <span class=sc2>// Produz um objeto GraphicsStream com os dados do buffer de vértices</span>
      <span class=sc5>GraphicsStream </span>data = <span class=prg>vb.Lock</span>(<span class=sc4>0</span>, <span class=sc4>0</span>, <span class=prg>LockFlags.None</span>);  

      <span class=sc2>// Configura a posição e cor dos vértices</span>
      const <span class=prg>int </span>vermelho = 0xFF0000; 
      const <span class=prg>int </span>verde = 0x00FF00; 
      const <span class=prg>int </span>azul = 0x0000FF; 
      const <span class=prg>int </span>amarelo = 0xFFFF00; 

      <span class=sc2>// Posicionamento dos vértices do cubo</span>
      <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>-1.0f</span>, <span class=sc4>1.0f</span>, <span class=sc4>1.0f</span>, vermelho ));  
      <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>-1.0f</span>, <span class=sc4>-1.0f</span>, <span class=sc4>1.0f</span>, verde ));  
      <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>1.0f</span>, <span class=sc4>1.0f</span>, <span class=sc4>1.0f</span>, vermelho ));  
      <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>1.0f</span>, <span class=sc4>-1.0f</span>, <span class=sc4>1.0f</span>, verde ));  
      <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>-1.0f</span>, <span class=sc4>1.0f</span>, <span class=sc4>-1.0f</span>, azul ));  
      <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>1.0f</span>, <span class=sc4>1.0f</span>, <span class=sc4>-1.0f</span>, azul ));  
      <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>-1.0f</span>, <span class=sc4>-1.0f</span>, <span class=sc4>-1.0f</span>, amarelo ));  
      <span class=prg>data.Write</span>(<span class=prg>new </span><span class=prg>CustomVertex.PositionColored</span>( <span class=sc4>1.0f</span>, <span class=sc4>-1.0f</span>, <span class=sc4>-1.0f</span>, amarelo ));  

      <span class=sc2>// Libera o buffer de vértices para a placa de video</span>
      <span class=prg>vb.Unlock</span>();  

      <span class=sc2>// Inicializa o buffer de índices</span>
      <span class=sc5>IndexBuffer </span>ib = <span class=prg>cubo.IndexBuffer;</span>
      <span class=prg>ib.SetData</span>(indices, <span class=sc4>0</span>, <span class=prg>LockFlags.None</span>);  

      <span class=sc2>// Dispensa os objetos utilizados</span>
      <span class=prg>vb.Dispose</span>();  
      <span class=prg>ib.Dispose</span>();  
    <span class=sc16>} <span class=sc2>// montarCubo().fim</span></span>


    <span class=prg>private </span><span class=prg>void </span>clonarCubo() 
    <span class=sc16>{</span>
      <span class=sc2>// Clona o cubo adicionando dados de normal</span>
      cuboClonado = <span class=prg>cubo.Clone</span>( <span class=prg>MeshFlags.Managed</span>, 
        <span class=prg>CustomVertex.PositionNormalColored.Format</span>, device );  

      <span class=sc2>// Cálcula as normais</span>
      <span class=prg>cuboClonado.ComputeNormals</span>();  
    <span class=sc16>} <span class=sc2>// clonarCubo().fim</span></span>


    <span class=prg>private </span><span class=prg>void </span>segundaClonagem() 
    <span class=sc16>{</span>
      <span class=sc2>// Verifica se o mesh possui informação de normal</span>
      <span class=sc2>// Se não possui, inclui esse dado</span>
      <span class=sc9>if </span>(( <span class=prg>cubo.VertexFormat </span>& <span class=prg>VertexFormats.Normal</span>) != <span class=prg>VertexFormats.Normal</span>) 
      <span class=sc16>{</span>
        <span class=sc2>// Acrescenta espaço para informação de normal</span>
        segundoClone = <span class=prg>cubo.Clone</span>(<span class=prg>cubo.Options.Value</span>, 
          <span class=prg>cubo.VertexFormat </span>| <span class=prg>VertexFormats.Normal</span>, device );  

        <span class=sc2>// Cálcula as normais do cubo clonado</span>
        <span class=prg>segundoClone.ComputeNormals</span>();  

      <span class=sc16>} <span class=sc2>// endif</span></span>
    <span class=sc16>} <span class=sc2>// segundaClonagem().fim</span></span>

    <span class=sc2>// Mostra mensagens na posição (x,y) da tela</span>
    <span class=prg>private </span><span class=prg>void </span>MostrarMensagem(<span class=prg>int </span>xpos, <span class=prg>int </span>ylin, <span class=prg>string </span>txt) 
    <span class=sc16>{</span>
      <span class=sc2>// Configura posição</span>
      <span class=sc5>Rectangle </span>position = <span class=prg>new </span><span class=sc5>Rectangle</span>(xpos, ylin, <span class=sc4>0</span>, <span class=sc4>0</span>);  

      <span class=sc2>// Mostra texto</span>
      <span class=prg>dxfMensagem.DrawText</span>(<span class=prg>null</span>, txt, position, 
        <span class=prg>DrawTextFormat.NoClip</span>, <span class=prg>Color.Blue</span>);  
    <span class=sc16>} <span class=sc2>// MostrarMensagem().fim</span></span>

    <span class=prg>private </span><span class=prg>void </span>Tela_KeyDown(<span class=sc5>object </span>sender, <span class=sc5>KeyEventArgs </span>e) 
    <span class=sc16>{</span>

      <span class=sc9>if </span>(<span class=prg>e.KeyCode </span>== <span class=prg>Keys.Space</span>)  estadoLuz = !estadoLuz; 
    <span class=sc16>} <span class=sc2>// Tela_KeyDown().fim</span></span>

  <span class=sc16>} <span class=sc2>// fim da classe</span></span>
<span class=sc16>} <span class=sc2>// fim do namespace</span></span>
</div>
<hr>
<table align='bottom' border='0' cellspacing='0' cellpadding='0' width='20%'>
<tr><td><a href='mdx9.html#start' style='color:blue'> index </a></td>
<td><a href='track11-1.html' style='color:blue'>&lt;&lt;</a></td>
<td><a href='track11-3.html' style='color:blue'>&gt;&gt;</a></td></tr></table><pre>
<hr><div style='background-color:lightyellow;color:blue'>
<center>Produzido por Gameprog: Jair Pereira - Março/2014 ©
gameprog.br@gmail.com
<a href='http://www.gameprog.com.br'>http://www.gameprog.com.br</center><hr></div></div></body></html>